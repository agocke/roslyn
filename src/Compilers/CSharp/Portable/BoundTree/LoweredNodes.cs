// <auto-generated />
#nullable enable

using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Diagnostics;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Threading;
using System.Text;
using Microsoft.CodeAnalysis.Collections;
using Roslyn.Utilities;

using Microsoft.CodeAnalysis.Text;
using Microsoft.CodeAnalysis.CSharp.Symbols;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace Microsoft.CodeAnalysis.CSharp
{
    internal enum LoweredKind: byte
    {
        FieldEqualsValue,
        PropertyEqualsValue,
        ParameterEqualsValue,
        GlobalStatementInitializer,
        DeconstructValuePlaceholder,
        TupleOperandPlaceholder,
        AwaitableValuePlaceholder,
        DisposableValuePlaceholder,
        ObjectOrCollectionValuePlaceholder,
        Dup,
        PassByCopy,
        BadExpression,
        BadStatement,
        ExtractedFinallyBlock,
        TypeExpression,
        TypeOrValueExpression,
        NamespaceExpression,
        UnaryOperator,
        IncrementOperator,
        AddressOfOperator,
        PointerIndirectionOperator,
        PointerElementAccess,
        RefTypeOperator,
        MakeRefOperator,
        RefValueOperator,
        FromEndIndexExpression,
        RangeExpression,
        BinaryOperator,
        TupleBinaryOperator,
        UserDefinedConditionalLogicalOperator,
        CompoundAssignmentOperator,
        AssignmentOperator,
        DeconstructionAssignmentOperator,
        NullCoalescingOperator,
        NullCoalescingAssignmentOperator,
        ConditionalOperator,
        ArrayAccess,
        ArrayLength,
        AwaitableInfo,
        AwaitExpression,
        TypeOfOperator,
        MethodDefIndex,
        MaximumMethodDefIndex,
        InstrumentationPayloadRoot,
        ModuleVersionId,
        ModuleVersionIdString,
        SourceDocumentIndex,
        MethodInfo,
        FieldInfo,
        DefaultLiteral,
        DefaultExpression,
        IsOperator,
        AsOperator,
        SizeOfOperator,
        Conversion,
        ReadOnlySpanFromArray,
        ArgList,
        ArgListOperator,
        FixedLocalCollectionInitializer,
        SequencePoint,
        SequencePointWithSpan,
        Block,
        Scope,
        StateMachineScope,
        LocalDeclaration,
        MultipleLocalDeclarations,
        UsingLocalDeclarations,
        LocalFunctionStatement,
        NoOpStatement,
        ReturnStatement,
        YieldReturnStatement,
        YieldBreakStatement,
        ThrowStatement,
        ExpressionStatement,
        BreakStatement,
        ContinueStatement,
        SwitchStatement,
        SwitchDispatch,
        IfStatement,
        DoStatement,
        WhileStatement,
        ForStatement,
        ForEachStatement,
        ForEachDeconstructStep,
        UsingStatement,
        FixedStatement,
        LockStatement,
        TryStatement,
        CatchBlock,
        Literal,
        ThisReference,
        PreviousSubmissionReference,
        HostObjectMemberReference,
        BaseReference,
        Local,
        PseudoVariable,
        RangeVariable,
        Parameter,
        LabelStatement,
        GotoStatement,
        LabeledStatement,
        Label,
        StatementList,
        ConditionalGoto,
        SwitchExpressionArm,
        UnconvertedSwitchExpression,
        ConvertedSwitchExpression,
        DecisionDag,
        EvaluationDecisionDagNode,
        TestDecisionDagNode,
        WhenDecisionDagNode,
        LeafDecisionDagNode,
        DagTemp,
        DagTypeTest,
        DagNonNullTest,
        DagExplicitNullTest,
        DagValueTest,
        DagDeconstructEvaluation,
        DagTypeEvaluation,
        DagFieldEvaluation,
        DagPropertyEvaluation,
        DagIndexEvaluation,
        SwitchSection,
        SwitchLabel,
        SequencePointExpression,
        Sequence,
        SpillSequence,
        DynamicMemberAccess,
        DynamicInvocation,
        ConditionalAccess,
        LoweredConditionalAccess,
        ConditionalReceiver,
        ComplexConditionalReceiver,
        MethodGroup,
        PropertyGroup,
        Call,
        EventAssignmentOperator,
        Attribute,
        ObjectCreationExpression,
        TupleLiteral,
        ConvertedTupleLiteral,
        DynamicObjectCreationExpression,
        NoPiaObjectCreationExpression,
        ObjectInitializerExpression,
        ObjectInitializerMember,
        DynamicObjectInitializerMember,
        CollectionInitializerExpression,
        CollectionElementInitializer,
        DynamicCollectionElementInitializer,
        ImplicitReceiver,
        AnonymousObjectCreationExpression,
        AnonymousPropertyDeclaration,
        NewT,
        DelegateCreationExpression,
        ArrayCreation,
        ArrayInitialization,
        StackAllocArrayCreation,
        ConvertedStackAllocExpression,
        FieldAccess,
        HoistedFieldAccess,
        PropertyAccess,
        EventAccess,
        IndexerAccess,
        IndexOrRangePatternIndexerAccess,
        DynamicIndexerAccess,
        Lambda,
        UnboundLambda,
        QueryClause,
        TypeOrInstanceInitializers,
        NameOfOperator,
        InterpolatedString,
        StringInsert,
        IsPatternExpression,
        ConstantPattern,
        DiscardPattern,
        DeclarationPattern,
        RecursivePattern,
        ITuplePattern,
        Subpattern,
        DiscardExpression,
        ThrowExpression,
        OutVariablePendingInference,
        DeconstructionVariablePendingInference,
        OutDeconstructVarPendingInference,
        NonConstructorMethodBody,
        ConstructorMethodBody,
        ExpressionWithNullability,
    }


    internal abstract partial class LoweredNode : BoundNode
    {
        private readonly LoweredKind _kind;
        private LoweredNodeAttributes _attributes;

        public readonly SyntaxNode Syntax;

        [Flags()]
        private enum LoweredNodeAttributes : short
        {
            HasErrors = 1 << 0,
            CompilerGenerated = 1 << 1,
            IsSuppressed = 1 << 2,

            // Bit 3: 1 if the node has maybe-null state, 0 if the node is not null
            // Bits 4 and 5: 01 if the node is not annotated, 10 if the node is annotated, 11 if the node is disabled
            TopLevelFlowStateMaybeNull = 1 << 3,
            TopLevelNotAnnotated = 1 << 4,
            TopLevelAnnotated = 1 << 5,
            TopLevelNone = TopLevelAnnotated | TopLevelNotAnnotated,
            TopLevelAnnotationMask = TopLevelNone,

            /// <summary>
            /// Captures the fact that consumers of the node already checked the state of the WasCompilerGenerated bit.
            /// Allows to assert on attempts to set WasCompilerGenerated bit after that.
            /// </summary>
            WasCompilerGeneratedIsChecked = 1 << 6,
            WasTopLevelNullabilityChecked = 1 << 7,

            /// <summary>
            /// Captures the fact that the node was either converted to some type, or converted to its natural
            /// type.  This is used to check the fact that every rvalue must pass through one of the two,
            /// so that expressions like tuple literals and switch expressions can reliably be rewritten once
            /// the target type is known.
            /// </summary>
            WasConverted = 1 << 8,

            AttributesPreservedInClone = HasErrors | CompilerGenerated | IsSuppressed | WasConverted,
        }

        protected new LoweredNode MemberwiseClone()
        {
            var result = (LoweredNode)base.MemberwiseClone();
            result._attributes &= LoweredNodeAttributes.AttributesPreservedInClone;
            return result;
        }

        protected LoweredNode(LoweredKind kind, SyntaxNode syntax)
        {
            Debug.Assert(
                kind == LoweredKind.SequencePoint ||
                kind == LoweredKind.SequencePointExpression ||
                kind == (LoweredKind)byte.MaxValue || // used in SpillSequenceSpiller
                syntax != null);

            _kind = kind;
            this.Syntax = syntax;
        }

        protected LoweredNode(LoweredKind kind, SyntaxNode syntax, bool hasErrors)
            : this(kind, syntax)
        {
            if (hasErrors)
            {
                _attributes = LoweredNodeAttributes.HasErrors;
            }
        }

        /// <summary>
        /// Determines if a bound node, or associated syntax or type has an error (not a warning) 
        /// diagnostic associated with it.
        /// 
        /// Typically used in the binder as a way to prevent cascading errors. 
        /// In most other cases a more lightweight HasErrors should be used.
        /// </summary>
        public bool HasAnyErrors
        {
            get
            {
                // NOTE: check Syntax rather than WasCompilerGenerated because sequence points can have null syntax.
                if (this.HasErrors || this.Syntax != null && this.Syntax.HasErrors)
                {
                    return true;
                }
                var expression = this as LoweredExpression;
                return expression?.Type?.IsErrorType() == true;
            }
        }

        /// <summary>
        /// Determines if a bound node, or any child, grandchild, etc has an error (not warning)
        /// diagnostic associated with it. The HasError bit is initially set for a node by providing it
        /// to the node constructor. If any child nodes of a node have
        /// the HasErrors bit set, then it is automatically set to true on the parent bound node.
        /// 
        /// HasErrors indicates that the tree is not emittable and used to short-circuit lowering/emit stages.
        /// NOTE: not having HasErrors does not guarantee that we do not have any diagnostic associated
        ///       with corresponding syntax or type.
        /// </summary>
        public bool HasErrors
        {
            get
            {
                return (_attributes & LoweredNodeAttributes.HasErrors) != 0;
            }
            private set
            {
                if (value)
                {
                    _attributes |= LoweredNodeAttributes.HasErrors;
                }
                else
                {
                    Debug.Assert((_attributes & LoweredNodeAttributes.HasErrors) == 0,
                        "HasErrors flag should not be reset here");
                }
            }
        }

        public SyntaxTree SyntaxTree
        {
            get
            {
                return Syntax?.SyntaxTree;
            }
        }

        protected void CopyAttributes(LoweredNode original)
        {
            this.WasCompilerGenerated = original.WasCompilerGenerated;

            Debug.Assert(original is LoweredExpression || !original.IsSuppressed);
            this.IsSuppressed = original.IsSuppressed;
#if DEBUG
            this.WasConverted = original.WasConverted;
#endif
        }

        /// <remarks>
        /// NOTE: not generally set in rewriters.
        /// </remarks>
        public bool WasCompilerGenerated
        {
            get
            {
#if DEBUG
                _attributes |= LoweredNodeAttributes.WasCompilerGeneratedIsChecked;
#endif
                return (_attributes & LoweredNodeAttributes.CompilerGenerated) != 0;
            }
            internal set
            {
#if DEBUG
                Debug.Assert((_attributes & LoweredNodeAttributes.WasCompilerGeneratedIsChecked) == 0,
                    "compiler generated flag should not be set after reading it");
#endif

                if (value)
                {
                    _attributes |= LoweredNodeAttributes.CompilerGenerated;
                }
                else
                {
                    Debug.Assert((_attributes & LoweredNodeAttributes.CompilerGenerated) == 0,
                        "compiler generated flag should not be reset here");
                }
            }
        }

        // PERF: it is very uncommon for a flag being forcibly reset 
        //       so we do not support it in general (making the commonly used implementation simpler) 
        //       and instead have a special method to do resetting.
        public void ResetCompilerGenerated(bool newCompilerGenerated)
        {
#if DEBUG
            Debug.Assert((_attributes & LoweredNodeAttributes.WasCompilerGeneratedIsChecked) == 0,
                "compiler generated flag should not be set after reading it");
#endif
            if (newCompilerGenerated)
            {
                _attributes |= LoweredNodeAttributes.CompilerGenerated;
            }
            else
            {
                _attributes &= ~LoweredNodeAttributes.CompilerGenerated;
            }
        }

        /// <summary>
        /// Top level nullability for the node. This should not be used by flow analysis.
        /// </summary>
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        protected NullabilityInfo TopLevelNullability
        {
            get
            {
#if DEBUG
                _attributes |= LoweredNodeAttributes.WasTopLevelNullabilityChecked;
#endif

                // This is broken out into a separate property so the debugger can display the
                // top level nullability without setting the _attributes flag and interfering
                // with the normal operation of tests.
                return TopLevelNullabilityCore;
            }
            set
            {
#if DEBUG
                Debug.Assert((_attributes & LoweredNodeAttributes.WasTopLevelNullabilityChecked) == 0,
                    "bound node nullability should not be set after reading it");
#endif
                _attributes &= ~(LoweredNodeAttributes.TopLevelAnnotationMask | LoweredNodeAttributes.TopLevelFlowStateMaybeNull);

                _attributes |= value.Annotation switch
                {
                    CodeAnalysis.NullableAnnotation.Annotated => LoweredNodeAttributes.TopLevelAnnotated,
                    CodeAnalysis.NullableAnnotation.NotAnnotated => LoweredNodeAttributes.TopLevelNotAnnotated,
                    CodeAnalysis.NullableAnnotation.None => LoweredNodeAttributes.TopLevelNone,
                    var a => throw ExceptionUtilities.UnexpectedValue(a),
                };

                switch (value.FlowState)
                {
                    case CodeAnalysis.NullableFlowState.MaybeNull:
                        _attributes |= LoweredNodeAttributes.TopLevelFlowStateMaybeNull;
                        break;

                    case CodeAnalysis.NullableFlowState.NotNull:
                        // Not needed: unset is NotNull
                        break;

                    default:
                        throw ExceptionUtilities.UnexpectedValue(value.FlowState);
                }
            }
        }

        /// <summary>
        /// This is for debugger display use only: <see cref="TopLevelNullability"/> will set the LoweredNodeAttributes.WasTopLevelNullabilityChecked
        /// bit in the boundnode properties, which will break debugging. This allows the debugger to display the current value without setting the bit.
        /// </summary>
        private NullabilityInfo TopLevelNullabilityCore
        {
            get
            {
                if ((_attributes & LoweredNodeAttributes.TopLevelAnnotationMask) == 0)
                {
                    return default;
                }

                var annotation = (_attributes & LoweredNodeAttributes.TopLevelAnnotationMask) switch
                {
                    LoweredNodeAttributes.TopLevelAnnotated => CodeAnalysis.NullableAnnotation.Annotated,
                    LoweredNodeAttributes.TopLevelNotAnnotated => CodeAnalysis.NullableAnnotation.NotAnnotated,
                    LoweredNodeAttributes.TopLevelNone => CodeAnalysis.NullableAnnotation.None,
                    var mask => throw ExceptionUtilities.UnexpectedValue(mask)
                };

                var flowState = (_attributes & LoweredNodeAttributes.TopLevelFlowStateMaybeNull) == 0 ? CodeAnalysis.NullableFlowState.NotNull : CodeAnalysis.NullableFlowState.MaybeNull;

                return new NullabilityInfo(annotation, flowState);
            }
        }

        public bool IsSuppressed
        {
            get
            {
                return (_attributes & LoweredNodeAttributes.IsSuppressed) != 0;
            }
            protected set
            {
                Debug.Assert((_attributes & LoweredNodeAttributes.IsSuppressed) == 0, "flag should not be set twice or reset");
                if (value)
                {
                    _attributes |= LoweredNodeAttributes.IsSuppressed;
                }
            }
        }

#if DEBUG
        /// <summary>
        /// WasConverted flag is used for debugging purposes only (not to direct the behavior of semantic analysis).
        /// It is used on LoweredLocal and LoweredParameter to check that every such rvalue that has not been converted to
        /// some type has been converted to its natural type.
        /// </summary>
        public bool WasConverted
        {
            get
            {
                return (_attributes & LoweredNodeAttributes.WasConverted) != 0;
            }
            protected set
            {
                Debug.Assert((_attributes & LoweredNodeAttributes.WasConverted) == 0, "WasConverted flag should not be set twice or reset");
                if (value)
                {
                    _attributes |= LoweredNodeAttributes.WasConverted;
                }
            }
        }
#endif

        public LoweredKind Kind
        {
            get
            {
                return _kind;
            }
        }

        public virtual LoweredNode Accept(LoweredTreeVisitor visitor)
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Return a clone of the current node with the HasErrors flag set.
        /// </summary>
        internal LoweredNode WithHasErrors()
        {
            if (this.HasErrors)
                return this;

            LoweredNode clone = MemberwiseClone();
            clone.HasErrors = true;
            return clone;
        }

#if DEBUG
        private class MyTreeDumper : TreeDumper
        {
            private MyTreeDumper() : base() { }

            public static new string DumpCompact(TreeDumperNode root)
            {
                return new MyTreeDumper().DoDumpCompact(root);
            }

            protected override string DumperString(object o)
            {
                return (o is SynthesizedLocal l) ? l.DumperString() : base.DumperString(o);
            }
        }

        internal virtual string Dump()
        {
            return MyTreeDumper.DumpCompact(LoweredTreeDumperNodeProducer.MakeTree(this));
        }
#endif

        internal string GetDebuggerDisplay()
        {
            var result = GetType().Name;
            if (Syntax != null)
            {
                result += " " + Syntax.ToString();
            }
            return result;
        }

        [Conditional("DEBUG")]
        public void CheckLocalsDefined()
        {
#if DEBUG
            LocalsScanner.CheckLocalsDefined(this);
#endif
        }

    }

    internal abstract partial class LoweredInitializer : LoweredNode
    {
        protected LoweredInitializer(LoweredKind kind, SyntaxNode syntax, bool hasErrors)
            : base(kind, syntax, hasErrors)
        {
        }

        protected LoweredInitializer(LoweredKind kind, SyntaxNode syntax)
            : base(kind, syntax)
        {
        }

    }

    internal abstract partial class LoweredEqualsValue : LoweredInitializer
    {
        protected LoweredEqualsValue(LoweredKind kind, SyntaxNode syntax, ImmutableArray<LocalSymbol> locals, LoweredExpression value, bool hasErrors = false)
            : base(kind, syntax, hasErrors)
        {

            RoslynDebug.Assert(!locals.IsDefault, "Field 'locals' cannot be null (use Null=\"allow\" in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(value is object, "Field 'value' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

            this.Locals = locals;
            this.Value = value;
        }


        public ImmutableArray<LocalSymbol> Locals { get; }

        public LoweredExpression Value { get; }
    }

    internal sealed partial class LoweredFieldEqualsValue : LoweredEqualsValue
    {
        public LoweredFieldEqualsValue(SyntaxNode syntax, FieldSymbol field, ImmutableArray<LocalSymbol> locals, LoweredExpression value, bool hasErrors = false)
            : base(LoweredKind.FieldEqualsValue, syntax, locals, value, hasErrors || value.HasErrors())
        {

            RoslynDebug.Assert(field is object, "Field 'field' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(!locals.IsDefault, "Field 'locals' cannot be null (use Null=\"allow\" in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(value is object, "Field 'value' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

            this.Field = field;
        }


        public FieldSymbol Field { get; }
        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitFieldEqualsValue(this);

        public LoweredFieldEqualsValue Update(FieldSymbol field, ImmutableArray<LocalSymbol> locals, LoweredExpression value)
        {
            if (!Symbols.SymbolEqualityComparer.ConsiderEverything.Equals(field, this.Field) || locals != this.Locals || value != this.Value)
            {
                var result = new LoweredFieldEqualsValue(this.Syntax, field, locals, value, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal sealed partial class LoweredPropertyEqualsValue : LoweredEqualsValue
    {
        public LoweredPropertyEqualsValue(SyntaxNode syntax, PropertySymbol property, ImmutableArray<LocalSymbol> locals, LoweredExpression value, bool hasErrors = false)
            : base(LoweredKind.PropertyEqualsValue, syntax, locals, value, hasErrors || value.HasErrors())
        {

            RoslynDebug.Assert(property is object, "Field 'property' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(!locals.IsDefault, "Field 'locals' cannot be null (use Null=\"allow\" in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(value is object, "Field 'value' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

            this.Property = property;
        }


        public PropertySymbol Property { get; }
        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitPropertyEqualsValue(this);

        public LoweredPropertyEqualsValue Update(PropertySymbol property, ImmutableArray<LocalSymbol> locals, LoweredExpression value)
        {
            if (!Symbols.SymbolEqualityComparer.ConsiderEverything.Equals(property, this.Property) || locals != this.Locals || value != this.Value)
            {
                var result = new LoweredPropertyEqualsValue(this.Syntax, property, locals, value, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal sealed partial class LoweredParameterEqualsValue : LoweredEqualsValue
    {
        public LoweredParameterEqualsValue(SyntaxNode syntax, ParameterSymbol parameter, ImmutableArray<LocalSymbol> locals, LoweredExpression value, bool hasErrors = false)
            : base(LoweredKind.ParameterEqualsValue, syntax, locals, value, hasErrors || value.HasErrors())
        {

            RoslynDebug.Assert(parameter is object, "Field 'parameter' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(!locals.IsDefault, "Field 'locals' cannot be null (use Null=\"allow\" in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(value is object, "Field 'value' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

            this.Parameter = parameter;
        }


        public ParameterSymbol Parameter { get; }
        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitParameterEqualsValue(this);

        public LoweredParameterEqualsValue Update(ParameterSymbol parameter, ImmutableArray<LocalSymbol> locals, LoweredExpression value)
        {
            if (!Symbols.SymbolEqualityComparer.ConsiderEverything.Equals(parameter, this.Parameter) || locals != this.Locals || value != this.Value)
            {
                var result = new LoweredParameterEqualsValue(this.Syntax, parameter, locals, value, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal sealed partial class LoweredGlobalStatementInitializer : LoweredInitializer
    {
        public LoweredGlobalStatementInitializer(SyntaxNode syntax, LoweredStatement statement, bool hasErrors = false)
            : base(LoweredKind.GlobalStatementInitializer, syntax, hasErrors || statement.HasErrors())
        {

            RoslynDebug.Assert(statement is object, "Field 'statement' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

            this.Statement = statement;
        }


        public LoweredStatement Statement { get; }
        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitGlobalStatementInitializer(this);

        public LoweredGlobalStatementInitializer Update(LoweredStatement statement)
        {
            if (statement != this.Statement)
            {
                var result = new LoweredGlobalStatementInitializer(this.Syntax, statement, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal abstract partial class LoweredExpression : LoweredNode
    {
        protected LoweredExpression(LoweredKind kind, SyntaxNode syntax, TypeSymbol? type, bool hasErrors)
            : base(kind, syntax, hasErrors)
        {
            this.Type = type;
        }

        protected LoweredExpression(LoweredKind kind, SyntaxNode syntax, TypeSymbol? type)
            : base(kind, syntax)
        {
            this.Type = type;
        }


        public TypeSymbol? Type { get; }
    }

    internal abstract partial class LoweredValuePlaceholderBase : LoweredExpression
    {
        protected LoweredValuePlaceholderBase(LoweredKind kind, SyntaxNode syntax, TypeSymbol? type, bool hasErrors)
            : base(kind, syntax, type, hasErrors)
        {
        }

        protected LoweredValuePlaceholderBase(LoweredKind kind, SyntaxNode syntax, TypeSymbol? type)
            : base(kind, syntax, type)
        {
        }

    }

    internal sealed partial class LoweredDeconstructValuePlaceholder : LoweredValuePlaceholderBase
    {
        public LoweredDeconstructValuePlaceholder(SyntaxNode syntax, uint valEscape, TypeSymbol type, bool hasErrors)
            : base(LoweredKind.DeconstructValuePlaceholder, syntax, type, hasErrors)
        {

            RoslynDebug.Assert(type is object, "Field 'type' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

            this.ValEscape = valEscape;
        }

        public LoweredDeconstructValuePlaceholder(SyntaxNode syntax, uint valEscape, TypeSymbol type)
            : base(LoweredKind.DeconstructValuePlaceholder, syntax, type)
        {

            RoslynDebug.Assert(type is object, "Field 'type' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

            this.ValEscape = valEscape;
        }


        public new TypeSymbol Type => base.Type!;

        public uint ValEscape { get; }
        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitDeconstructValuePlaceholder(this);

        public LoweredDeconstructValuePlaceholder Update(uint valEscape, TypeSymbol type)
        {
            if (valEscape != this.ValEscape || !TypeSymbol.Equals(type, this.Type, TypeCompareKind.ConsiderEverything))
            {
                var result = new LoweredDeconstructValuePlaceholder(this.Syntax, valEscape, type, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal sealed partial class LoweredTupleOperandPlaceholder : LoweredValuePlaceholderBase
    {
        public LoweredTupleOperandPlaceholder(SyntaxNode syntax, TypeSymbol type, bool hasErrors)
            : base(LoweredKind.TupleOperandPlaceholder, syntax, type, hasErrors)
        {

            RoslynDebug.Assert(type is object, "Field 'type' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

        }

        public LoweredTupleOperandPlaceholder(SyntaxNode syntax, TypeSymbol type)
            : base(LoweredKind.TupleOperandPlaceholder, syntax, type)
        {

            RoslynDebug.Assert(type is object, "Field 'type' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

        }


        public new TypeSymbol Type => base.Type!;
        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitTupleOperandPlaceholder(this);

        public LoweredTupleOperandPlaceholder Update(TypeSymbol type)
        {
            if (!TypeSymbol.Equals(type, this.Type, TypeCompareKind.ConsiderEverything))
            {
                var result = new LoweredTupleOperandPlaceholder(this.Syntax, type, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal sealed partial class LoweredAwaitableValuePlaceholder : LoweredValuePlaceholderBase
    {
        public LoweredAwaitableValuePlaceholder(SyntaxNode syntax, uint valEscape, TypeSymbol? type, bool hasErrors)
            : base(LoweredKind.AwaitableValuePlaceholder, syntax, type, hasErrors)
        {
            this.ValEscape = valEscape;
        }

        public LoweredAwaitableValuePlaceholder(SyntaxNode syntax, uint valEscape, TypeSymbol? type)
            : base(LoweredKind.AwaitableValuePlaceholder, syntax, type)
        {
            this.ValEscape = valEscape;
        }


        public new TypeSymbol? Type => base.Type!;

        public uint ValEscape { get; }
        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitAwaitableValuePlaceholder(this);

        public LoweredAwaitableValuePlaceholder Update(uint valEscape, TypeSymbol? type)
        {
            if (valEscape != this.ValEscape || !TypeSymbol.Equals(type, this.Type, TypeCompareKind.ConsiderEverything))
            {
                var result = new LoweredAwaitableValuePlaceholder(this.Syntax, valEscape, type, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal sealed partial class LoweredDisposableValuePlaceholder : LoweredValuePlaceholderBase
    {
        public LoweredDisposableValuePlaceholder(SyntaxNode syntax, TypeSymbol type, bool hasErrors)
            : base(LoweredKind.DisposableValuePlaceholder, syntax, type, hasErrors)
        {

            RoslynDebug.Assert(type is object, "Field 'type' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

        }

        public LoweredDisposableValuePlaceholder(SyntaxNode syntax, TypeSymbol type)
            : base(LoweredKind.DisposableValuePlaceholder, syntax, type)
        {

            RoslynDebug.Assert(type is object, "Field 'type' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

        }


        public new TypeSymbol Type => base.Type!;
        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitDisposableValuePlaceholder(this);

        public LoweredDisposableValuePlaceholder Update(TypeSymbol type)
        {
            if (!TypeSymbol.Equals(type, this.Type, TypeCompareKind.ConsiderEverything))
            {
                var result = new LoweredDisposableValuePlaceholder(this.Syntax, type, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal sealed partial class LoweredObjectOrCollectionValuePlaceholder : LoweredValuePlaceholderBase
    {
        public LoweredObjectOrCollectionValuePlaceholder(SyntaxNode syntax, TypeSymbol type, bool hasErrors)
            : base(LoweredKind.ObjectOrCollectionValuePlaceholder, syntax, type, hasErrors)
        {

            RoslynDebug.Assert(type is object, "Field 'type' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

        }

        public LoweredObjectOrCollectionValuePlaceholder(SyntaxNode syntax, TypeSymbol type)
            : base(LoweredKind.ObjectOrCollectionValuePlaceholder, syntax, type)
        {

            RoslynDebug.Assert(type is object, "Field 'type' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

        }


        public new TypeSymbol Type => base.Type!;
        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitObjectOrCollectionValuePlaceholder(this);

        public LoweredObjectOrCollectionValuePlaceholder Update(TypeSymbol type)
        {
            if (!TypeSymbol.Equals(type, this.Type, TypeCompareKind.ConsiderEverything))
            {
                var result = new LoweredObjectOrCollectionValuePlaceholder(this.Syntax, type, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal sealed partial class LoweredDup : LoweredExpression
    {
        public LoweredDup(SyntaxNode syntax, RefKind refKind, TypeSymbol? type, bool hasErrors)
            : base(LoweredKind.Dup, syntax, type, hasErrors)
        {
            this.RefKind = refKind;
        }

        public LoweredDup(SyntaxNode syntax, RefKind refKind, TypeSymbol? type)
            : base(LoweredKind.Dup, syntax, type)
        {
            this.RefKind = refKind;
        }


        public RefKind RefKind { get; }
        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitDup(this);

        public LoweredDup Update(RefKind refKind, TypeSymbol? type)
        {
            if (refKind != this.RefKind || !TypeSymbol.Equals(type, this.Type, TypeCompareKind.ConsiderEverything))
            {
                var result = new LoweredDup(this.Syntax, refKind, type, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal sealed partial class LoweredPassByCopy : LoweredExpression
    {
        public LoweredPassByCopy(SyntaxNode syntax, LoweredExpression expression, TypeSymbol? type, bool hasErrors = false)
            : base(LoweredKind.PassByCopy, syntax, type, hasErrors || expression.HasErrors())
        {

            RoslynDebug.Assert(expression is object, "Field 'expression' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

            this.Expression = expression;
        }


        public LoweredExpression Expression { get; }
        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitPassByCopy(this);

        public LoweredPassByCopy Update(LoweredExpression expression, TypeSymbol? type)
        {
            if (expression != this.Expression || !TypeSymbol.Equals(type, this.Type, TypeCompareKind.ConsiderEverything))
            {
                var result = new LoweredPassByCopy(this.Syntax, expression, type, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal sealed partial class LoweredBadExpression : LoweredExpression
    {
        public LoweredBadExpression(SyntaxNode syntax, LookupResultKind resultKind, ImmutableArray<Symbol?> symbols, ImmutableArray<LoweredExpression> childLoweredNodes, TypeSymbol? type, bool hasErrors = false)
            : base(LoweredKind.BadExpression, syntax, type, hasErrors || childLoweredNodes.HasErrors())
        {

            RoslynDebug.Assert(!symbols.IsDefault, "Field 'symbols' cannot be null (use Null=\"allow\" in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(!childLoweredNodes.IsDefault, "Field 'childLoweredNodes' cannot be null (use Null=\"allow\" in LoweredNodes.xml to remove this check)");

            this._ResultKind = resultKind;
            this.Symbols = symbols;
            this.ChildLoweredNodes = childLoweredNodes;
        }


        private readonly LookupResultKind _ResultKind;
        public override LookupResultKind ResultKind { get { return _ResultKind;} }

        public ImmutableArray<Symbol?> Symbols { get; }

        public ImmutableArray<LoweredExpression> ChildLoweredNodes { get; }
        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitBadExpression(this);

        public LoweredBadExpression Update(LookupResultKind resultKind, ImmutableArray<Symbol?> symbols, ImmutableArray<LoweredExpression> childLoweredNodes, TypeSymbol? type)
        {
            if (resultKind != this.ResultKind || symbols != this.Symbols || childLoweredNodes != this.ChildLoweredNodes || !TypeSymbol.Equals(type, this.Type, TypeCompareKind.ConsiderEverything))
            {
                var result = new LoweredBadExpression(this.Syntax, resultKind, symbols, childLoweredNodes, type, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal sealed partial class LoweredBadStatement : LoweredStatement
    {
        public LoweredBadStatement(SyntaxNode syntax, ImmutableArray<LoweredNode> childLoweredNodes, bool hasErrors = false)
            : base(LoweredKind.BadStatement, syntax, hasErrors || childLoweredNodes.HasErrors())
        {

            RoslynDebug.Assert(!childLoweredNodes.IsDefault, "Field 'childLoweredNodes' cannot be null (use Null=\"allow\" in LoweredNodes.xml to remove this check)");

            this.ChildLoweredNodes = childLoweredNodes;
        }


        public ImmutableArray<LoweredNode> ChildLoweredNodes { get; }
        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitBadStatement(this);

        public LoweredBadStatement Update(ImmutableArray<LoweredNode> childLoweredNodes)
        {
            if (childLoweredNodes != this.ChildLoweredNodes)
            {
                var result = new LoweredBadStatement(this.Syntax, childLoweredNodes, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal sealed partial class LoweredExtractedFinallyBlock : LoweredStatement
    {
        public LoweredExtractedFinallyBlock(SyntaxNode syntax, LoweredBlock finallyBlock, bool hasErrors = false)
            : base(LoweredKind.ExtractedFinallyBlock, syntax, hasErrors || finallyBlock.HasErrors())
        {

            RoslynDebug.Assert(finallyBlock is object, "Field 'finallyBlock' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

            this.FinallyBlock = finallyBlock;
        }


        public LoweredBlock FinallyBlock { get; }
        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitExtractedFinallyBlock(this);

        public LoweredExtractedFinallyBlock Update(LoweredBlock finallyBlock)
        {
            if (finallyBlock != this.FinallyBlock)
            {
                var result = new LoweredExtractedFinallyBlock(this.Syntax, finallyBlock, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal sealed partial class LoweredTypeExpression : LoweredExpression
    {
        public LoweredTypeExpression(SyntaxNode syntax, AliasSymbol? aliasOpt, LoweredTypeExpression? boundContainingTypeOpt, ImmutableArray<LoweredExpression> boundDimensionsOpt, TypeWithAnnotations typeWithAnnotations, TypeSymbol? type, bool hasErrors = false)
            : base(LoweredKind.TypeExpression, syntax, type, hasErrors || boundContainingTypeOpt.HasErrors() || boundDimensionsOpt.HasErrors())
        {
            this.AliasOpt = aliasOpt;
            this.LoweredContainingTypeOpt = boundContainingTypeOpt;
            this.LoweredDimensionsOpt = boundDimensionsOpt;
            this.TypeWithAnnotations = typeWithAnnotations;
        }


        public AliasSymbol? AliasOpt { get; }

        public LoweredTypeExpression? LoweredContainingTypeOpt { get; }

        public ImmutableArray<LoweredExpression> LoweredDimensionsOpt { get; }

        public TypeWithAnnotations TypeWithAnnotations { get; }
        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitTypeExpression(this);

        public LoweredTypeExpression Update(AliasSymbol? aliasOpt, LoweredTypeExpression? boundContainingTypeOpt, ImmutableArray<LoweredExpression> boundDimensionsOpt, TypeWithAnnotations typeWithAnnotations, TypeSymbol? type)
        {
            if (!Symbols.SymbolEqualityComparer.ConsiderEverything.Equals(aliasOpt, this.AliasOpt) || boundContainingTypeOpt != this.LoweredContainingTypeOpt || boundDimensionsOpt != this.LoweredDimensionsOpt || typeWithAnnotations != this.TypeWithAnnotations || !TypeSymbol.Equals(type, this.Type, TypeCompareKind.ConsiderEverything))
            {
                var result = new LoweredTypeExpression(this.Syntax, aliasOpt, boundContainingTypeOpt, boundDimensionsOpt, typeWithAnnotations, type, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal sealed partial class LoweredTypeOrValueExpression : LoweredExpression
    {
        public LoweredTypeOrValueExpression(SyntaxNode syntax, LoweredTypeOrValueData data, TypeSymbol type, bool hasErrors)
            : base(LoweredKind.TypeOrValueExpression, syntax, type, hasErrors)
        {

            RoslynDebug.Assert(type is object, "Field 'type' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

            this.Data = data;
        }

        public LoweredTypeOrValueExpression(SyntaxNode syntax, LoweredTypeOrValueData data, TypeSymbol type)
            : base(LoweredKind.TypeOrValueExpression, syntax, type)
        {

            RoslynDebug.Assert(type is object, "Field 'type' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

            this.Data = data;
        }


        public new TypeSymbol Type => base.Type!;

        public LoweredTypeOrValueData Data { get; }
        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitTypeOrValueExpression(this);

        public LoweredTypeOrValueExpression Update(LoweredTypeOrValueData data, TypeSymbol type)
        {
            if (data != this.Data || !TypeSymbol.Equals(type, this.Type, TypeCompareKind.ConsiderEverything))
            {
                var result = new LoweredTypeOrValueExpression(this.Syntax, data, type, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal sealed partial class LoweredNamespaceExpression : LoweredExpression
    {
        public LoweredNamespaceExpression(SyntaxNode syntax, NamespaceSymbol namespaceSymbol, AliasSymbol? aliasOpt, bool hasErrors)
            : base(LoweredKind.NamespaceExpression, syntax, null, hasErrors)
        {

            RoslynDebug.Assert(namespaceSymbol is object, "Field 'namespaceSymbol' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

            this.NamespaceSymbol = namespaceSymbol;
            this.AliasOpt = aliasOpt;
        }

        public LoweredNamespaceExpression(SyntaxNode syntax, NamespaceSymbol namespaceSymbol, AliasSymbol? aliasOpt)
            : base(LoweredKind.NamespaceExpression, syntax, null)
        {

            RoslynDebug.Assert(namespaceSymbol is object, "Field 'namespaceSymbol' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

            this.NamespaceSymbol = namespaceSymbol;
            this.AliasOpt = aliasOpt;
        }


        public new TypeSymbol Type => base.Type!;

        public NamespaceSymbol NamespaceSymbol { get; }

        public AliasSymbol? AliasOpt { get; }
        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitNamespaceExpression(this);

        public LoweredNamespaceExpression Update(NamespaceSymbol namespaceSymbol, AliasSymbol? aliasOpt)
        {
            if (!Symbols.SymbolEqualityComparer.ConsiderEverything.Equals(namespaceSymbol, this.NamespaceSymbol) || !Symbols.SymbolEqualityComparer.ConsiderEverything.Equals(aliasOpt, this.AliasOpt))
            {
                var result = new LoweredNamespaceExpression(this.Syntax, namespaceSymbol, aliasOpt, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal sealed partial class LoweredUnaryOperator : LoweredExpression
    {
        public LoweredUnaryOperator(SyntaxNode syntax, UnaryOperatorKind operatorKind, LoweredExpression operand, ConstantValue? constantValueOpt, MethodSymbol? methodOpt, LookupResultKind resultKind, ImmutableArray<MethodSymbol> originalUserDefinedOperatorsOpt, TypeSymbol type, bool hasErrors = false)
            : base(LoweredKind.UnaryOperator, syntax, type, hasErrors || operand.HasErrors())
        {

            RoslynDebug.Assert(operand is object, "Field 'operand' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(type is object, "Field 'type' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

            this.OperatorKind = operatorKind;
            this.Operand = operand;
            this.ConstantValueOpt = constantValueOpt;
            this.MethodOpt = methodOpt;
            this._ResultKind = resultKind;
            this.OriginalUserDefinedOperatorsOpt = originalUserDefinedOperatorsOpt;
        }


        public new TypeSymbol Type => base.Type!;

        public UnaryOperatorKind OperatorKind { get; }

        public LoweredExpression Operand { get; }

        public ConstantValue? ConstantValueOpt { get; }

        public MethodSymbol? MethodOpt { get; }

        private readonly LookupResultKind _ResultKind;
        public override LookupResultKind ResultKind { get { return _ResultKind;} }

        public ImmutableArray<MethodSymbol> OriginalUserDefinedOperatorsOpt { get; }
        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitUnaryOperator(this);

        public LoweredUnaryOperator Update(UnaryOperatorKind operatorKind, LoweredExpression operand, ConstantValue? constantValueOpt, MethodSymbol? methodOpt, LookupResultKind resultKind, ImmutableArray<MethodSymbol> originalUserDefinedOperatorsOpt, TypeSymbol type)
        {
            if (operatorKind != this.OperatorKind || operand != this.Operand || constantValueOpt != this.ConstantValueOpt || !Symbols.SymbolEqualityComparer.ConsiderEverything.Equals(methodOpt, this.MethodOpt) || resultKind != this.ResultKind || originalUserDefinedOperatorsOpt != this.OriginalUserDefinedOperatorsOpt || !TypeSymbol.Equals(type, this.Type, TypeCompareKind.ConsiderEverything))
            {
                var result = new LoweredUnaryOperator(this.Syntax, operatorKind, operand, constantValueOpt, methodOpt, resultKind, originalUserDefinedOperatorsOpt, type, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal sealed partial class LoweredIncrementOperator : LoweredExpression
    {
        public LoweredIncrementOperator(SyntaxNode syntax, UnaryOperatorKind operatorKind, LoweredExpression operand, MethodSymbol? methodOpt, Conversion operandConversion, Conversion resultConversion, LookupResultKind resultKind, ImmutableArray<MethodSymbol> originalUserDefinedOperatorsOpt, TypeSymbol type, bool hasErrors = false)
            : base(LoweredKind.IncrementOperator, syntax, type, hasErrors || operand.HasErrors())
        {

            RoslynDebug.Assert(operand is object, "Field 'operand' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(type is object, "Field 'type' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

            this.OperatorKind = operatorKind;
            this.Operand = operand;
            this.MethodOpt = methodOpt;
            this.OperandConversion = operandConversion;
            this.ResultConversion = resultConversion;
            this._ResultKind = resultKind;
            this.OriginalUserDefinedOperatorsOpt = originalUserDefinedOperatorsOpt;
        }


        public new TypeSymbol Type => base.Type!;

        public UnaryOperatorKind OperatorKind { get; }

        public LoweredExpression Operand { get; }

        public MethodSymbol? MethodOpt { get; }

        public Conversion OperandConversion { get; }

        public Conversion ResultConversion { get; }

        private readonly LookupResultKind _ResultKind;
        public override LookupResultKind ResultKind { get { return _ResultKind;} }

        public ImmutableArray<MethodSymbol> OriginalUserDefinedOperatorsOpt { get; }
        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitIncrementOperator(this);

        public LoweredIncrementOperator Update(UnaryOperatorKind operatorKind, LoweredExpression operand, MethodSymbol? methodOpt, Conversion operandConversion, Conversion resultConversion, LookupResultKind resultKind, ImmutableArray<MethodSymbol> originalUserDefinedOperatorsOpt, TypeSymbol type)
        {
            if (operatorKind != this.OperatorKind || operand != this.Operand || !Symbols.SymbolEqualityComparer.ConsiderEverything.Equals(methodOpt, this.MethodOpt) || operandConversion != this.OperandConversion || resultConversion != this.ResultConversion || resultKind != this.ResultKind || originalUserDefinedOperatorsOpt != this.OriginalUserDefinedOperatorsOpt || !TypeSymbol.Equals(type, this.Type, TypeCompareKind.ConsiderEverything))
            {
                var result = new LoweredIncrementOperator(this.Syntax, operatorKind, operand, methodOpt, operandConversion, resultConversion, resultKind, originalUserDefinedOperatorsOpt, type, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal sealed partial class LoweredAddressOfOperator : LoweredExpression
    {
        public LoweredAddressOfOperator(SyntaxNode syntax, LoweredExpression operand, bool isManaged, TypeSymbol type, bool hasErrors = false)
            : base(LoweredKind.AddressOfOperator, syntax, type, hasErrors || operand.HasErrors())
        {

            RoslynDebug.Assert(operand is object, "Field 'operand' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(type is object, "Field 'type' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

            this.Operand = operand;
            this.IsManaged = isManaged;
        }


        public new TypeSymbol Type => base.Type!;

        public LoweredExpression Operand { get; }

        public bool IsManaged { get; }
        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitAddressOfOperator(this);

        public LoweredAddressOfOperator Update(LoweredExpression operand, bool isManaged, TypeSymbol type)
        {
            if (operand != this.Operand || isManaged != this.IsManaged || !TypeSymbol.Equals(type, this.Type, TypeCompareKind.ConsiderEverything))
            {
                var result = new LoweredAddressOfOperator(this.Syntax, operand, isManaged, type, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal sealed partial class LoweredPointerIndirectionOperator : LoweredExpression
    {
        public LoweredPointerIndirectionOperator(SyntaxNode syntax, LoweredExpression operand, TypeSymbol type, bool hasErrors = false)
            : base(LoweredKind.PointerIndirectionOperator, syntax, type, hasErrors || operand.HasErrors())
        {

            RoslynDebug.Assert(operand is object, "Field 'operand' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(type is object, "Field 'type' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

            this.Operand = operand;
        }


        public new TypeSymbol Type => base.Type!;

        public LoweredExpression Operand { get; }
        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitPointerIndirectionOperator(this);

        public LoweredPointerIndirectionOperator Update(LoweredExpression operand, TypeSymbol type)
        {
            if (operand != this.Operand || !TypeSymbol.Equals(type, this.Type, TypeCompareKind.ConsiderEverything))
            {
                var result = new LoweredPointerIndirectionOperator(this.Syntax, operand, type, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal sealed partial class LoweredPointerElementAccess : LoweredExpression
    {
        public LoweredPointerElementAccess(SyntaxNode syntax, LoweredExpression expression, LoweredExpression index, bool @checked, TypeSymbol type, bool hasErrors = false)
            : base(LoweredKind.PointerElementAccess, syntax, type, hasErrors || expression.HasErrors() || index.HasErrors())
        {

            RoslynDebug.Assert(expression is object, "Field 'expression' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(index is object, "Field 'index' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(type is object, "Field 'type' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

            this.Expression = expression;
            this.Index = index;
            this.Checked = @checked;
        }


        public new TypeSymbol Type => base.Type!;

        public LoweredExpression Expression { get; }

        public LoweredExpression Index { get; }

        public bool Checked { get; }
        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitPointerElementAccess(this);

        public LoweredPointerElementAccess Update(LoweredExpression expression, LoweredExpression index, bool @checked, TypeSymbol type)
        {
            if (expression != this.Expression || index != this.Index || @checked != this.Checked || !TypeSymbol.Equals(type, this.Type, TypeCompareKind.ConsiderEverything))
            {
                var result = new LoweredPointerElementAccess(this.Syntax, expression, index, @checked, type, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal sealed partial class LoweredRefTypeOperator : LoweredExpression
    {
        public LoweredRefTypeOperator(SyntaxNode syntax, LoweredExpression operand, MethodSymbol? getTypeFromHandle, TypeSymbol type, bool hasErrors = false)
            : base(LoweredKind.RefTypeOperator, syntax, type, hasErrors || operand.HasErrors())
        {

            RoslynDebug.Assert(operand is object, "Field 'operand' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(type is object, "Field 'type' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

            this.Operand = operand;
            this.GetTypeFromHandle = getTypeFromHandle;
        }


        public new TypeSymbol Type => base.Type!;

        public LoweredExpression Operand { get; }

        public MethodSymbol? GetTypeFromHandle { get; }
        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitRefTypeOperator(this);

        public LoweredRefTypeOperator Update(LoweredExpression operand, MethodSymbol? getTypeFromHandle, TypeSymbol type)
        {
            if (operand != this.Operand || !Symbols.SymbolEqualityComparer.ConsiderEverything.Equals(getTypeFromHandle, this.GetTypeFromHandle) || !TypeSymbol.Equals(type, this.Type, TypeCompareKind.ConsiderEverything))
            {
                var result = new LoweredRefTypeOperator(this.Syntax, operand, getTypeFromHandle, type, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal sealed partial class LoweredMakeRefOperator : LoweredExpression
    {
        public LoweredMakeRefOperator(SyntaxNode syntax, LoweredExpression operand, TypeSymbol type, bool hasErrors = false)
            : base(LoweredKind.MakeRefOperator, syntax, type, hasErrors || operand.HasErrors())
        {

            RoslynDebug.Assert(operand is object, "Field 'operand' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(type is object, "Field 'type' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

            this.Operand = operand;
        }


        public new TypeSymbol Type => base.Type!;

        public LoweredExpression Operand { get; }
        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitMakeRefOperator(this);

        public LoweredMakeRefOperator Update(LoweredExpression operand, TypeSymbol type)
        {
            if (operand != this.Operand || !TypeSymbol.Equals(type, this.Type, TypeCompareKind.ConsiderEverything))
            {
                var result = new LoweredMakeRefOperator(this.Syntax, operand, type, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal sealed partial class LoweredRefValueOperator : LoweredExpression
    {
        public LoweredRefValueOperator(SyntaxNode syntax, NullableAnnotation nullableAnnotation, LoweredExpression operand, TypeSymbol type, bool hasErrors = false)
            : base(LoweredKind.RefValueOperator, syntax, type, hasErrors || operand.HasErrors())
        {

            RoslynDebug.Assert(operand is object, "Field 'operand' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(type is object, "Field 'type' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

            this.NullableAnnotation = nullableAnnotation;
            this.Operand = operand;
        }


        public new TypeSymbol Type => base.Type!;

        public NullableAnnotation NullableAnnotation { get; }

        public LoweredExpression Operand { get; }
        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitRefValueOperator(this);

        public LoweredRefValueOperator Update(NullableAnnotation nullableAnnotation, LoweredExpression operand, TypeSymbol type)
        {
            if (nullableAnnotation != this.NullableAnnotation || operand != this.Operand || !TypeSymbol.Equals(type, this.Type, TypeCompareKind.ConsiderEverything))
            {
                var result = new LoweredRefValueOperator(this.Syntax, nullableAnnotation, operand, type, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal sealed partial class LoweredFromEndIndexExpression : LoweredExpression
    {
        public LoweredFromEndIndexExpression(SyntaxNode syntax, LoweredExpression operand, MethodSymbol? methodOpt, TypeSymbol type, bool hasErrors = false)
            : base(LoweredKind.FromEndIndexExpression, syntax, type, hasErrors || operand.HasErrors())
        {

            RoslynDebug.Assert(operand is object, "Field 'operand' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(type is object, "Field 'type' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

            this.Operand = operand;
            this.MethodOpt = methodOpt;
        }


        public new TypeSymbol Type => base.Type!;

        public LoweredExpression Operand { get; }

        public MethodSymbol? MethodOpt { get; }
        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitFromEndIndexExpression(this);

        public LoweredFromEndIndexExpression Update(LoweredExpression operand, MethodSymbol? methodOpt, TypeSymbol type)
        {
            if (operand != this.Operand || !Symbols.SymbolEqualityComparer.ConsiderEverything.Equals(methodOpt, this.MethodOpt) || !TypeSymbol.Equals(type, this.Type, TypeCompareKind.ConsiderEverything))
            {
                var result = new LoweredFromEndIndexExpression(this.Syntax, operand, methodOpt, type, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal sealed partial class LoweredRangeExpression : LoweredExpression
    {
        public LoweredRangeExpression(SyntaxNode syntax, LoweredExpression? leftOperandOpt, LoweredExpression? rightOperandOpt, MethodSymbol? methodOpt, TypeSymbol type, bool hasErrors = false)
            : base(LoweredKind.RangeExpression, syntax, type, hasErrors || leftOperandOpt.HasErrors() || rightOperandOpt.HasErrors())
        {

            RoslynDebug.Assert(type is object, "Field 'type' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

            this.LeftOperandOpt = leftOperandOpt;
            this.RightOperandOpt = rightOperandOpt;
            this.MethodOpt = methodOpt;
        }


        public new TypeSymbol Type => base.Type!;

        public LoweredExpression? LeftOperandOpt { get; }

        public LoweredExpression? RightOperandOpt { get; }

        public MethodSymbol? MethodOpt { get; }
        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitRangeExpression(this);

        public LoweredRangeExpression Update(LoweredExpression? leftOperandOpt, LoweredExpression? rightOperandOpt, MethodSymbol? methodOpt, TypeSymbol type)
        {
            if (leftOperandOpt != this.LeftOperandOpt || rightOperandOpt != this.RightOperandOpt || !Symbols.SymbolEqualityComparer.ConsiderEverything.Equals(methodOpt, this.MethodOpt) || !TypeSymbol.Equals(type, this.Type, TypeCompareKind.ConsiderEverything))
            {
                var result = new LoweredRangeExpression(this.Syntax, leftOperandOpt, rightOperandOpt, methodOpt, type, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal abstract partial class LoweredBinaryOperatorBase : LoweredExpression
    {
        protected LoweredBinaryOperatorBase(LoweredKind kind, SyntaxNode syntax, LoweredExpression left, LoweredExpression right, TypeSymbol type, bool hasErrors = false)
            : base(kind, syntax, type, hasErrors)
        {

            RoslynDebug.Assert(left is object, "Field 'left' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(right is object, "Field 'right' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(type is object, "Field 'type' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

            this.Left = left;
            this.Right = right;
        }


        public new TypeSymbol Type => base.Type!;

        public LoweredExpression Left { get; }

        public LoweredExpression Right { get; }
    }

    internal sealed partial class LoweredBinaryOperator : LoweredBinaryOperatorBase
    {
        public LoweredBinaryOperator(SyntaxNode syntax, BinaryOperatorKind operatorKind, ConstantValue? constantValueOpt, MethodSymbol? methodOpt, LookupResultKind resultKind, ImmutableArray<MethodSymbol> originalUserDefinedOperatorsOpt, LoweredExpression left, LoweredExpression right, TypeSymbol type, bool hasErrors = false)
            : base(LoweredKind.BinaryOperator, syntax, left, right, type, hasErrors || left.HasErrors() || right.HasErrors())
        {

            RoslynDebug.Assert(left is object, "Field 'left' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(right is object, "Field 'right' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(type is object, "Field 'type' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

            this.OperatorKind = operatorKind;
            this.ConstantValueOpt = constantValueOpt;
            this.MethodOpt = methodOpt;
            this._ResultKind = resultKind;
            this.OriginalUserDefinedOperatorsOpt = originalUserDefinedOperatorsOpt;
        }


        public BinaryOperatorKind OperatorKind { get; }

        public ConstantValue? ConstantValueOpt { get; }

        public MethodSymbol? MethodOpt { get; }

        private readonly LookupResultKind _ResultKind;
        public override LookupResultKind ResultKind { get { return _ResultKind;} }

        public ImmutableArray<MethodSymbol> OriginalUserDefinedOperatorsOpt { get; }
        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitBinaryOperator(this);

        public LoweredBinaryOperator Update(BinaryOperatorKind operatorKind, ConstantValue? constantValueOpt, MethodSymbol? methodOpt, LookupResultKind resultKind, ImmutableArray<MethodSymbol> originalUserDefinedOperatorsOpt, LoweredExpression left, LoweredExpression right, TypeSymbol type)
        {
            if (operatorKind != this.OperatorKind || constantValueOpt != this.ConstantValueOpt || !Symbols.SymbolEqualityComparer.ConsiderEverything.Equals(methodOpt, this.MethodOpt) || resultKind != this.ResultKind || originalUserDefinedOperatorsOpt != this.OriginalUserDefinedOperatorsOpt || left != this.Left || right != this.Right || !TypeSymbol.Equals(type, this.Type, TypeCompareKind.ConsiderEverything))
            {
                var result = new LoweredBinaryOperator(this.Syntax, operatorKind, constantValueOpt, methodOpt, resultKind, originalUserDefinedOperatorsOpt, left, right, type, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal sealed partial class LoweredTupleBinaryOperator : LoweredExpression
    {
        public LoweredTupleBinaryOperator(SyntaxNode syntax, LoweredExpression left, LoweredExpression right, BinaryOperatorKind operatorKind, TupleBinaryOperatorInfo.Multiple operators, TypeSymbol type, bool hasErrors = false)
            : base(LoweredKind.TupleBinaryOperator, syntax, type, hasErrors || left.HasErrors() || right.HasErrors())
        {

            RoslynDebug.Assert(left is object, "Field 'left' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(right is object, "Field 'right' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(operators is object, "Field 'operators' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(type is object, "Field 'type' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

            this.Left = left;
            this.Right = right;
            this.OperatorKind = operatorKind;
            this.Operators = operators;
        }


        public new TypeSymbol Type => base.Type!;

        public LoweredExpression Left { get; }

        public LoweredExpression Right { get; }

        public BinaryOperatorKind OperatorKind { get; }

        public TupleBinaryOperatorInfo.Multiple Operators { get; }
        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitTupleBinaryOperator(this);

        public LoweredTupleBinaryOperator Update(LoweredExpression left, LoweredExpression right, BinaryOperatorKind operatorKind, TupleBinaryOperatorInfo.Multiple operators, TypeSymbol type)
        {
            if (left != this.Left || right != this.Right || operatorKind != this.OperatorKind || operators != this.Operators || !TypeSymbol.Equals(type, this.Type, TypeCompareKind.ConsiderEverything))
            {
                var result = new LoweredTupleBinaryOperator(this.Syntax, left, right, operatorKind, operators, type, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal sealed partial class LoweredUserDefinedConditionalLogicalOperator : LoweredBinaryOperatorBase
    {
        public LoweredUserDefinedConditionalLogicalOperator(SyntaxNode syntax, BinaryOperatorKind operatorKind, MethodSymbol logicalOperator, MethodSymbol trueOperator, MethodSymbol falseOperator, LookupResultKind resultKind, ImmutableArray<MethodSymbol> originalUserDefinedOperatorsOpt, LoweredExpression left, LoweredExpression right, TypeSymbol type, bool hasErrors = false)
            : base(LoweredKind.UserDefinedConditionalLogicalOperator, syntax, left, right, type, hasErrors || left.HasErrors() || right.HasErrors())
        {

            RoslynDebug.Assert(logicalOperator is object, "Field 'logicalOperator' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(trueOperator is object, "Field 'trueOperator' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(falseOperator is object, "Field 'falseOperator' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(left is object, "Field 'left' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(right is object, "Field 'right' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(type is object, "Field 'type' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

            this.OperatorKind = operatorKind;
            this.LogicalOperator = logicalOperator;
            this.TrueOperator = trueOperator;
            this.FalseOperator = falseOperator;
            this._ResultKind = resultKind;
            this.OriginalUserDefinedOperatorsOpt = originalUserDefinedOperatorsOpt;
        }


        public BinaryOperatorKind OperatorKind { get; }

        public MethodSymbol LogicalOperator { get; }

        public MethodSymbol TrueOperator { get; }

        public MethodSymbol FalseOperator { get; }

        private readonly LookupResultKind _ResultKind;
        public override LookupResultKind ResultKind { get { return _ResultKind;} }

        public ImmutableArray<MethodSymbol> OriginalUserDefinedOperatorsOpt { get; }
        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitUserDefinedConditionalLogicalOperator(this);

        public LoweredUserDefinedConditionalLogicalOperator Update(BinaryOperatorKind operatorKind, MethodSymbol logicalOperator, MethodSymbol trueOperator, MethodSymbol falseOperator, LookupResultKind resultKind, ImmutableArray<MethodSymbol> originalUserDefinedOperatorsOpt, LoweredExpression left, LoweredExpression right, TypeSymbol type)
        {
            if (operatorKind != this.OperatorKind || !Symbols.SymbolEqualityComparer.ConsiderEverything.Equals(logicalOperator, this.LogicalOperator) || !Symbols.SymbolEqualityComparer.ConsiderEverything.Equals(trueOperator, this.TrueOperator) || !Symbols.SymbolEqualityComparer.ConsiderEverything.Equals(falseOperator, this.FalseOperator) || resultKind != this.ResultKind || originalUserDefinedOperatorsOpt != this.OriginalUserDefinedOperatorsOpt || left != this.Left || right != this.Right || !TypeSymbol.Equals(type, this.Type, TypeCompareKind.ConsiderEverything))
            {
                var result = new LoweredUserDefinedConditionalLogicalOperator(this.Syntax, operatorKind, logicalOperator, trueOperator, falseOperator, resultKind, originalUserDefinedOperatorsOpt, left, right, type, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal sealed partial class LoweredCompoundAssignmentOperator : LoweredExpression
    {
        public LoweredCompoundAssignmentOperator(SyntaxNode syntax, BinaryOperatorSignature @operator, LoweredExpression left, LoweredExpression right, Conversion leftConversion, Conversion finalConversion, LookupResultKind resultKind, ImmutableArray<MethodSymbol> originalUserDefinedOperatorsOpt, TypeSymbol type, bool hasErrors = false)
            : base(LoweredKind.CompoundAssignmentOperator, syntax, type, hasErrors || left.HasErrors() || right.HasErrors())
        {

            RoslynDebug.Assert(left is object, "Field 'left' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(right is object, "Field 'right' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(type is object, "Field 'type' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

            this.Operator = @operator;
            this.Left = left;
            this.Right = right;
            this.LeftConversion = leftConversion;
            this.FinalConversion = finalConversion;
            this._ResultKind = resultKind;
            this.OriginalUserDefinedOperatorsOpt = originalUserDefinedOperatorsOpt;
        }


        public new TypeSymbol Type => base.Type!;

        public BinaryOperatorSignature Operator { get; }

        public LoweredExpression Left { get; }

        public LoweredExpression Right { get; }

        public Conversion LeftConversion { get; }

        public Conversion FinalConversion { get; }

        private readonly LookupResultKind _ResultKind;
        public override LookupResultKind ResultKind { get { return _ResultKind;} }

        public ImmutableArray<MethodSymbol> OriginalUserDefinedOperatorsOpt { get; }
        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitCompoundAssignmentOperator(this);

        public LoweredCompoundAssignmentOperator Update(BinaryOperatorSignature @operator, LoweredExpression left, LoweredExpression right, Conversion leftConversion, Conversion finalConversion, LookupResultKind resultKind, ImmutableArray<MethodSymbol> originalUserDefinedOperatorsOpt, TypeSymbol type)
        {
            if (@operator != this.Operator || left != this.Left || right != this.Right || leftConversion != this.LeftConversion || finalConversion != this.FinalConversion || resultKind != this.ResultKind || originalUserDefinedOperatorsOpt != this.OriginalUserDefinedOperatorsOpt || !TypeSymbol.Equals(type, this.Type, TypeCompareKind.ConsiderEverything))
            {
                var result = new LoweredCompoundAssignmentOperator(this.Syntax, @operator, left, right, leftConversion, finalConversion, resultKind, originalUserDefinedOperatorsOpt, type, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal sealed partial class LoweredAssignmentOperator : LoweredExpression
    {
        public LoweredAssignmentOperator(SyntaxNode syntax, LoweredExpression left, LoweredExpression right, bool isRef, TypeSymbol? type, bool hasErrors = false)
            : base(LoweredKind.AssignmentOperator, syntax, type, hasErrors || left.HasErrors() || right.HasErrors())
        {

            RoslynDebug.Assert(left is object, "Field 'left' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

            this.Left = left;
            this.Right = right;
            this.IsRef = isRef;
        }


        public LoweredExpression Left { get; }

        public LoweredExpression Right { get; }

        public bool IsRef { get; }
        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitAssignmentOperator(this);

        public LoweredAssignmentOperator Update(LoweredExpression left, LoweredExpression right, bool isRef, TypeSymbol? type)
        {
            if (left != this.Left || right != this.Right || isRef != this.IsRef || !TypeSymbol.Equals(type, this.Type, TypeCompareKind.ConsiderEverything))
            {
                var result = new LoweredAssignmentOperator(this.Syntax, left, right, isRef, type, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal sealed partial class LoweredDeconstructionAssignmentOperator : LoweredExpression
    {
        public LoweredDeconstructionAssignmentOperator(SyntaxNode syntax, LoweredTupleExpression left, LoweredConversion right, bool isUsed, TypeSymbol type, bool hasErrors = false)
            : base(LoweredKind.DeconstructionAssignmentOperator, syntax, type, hasErrors || left.HasErrors() || right.HasErrors())
        {

            RoslynDebug.Assert(left is object, "Field 'left' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(right is object, "Field 'right' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(type is object, "Field 'type' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

            this.Left = left;
            this.Right = right;
            this.IsUsed = isUsed;
        }


        public new TypeSymbol Type => base.Type!;

        public LoweredTupleExpression Left { get; }

        public LoweredConversion Right { get; }

        public bool IsUsed { get; }
        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitDeconstructionAssignmentOperator(this);

        public LoweredDeconstructionAssignmentOperator Update(LoweredTupleExpression left, LoweredConversion right, bool isUsed, TypeSymbol type)
        {
            if (left != this.Left || right != this.Right || isUsed != this.IsUsed || !TypeSymbol.Equals(type, this.Type, TypeCompareKind.ConsiderEverything))
            {
                var result = new LoweredDeconstructionAssignmentOperator(this.Syntax, left, right, isUsed, type, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal sealed partial class LoweredNullCoalescingOperator : LoweredExpression
    {
        public LoweredNullCoalescingOperator(SyntaxNode syntax, LoweredExpression leftOperand, LoweredExpression rightOperand, Conversion leftConversion, LoweredNullCoalescingOperatorResultKind operatorResultKind, TypeSymbol? type, bool hasErrors = false)
            : base(LoweredKind.NullCoalescingOperator, syntax, type, hasErrors || leftOperand.HasErrors() || rightOperand.HasErrors())
        {

            RoslynDebug.Assert(leftOperand is object, "Field 'leftOperand' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(rightOperand is object, "Field 'rightOperand' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

            this.LeftOperand = leftOperand;
            this.RightOperand = rightOperand;
            this.LeftConversion = leftConversion;
            this.OperatorResultKind = operatorResultKind;
        }


        public LoweredExpression LeftOperand { get; }

        public LoweredExpression RightOperand { get; }

        public Conversion LeftConversion { get; }

        public LoweredNullCoalescingOperatorResultKind OperatorResultKind { get; }
        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitNullCoalescingOperator(this);

        public LoweredNullCoalescingOperator Update(LoweredExpression leftOperand, LoweredExpression rightOperand, Conversion leftConversion, LoweredNullCoalescingOperatorResultKind operatorResultKind, TypeSymbol? type)
        {
            if (leftOperand != this.LeftOperand || rightOperand != this.RightOperand || leftConversion != this.LeftConversion || operatorResultKind != this.OperatorResultKind || !TypeSymbol.Equals(type, this.Type, TypeCompareKind.ConsiderEverything))
            {
                var result = new LoweredNullCoalescingOperator(this.Syntax, leftOperand, rightOperand, leftConversion, operatorResultKind, type, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal sealed partial class LoweredNullCoalescingAssignmentOperator : LoweredExpression
    {
        public LoweredNullCoalescingAssignmentOperator(SyntaxNode syntax, LoweredExpression leftOperand, LoweredExpression rightOperand, TypeSymbol? type, bool hasErrors = false)
            : base(LoweredKind.NullCoalescingAssignmentOperator, syntax, type, hasErrors || leftOperand.HasErrors() || rightOperand.HasErrors())
        {

            RoslynDebug.Assert(leftOperand is object, "Field 'leftOperand' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(rightOperand is object, "Field 'rightOperand' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

            this.LeftOperand = leftOperand;
            this.RightOperand = rightOperand;
        }


        public LoweredExpression LeftOperand { get; }

        public LoweredExpression RightOperand { get; }
        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitNullCoalescingAssignmentOperator(this);

        public LoweredNullCoalescingAssignmentOperator Update(LoweredExpression leftOperand, LoweredExpression rightOperand, TypeSymbol? type)
        {
            if (leftOperand != this.LeftOperand || rightOperand != this.RightOperand || !TypeSymbol.Equals(type, this.Type, TypeCompareKind.ConsiderEverything))
            {
                var result = new LoweredNullCoalescingAssignmentOperator(this.Syntax, leftOperand, rightOperand, type, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal sealed partial class LoweredConditionalOperator : LoweredExpression
    {
        public LoweredConditionalOperator(SyntaxNode syntax, bool isRef, LoweredExpression condition, LoweredExpression consequence, LoweredExpression alternative, ConstantValue? constantValueOpt, TypeSymbol type, bool hasErrors = false)
            : base(LoweredKind.ConditionalOperator, syntax, type, hasErrors || condition.HasErrors() || consequence.HasErrors() || alternative.HasErrors())
        {

            RoslynDebug.Assert(condition is object, "Field 'condition' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(consequence is object, "Field 'consequence' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(alternative is object, "Field 'alternative' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(type is object, "Field 'type' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

            this.IsRef = isRef;
            this.Condition = condition;
            this.Consequence = consequence;
            this.Alternative = alternative;
            this.ConstantValueOpt = constantValueOpt;
        }


        public new TypeSymbol Type => base.Type!;

        public bool IsRef { get; }

        public LoweredExpression Condition { get; }

        public LoweredExpression Consequence { get; }

        public LoweredExpression Alternative { get; }

        public ConstantValue? ConstantValueOpt { get; }
        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitConditionalOperator(this);

        public LoweredConditionalOperator Update(bool isRef, LoweredExpression condition, LoweredExpression consequence, LoweredExpression alternative, ConstantValue? constantValueOpt, TypeSymbol type)
        {
            if (isRef != this.IsRef || condition != this.Condition || consequence != this.Consequence || alternative != this.Alternative || constantValueOpt != this.ConstantValueOpt || !TypeSymbol.Equals(type, this.Type, TypeCompareKind.ConsiderEverything))
            {
                var result = new LoweredConditionalOperator(this.Syntax, isRef, condition, consequence, alternative, constantValueOpt, type, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal sealed partial class LoweredArrayAccess : LoweredExpression
    {
        public LoweredArrayAccess(SyntaxNode syntax, LoweredExpression expression, ImmutableArray<LoweredExpression> indices, TypeSymbol type, bool hasErrors = false)
            : base(LoweredKind.ArrayAccess, syntax, type, hasErrors || expression.HasErrors() || indices.HasErrors())
        {

            RoslynDebug.Assert(expression is object, "Field 'expression' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(!indices.IsDefault, "Field 'indices' cannot be null (use Null=\"allow\" in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(type is object, "Field 'type' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

            this.Expression = expression;
            this.Indices = indices;
        }


        public new TypeSymbol Type => base.Type!;

        public LoweredExpression Expression { get; }

        public ImmutableArray<LoweredExpression> Indices { get; }
        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitArrayAccess(this);

        public LoweredArrayAccess Update(LoweredExpression expression, ImmutableArray<LoweredExpression> indices, TypeSymbol type)
        {
            if (expression != this.Expression || indices != this.Indices || !TypeSymbol.Equals(type, this.Type, TypeCompareKind.ConsiderEverything))
            {
                var result = new LoweredArrayAccess(this.Syntax, expression, indices, type, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal sealed partial class LoweredArrayLength : LoweredExpression
    {
        public LoweredArrayLength(SyntaxNode syntax, LoweredExpression expression, TypeSymbol type, bool hasErrors = false)
            : base(LoweredKind.ArrayLength, syntax, type, hasErrors || expression.HasErrors())
        {

            RoslynDebug.Assert(expression is object, "Field 'expression' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(type is object, "Field 'type' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

            this.Expression = expression;
        }


        public new TypeSymbol Type => base.Type!;

        public LoweredExpression Expression { get; }
        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitArrayLength(this);

        public LoweredArrayLength Update(LoweredExpression expression, TypeSymbol type)
        {
            if (expression != this.Expression || !TypeSymbol.Equals(type, this.Type, TypeCompareKind.ConsiderEverything))
            {
                var result = new LoweredArrayLength(this.Syntax, expression, type, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal sealed partial class LoweredAwaitableInfo : LoweredNode
    {
        public LoweredAwaitableInfo(SyntaxNode syntax, LoweredAwaitableValuePlaceholder? awaitableInstancePlaceholder, bool isDynamic, LoweredExpression? getAwaiter, PropertySymbol? isCompleted, MethodSymbol? getResult, bool hasErrors = false)
            : base(LoweredKind.AwaitableInfo, syntax, hasErrors || awaitableInstancePlaceholder.HasErrors() || getAwaiter.HasErrors())
        {
            this.AwaitableInstancePlaceholder = awaitableInstancePlaceholder;
            this.IsDynamic = isDynamic;
            this.GetAwaiter = getAwaiter;
            this.IsCompleted = isCompleted;
            this.GetResult = getResult;
        }


        public LoweredAwaitableValuePlaceholder? AwaitableInstancePlaceholder { get; }

        public bool IsDynamic { get; }

        public LoweredExpression? GetAwaiter { get; }

        public PropertySymbol? IsCompleted { get; }

        public MethodSymbol? GetResult { get; }
        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitAwaitableInfo(this);

        public LoweredAwaitableInfo Update(LoweredAwaitableValuePlaceholder? awaitableInstancePlaceholder, bool isDynamic, LoweredExpression? getAwaiter, PropertySymbol? isCompleted, MethodSymbol? getResult)
        {
            if (awaitableInstancePlaceholder != this.AwaitableInstancePlaceholder || isDynamic != this.IsDynamic || getAwaiter != this.GetAwaiter || !Symbols.SymbolEqualityComparer.ConsiderEverything.Equals(isCompleted, this.IsCompleted) || !Symbols.SymbolEqualityComparer.ConsiderEverything.Equals(getResult, this.GetResult))
            {
                var result = new LoweredAwaitableInfo(this.Syntax, awaitableInstancePlaceholder, isDynamic, getAwaiter, isCompleted, getResult, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal sealed partial class LoweredAwaitExpression : LoweredExpression
    {
        public LoweredAwaitExpression(SyntaxNode syntax, LoweredExpression expression, LoweredAwaitableInfo awaitableInfo, TypeSymbol type, bool hasErrors = false)
            : base(LoweredKind.AwaitExpression, syntax, type, hasErrors || expression.HasErrors() || awaitableInfo.HasErrors())
        {

            RoslynDebug.Assert(expression is object, "Field 'expression' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(awaitableInfo is object, "Field 'awaitableInfo' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(type is object, "Field 'type' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

            this.Expression = expression;
            this.AwaitableInfo = awaitableInfo;
        }


        public new TypeSymbol Type => base.Type!;

        public LoweredExpression Expression { get; }

        public LoweredAwaitableInfo AwaitableInfo { get; }
        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitAwaitExpression(this);

        public LoweredAwaitExpression Update(LoweredExpression expression, LoweredAwaitableInfo awaitableInfo, TypeSymbol type)
        {
            if (expression != this.Expression || awaitableInfo != this.AwaitableInfo || !TypeSymbol.Equals(type, this.Type, TypeCompareKind.ConsiderEverything))
            {
                var result = new LoweredAwaitExpression(this.Syntax, expression, awaitableInfo, type, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal abstract partial class LoweredTypeOf : LoweredExpression
    {
        protected LoweredTypeOf(LoweredKind kind, SyntaxNode syntax, MethodSymbol? getTypeFromHandle, TypeSymbol type, bool hasErrors)
            : base(kind, syntax, type, hasErrors)
        {

            RoslynDebug.Assert(type is object, "Field 'type' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

            this.GetTypeFromHandle = getTypeFromHandle;
        }

        protected LoweredTypeOf(LoweredKind kind, SyntaxNode syntax, MethodSymbol? getTypeFromHandle, TypeSymbol type)
            : base(kind, syntax, type)
        {

            RoslynDebug.Assert(type is object, "Field 'type' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

            this.GetTypeFromHandle = getTypeFromHandle;
        }


        public new TypeSymbol Type => base.Type!;

        public MethodSymbol? GetTypeFromHandle { get; }
    }

    internal sealed partial class LoweredTypeOfOperator : LoweredTypeOf
    {
        public LoweredTypeOfOperator(SyntaxNode syntax, LoweredTypeExpression sourceType, MethodSymbol? getTypeFromHandle, TypeSymbol type, bool hasErrors = false)
            : base(LoweredKind.TypeOfOperator, syntax, getTypeFromHandle, type, hasErrors || sourceType.HasErrors())
        {

            RoslynDebug.Assert(sourceType is object, "Field 'sourceType' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(type is object, "Field 'type' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

            this.SourceType = sourceType;
        }


        public LoweredTypeExpression SourceType { get; }
        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitTypeOfOperator(this);

        public LoweredTypeOfOperator Update(LoweredTypeExpression sourceType, MethodSymbol? getTypeFromHandle, TypeSymbol type)
        {
            if (sourceType != this.SourceType || !Symbols.SymbolEqualityComparer.ConsiderEverything.Equals(getTypeFromHandle, this.GetTypeFromHandle) || !TypeSymbol.Equals(type, this.Type, TypeCompareKind.ConsiderEverything))
            {
                var result = new LoweredTypeOfOperator(this.Syntax, sourceType, getTypeFromHandle, type, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal sealed partial class LoweredMethodDefIndex : LoweredExpression
    {
        public LoweredMethodDefIndex(SyntaxNode syntax, MethodSymbol method, TypeSymbol type, bool hasErrors)
            : base(LoweredKind.MethodDefIndex, syntax, type, hasErrors)
        {

            RoslynDebug.Assert(method is object, "Field 'method' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(type is object, "Field 'type' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

            this.Method = method;
        }

        public LoweredMethodDefIndex(SyntaxNode syntax, MethodSymbol method, TypeSymbol type)
            : base(LoweredKind.MethodDefIndex, syntax, type)
        {

            RoslynDebug.Assert(method is object, "Field 'method' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(type is object, "Field 'type' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

            this.Method = method;
        }


        public new TypeSymbol Type => base.Type!;

        public MethodSymbol Method { get; }
        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitMethodDefIndex(this);

        public LoweredMethodDefIndex Update(MethodSymbol method, TypeSymbol type)
        {
            if (!Symbols.SymbolEqualityComparer.ConsiderEverything.Equals(method, this.Method) || !TypeSymbol.Equals(type, this.Type, TypeCompareKind.ConsiderEverything))
            {
                var result = new LoweredMethodDefIndex(this.Syntax, method, type, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal sealed partial class LoweredMaximumMethodDefIndex : LoweredExpression
    {
        public LoweredMaximumMethodDefIndex(SyntaxNode syntax, TypeSymbol type, bool hasErrors)
            : base(LoweredKind.MaximumMethodDefIndex, syntax, type, hasErrors)
        {

            RoslynDebug.Assert(type is object, "Field 'type' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

        }

        public LoweredMaximumMethodDefIndex(SyntaxNode syntax, TypeSymbol type)
            : base(LoweredKind.MaximumMethodDefIndex, syntax, type)
        {

            RoslynDebug.Assert(type is object, "Field 'type' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

        }


        public new TypeSymbol Type => base.Type!;
        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitMaximumMethodDefIndex(this);

        public LoweredMaximumMethodDefIndex Update(TypeSymbol type)
        {
            if (!TypeSymbol.Equals(type, this.Type, TypeCompareKind.ConsiderEverything))
            {
                var result = new LoweredMaximumMethodDefIndex(this.Syntax, type, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal sealed partial class LoweredInstrumentationPayloadRoot : LoweredExpression
    {
        public LoweredInstrumentationPayloadRoot(SyntaxNode syntax, int analysisKind, TypeSymbol type, bool hasErrors)
            : base(LoweredKind.InstrumentationPayloadRoot, syntax, type, hasErrors)
        {

            RoslynDebug.Assert(type is object, "Field 'type' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

            this.AnalysisKind = analysisKind;
        }

        public LoweredInstrumentationPayloadRoot(SyntaxNode syntax, int analysisKind, TypeSymbol type)
            : base(LoweredKind.InstrumentationPayloadRoot, syntax, type)
        {

            RoslynDebug.Assert(type is object, "Field 'type' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

            this.AnalysisKind = analysisKind;
        }


        public int AnalysisKind { get; }

        public new TypeSymbol Type => base.Type!;
        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitInstrumentationPayloadRoot(this);

        public LoweredInstrumentationPayloadRoot Update(int analysisKind, TypeSymbol type)
        {
            if (analysisKind != this.AnalysisKind || !TypeSymbol.Equals(type, this.Type, TypeCompareKind.ConsiderEverything))
            {
                var result = new LoweredInstrumentationPayloadRoot(this.Syntax, analysisKind, type, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal sealed partial class LoweredModuleVersionId : LoweredExpression
    {
        public LoweredModuleVersionId(SyntaxNode syntax, TypeSymbol type, bool hasErrors)
            : base(LoweredKind.ModuleVersionId, syntax, type, hasErrors)
        {

            RoslynDebug.Assert(type is object, "Field 'type' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

        }

        public LoweredModuleVersionId(SyntaxNode syntax, TypeSymbol type)
            : base(LoweredKind.ModuleVersionId, syntax, type)
        {

            RoslynDebug.Assert(type is object, "Field 'type' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

        }


        public new TypeSymbol Type => base.Type!;
        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitModuleVersionId(this);

        public LoweredModuleVersionId Update(TypeSymbol type)
        {
            if (!TypeSymbol.Equals(type, this.Type, TypeCompareKind.ConsiderEverything))
            {
                var result = new LoweredModuleVersionId(this.Syntax, type, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal sealed partial class LoweredModuleVersionIdString : LoweredExpression
    {
        public LoweredModuleVersionIdString(SyntaxNode syntax, TypeSymbol type, bool hasErrors)
            : base(LoweredKind.ModuleVersionIdString, syntax, type, hasErrors)
        {

            RoslynDebug.Assert(type is object, "Field 'type' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

        }

        public LoweredModuleVersionIdString(SyntaxNode syntax, TypeSymbol type)
            : base(LoweredKind.ModuleVersionIdString, syntax, type)
        {

            RoslynDebug.Assert(type is object, "Field 'type' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

        }


        public new TypeSymbol Type => base.Type!;
        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitModuleVersionIdString(this);

        public LoweredModuleVersionIdString Update(TypeSymbol type)
        {
            if (!TypeSymbol.Equals(type, this.Type, TypeCompareKind.ConsiderEverything))
            {
                var result = new LoweredModuleVersionIdString(this.Syntax, type, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal sealed partial class LoweredSourceDocumentIndex : LoweredExpression
    {
        public LoweredSourceDocumentIndex(SyntaxNode syntax, Cci.DebugSourceDocument document, TypeSymbol type, bool hasErrors)
            : base(LoweredKind.SourceDocumentIndex, syntax, type, hasErrors)
        {

            RoslynDebug.Assert(document is object, "Field 'document' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(type is object, "Field 'type' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

            this.Document = document;
        }

        public LoweredSourceDocumentIndex(SyntaxNode syntax, Cci.DebugSourceDocument document, TypeSymbol type)
            : base(LoweredKind.SourceDocumentIndex, syntax, type)
        {

            RoslynDebug.Assert(document is object, "Field 'document' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(type is object, "Field 'type' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

            this.Document = document;
        }


        public new TypeSymbol Type => base.Type!;

        public Cci.DebugSourceDocument Document { get; }
        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitSourceDocumentIndex(this);

        public LoweredSourceDocumentIndex Update(Cci.DebugSourceDocument document, TypeSymbol type)
        {
            if (document != this.Document || !TypeSymbol.Equals(type, this.Type, TypeCompareKind.ConsiderEverything))
            {
                var result = new LoweredSourceDocumentIndex(this.Syntax, document, type, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal sealed partial class LoweredMethodInfo : LoweredExpression
    {
        public LoweredMethodInfo(SyntaxNode syntax, MethodSymbol method, MethodSymbol? getMethodFromHandle, TypeSymbol type, bool hasErrors)
            : base(LoweredKind.MethodInfo, syntax, type, hasErrors)
        {

            RoslynDebug.Assert(method is object, "Field 'method' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(type is object, "Field 'type' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

            this.Method = method;
            this.GetMethodFromHandle = getMethodFromHandle;
        }

        public LoweredMethodInfo(SyntaxNode syntax, MethodSymbol method, MethodSymbol? getMethodFromHandle, TypeSymbol type)
            : base(LoweredKind.MethodInfo, syntax, type)
        {

            RoslynDebug.Assert(method is object, "Field 'method' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(type is object, "Field 'type' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

            this.Method = method;
            this.GetMethodFromHandle = getMethodFromHandle;
        }


        public new TypeSymbol Type => base.Type!;

        public MethodSymbol Method { get; }

        public MethodSymbol? GetMethodFromHandle { get; }
        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitMethodInfo(this);

        public LoweredMethodInfo Update(MethodSymbol method, MethodSymbol? getMethodFromHandle, TypeSymbol type)
        {
            if (!Symbols.SymbolEqualityComparer.ConsiderEverything.Equals(method, this.Method) || !Symbols.SymbolEqualityComparer.ConsiderEverything.Equals(getMethodFromHandle, this.GetMethodFromHandle) || !TypeSymbol.Equals(type, this.Type, TypeCompareKind.ConsiderEverything))
            {
                var result = new LoweredMethodInfo(this.Syntax, method, getMethodFromHandle, type, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal sealed partial class LoweredFieldInfo : LoweredExpression
    {
        public LoweredFieldInfo(SyntaxNode syntax, FieldSymbol field, MethodSymbol? getFieldFromHandle, TypeSymbol type, bool hasErrors)
            : base(LoweredKind.FieldInfo, syntax, type, hasErrors)
        {

            RoslynDebug.Assert(field is object, "Field 'field' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(type is object, "Field 'type' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

            this.Field = field;
            this.GetFieldFromHandle = getFieldFromHandle;
        }

        public LoweredFieldInfo(SyntaxNode syntax, FieldSymbol field, MethodSymbol? getFieldFromHandle, TypeSymbol type)
            : base(LoweredKind.FieldInfo, syntax, type)
        {

            RoslynDebug.Assert(field is object, "Field 'field' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(type is object, "Field 'type' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

            this.Field = field;
            this.GetFieldFromHandle = getFieldFromHandle;
        }


        public new TypeSymbol Type => base.Type!;

        public FieldSymbol Field { get; }

        public MethodSymbol? GetFieldFromHandle { get; }
        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitFieldInfo(this);

        public LoweredFieldInfo Update(FieldSymbol field, MethodSymbol? getFieldFromHandle, TypeSymbol type)
        {
            if (!Symbols.SymbolEqualityComparer.ConsiderEverything.Equals(field, this.Field) || !Symbols.SymbolEqualityComparer.ConsiderEverything.Equals(getFieldFromHandle, this.GetFieldFromHandle) || !TypeSymbol.Equals(type, this.Type, TypeCompareKind.ConsiderEverything))
            {
                var result = new LoweredFieldInfo(this.Syntax, field, getFieldFromHandle, type, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal sealed partial class LoweredDefaultLiteral : LoweredExpression
    {
        public LoweredDefaultLiteral(SyntaxNode syntax, bool hasErrors)
            : base(LoweredKind.DefaultLiteral, syntax, null, hasErrors)
        {
        }

        public LoweredDefaultLiteral(SyntaxNode syntax)
            : base(LoweredKind.DefaultLiteral, syntax, null)
        {
        }


        public new TypeSymbol? Type => base.Type!;
        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitDefaultLiteral(this);

        public LoweredDefaultLiteral Update()
        {
            return this;
        }
    }

    internal sealed partial class LoweredDefaultExpression : LoweredExpression
    {
        public LoweredDefaultExpression(SyntaxNode syntax, LoweredTypeExpression? targetType, ConstantValue? constantValueOpt, TypeSymbol type, bool hasErrors = false)
            : base(LoweredKind.DefaultExpression, syntax, type, hasErrors || targetType.HasErrors())
        {

            RoslynDebug.Assert(type is object, "Field 'type' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

            this.TargetType = targetType;
            this.ConstantValueOpt = constantValueOpt;
        }


        public new TypeSymbol Type => base.Type!;

        public LoweredTypeExpression? TargetType { get; }

        public ConstantValue? ConstantValueOpt { get; }
        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitDefaultExpression(this);

        public LoweredDefaultExpression Update(LoweredTypeExpression? targetType, ConstantValue? constantValueOpt, TypeSymbol type)
        {
            if (targetType != this.TargetType || constantValueOpt != this.ConstantValueOpt || !TypeSymbol.Equals(type, this.Type, TypeCompareKind.ConsiderEverything))
            {
                var result = new LoweredDefaultExpression(this.Syntax, targetType, constantValueOpt, type, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal sealed partial class LoweredIsOperator : LoweredExpression
    {
        public LoweredIsOperator(SyntaxNode syntax, LoweredExpression operand, LoweredTypeExpression targetType, Conversion conversion, TypeSymbol type, bool hasErrors = false)
            : base(LoweredKind.IsOperator, syntax, type, hasErrors || operand.HasErrors() || targetType.HasErrors())
        {

            RoslynDebug.Assert(operand is object, "Field 'operand' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(targetType is object, "Field 'targetType' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(type is object, "Field 'type' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

            this.Operand = operand;
            this.TargetType = targetType;
            this.Conversion = conversion;
        }


        public new TypeSymbol Type => base.Type!;

        public LoweredExpression Operand { get; }

        public LoweredTypeExpression TargetType { get; }

        public Conversion Conversion { get; }
        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitIsOperator(this);

        public LoweredIsOperator Update(LoweredExpression operand, LoweredTypeExpression targetType, Conversion conversion, TypeSymbol type)
        {
            if (operand != this.Operand || targetType != this.TargetType || conversion != this.Conversion || !TypeSymbol.Equals(type, this.Type, TypeCompareKind.ConsiderEverything))
            {
                var result = new LoweredIsOperator(this.Syntax, operand, targetType, conversion, type, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal sealed partial class LoweredAsOperator : LoweredExpression
    {
        public LoweredAsOperator(SyntaxNode syntax, LoweredExpression operand, LoweredTypeExpression targetType, Conversion conversion, TypeSymbol type, bool hasErrors = false)
            : base(LoweredKind.AsOperator, syntax, type, hasErrors || operand.HasErrors() || targetType.HasErrors())
        {

            RoslynDebug.Assert(operand is object, "Field 'operand' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(targetType is object, "Field 'targetType' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(type is object, "Field 'type' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

            this.Operand = operand;
            this.TargetType = targetType;
            this.Conversion = conversion;
        }


        public new TypeSymbol Type => base.Type!;

        public LoweredExpression Operand { get; }

        public LoweredTypeExpression TargetType { get; }

        public Conversion Conversion { get; }
        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitAsOperator(this);

        public LoweredAsOperator Update(LoweredExpression operand, LoweredTypeExpression targetType, Conversion conversion, TypeSymbol type)
        {
            if (operand != this.Operand || targetType != this.TargetType || conversion != this.Conversion || !TypeSymbol.Equals(type, this.Type, TypeCompareKind.ConsiderEverything))
            {
                var result = new LoweredAsOperator(this.Syntax, operand, targetType, conversion, type, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal sealed partial class LoweredSizeOfOperator : LoweredExpression
    {
        public LoweredSizeOfOperator(SyntaxNode syntax, LoweredTypeExpression sourceType, ConstantValue? constantValueOpt, TypeSymbol type, bool hasErrors = false)
            : base(LoweredKind.SizeOfOperator, syntax, type, hasErrors || sourceType.HasErrors())
        {

            RoslynDebug.Assert(sourceType is object, "Field 'sourceType' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(type is object, "Field 'type' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

            this.SourceType = sourceType;
            this.ConstantValueOpt = constantValueOpt;
        }


        public new TypeSymbol Type => base.Type!;

        public LoweredTypeExpression SourceType { get; }

        public ConstantValue? ConstantValueOpt { get; }
        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitSizeOfOperator(this);

        public LoweredSizeOfOperator Update(LoweredTypeExpression sourceType, ConstantValue? constantValueOpt, TypeSymbol type)
        {
            if (sourceType != this.SourceType || constantValueOpt != this.ConstantValueOpt || !TypeSymbol.Equals(type, this.Type, TypeCompareKind.ConsiderEverything))
            {
                var result = new LoweredSizeOfOperator(this.Syntax, sourceType, constantValueOpt, type, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal sealed partial class LoweredConversion : LoweredExpression
    {
        public LoweredConversion(SyntaxNode syntax, LoweredExpression operand, Conversion conversion, bool isBaseConversion, bool @checked, bool explicitCastInCode, ConstantValue? constantValueOpt, ConversionGroup? conversionGroupOpt, ImmutableArray<MethodSymbol> originalUserDefinedConversionsOpt, TypeSymbol type, bool hasErrors = false)
            : base(LoweredKind.Conversion, syntax, type, hasErrors || operand.HasErrors())
        {

            RoslynDebug.Assert(operand is object, "Field 'operand' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(type is object, "Field 'type' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

            this.Operand = operand;
            this.Conversion = conversion;
            this.IsBaseConversion = isBaseConversion;
            this.Checked = @checked;
            this.ExplicitCastInCode = explicitCastInCode;
            this.ConstantValueOpt = constantValueOpt;
            this.ConversionGroupOpt = conversionGroupOpt;
            this.OriginalUserDefinedConversionsOpt = originalUserDefinedConversionsOpt;
        }


        public new TypeSymbol Type => base.Type!;

        public LoweredExpression Operand { get; }

        public Conversion Conversion { get; }

        public bool IsBaseConversion { get; }

        public bool Checked { get; }

        public bool ExplicitCastInCode { get; }

        public ConstantValue? ConstantValueOpt { get; }

        public ConversionGroup? ConversionGroupOpt { get; }

        public ImmutableArray<MethodSymbol> OriginalUserDefinedConversionsOpt { get; }
        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitConversion(this);

        public LoweredConversion Update(LoweredExpression operand, Conversion conversion, bool isBaseConversion, bool @checked, bool explicitCastInCode, ConstantValue? constantValueOpt, ConversionGroup? conversionGroupOpt, ImmutableArray<MethodSymbol> originalUserDefinedConversionsOpt, TypeSymbol type)
        {
            if (operand != this.Operand || conversion != this.Conversion || isBaseConversion != this.IsBaseConversion || @checked != this.Checked || explicitCastInCode != this.ExplicitCastInCode || constantValueOpt != this.ConstantValueOpt || conversionGroupOpt != this.ConversionGroupOpt || originalUserDefinedConversionsOpt != this.OriginalUserDefinedConversionsOpt || !TypeSymbol.Equals(type, this.Type, TypeCompareKind.ConsiderEverything))
            {
                var result = new LoweredConversion(this.Syntax, operand, conversion, isBaseConversion, @checked, explicitCastInCode, constantValueOpt, conversionGroupOpt, originalUserDefinedConversionsOpt, type, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal sealed partial class LoweredReadOnlySpanFromArray : LoweredExpression
    {
        public LoweredReadOnlySpanFromArray(SyntaxNode syntax, LoweredExpression operand, MethodSymbol conversionMethod, TypeSymbol type, bool hasErrors = false)
            : base(LoweredKind.ReadOnlySpanFromArray, syntax, type, hasErrors || operand.HasErrors())
        {

            RoslynDebug.Assert(operand is object, "Field 'operand' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(conversionMethod is object, "Field 'conversionMethod' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(type is object, "Field 'type' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

            this.Operand = operand;
            this.ConversionMethod = conversionMethod;
        }


        public new TypeSymbol Type => base.Type!;

        public LoweredExpression Operand { get; }

        public MethodSymbol ConversionMethod { get; }
        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitReadOnlySpanFromArray(this);

        public LoweredReadOnlySpanFromArray Update(LoweredExpression operand, MethodSymbol conversionMethod, TypeSymbol type)
        {
            if (operand != this.Operand || !Symbols.SymbolEqualityComparer.ConsiderEverything.Equals(conversionMethod, this.ConversionMethod) || !TypeSymbol.Equals(type, this.Type, TypeCompareKind.ConsiderEverything))
            {
                var result = new LoweredReadOnlySpanFromArray(this.Syntax, operand, conversionMethod, type, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal sealed partial class LoweredArgList : LoweredExpression
    {
        public LoweredArgList(SyntaxNode syntax, TypeSymbol type, bool hasErrors)
            : base(LoweredKind.ArgList, syntax, type, hasErrors)
        {

            RoslynDebug.Assert(type is object, "Field 'type' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

        }

        public LoweredArgList(SyntaxNode syntax, TypeSymbol type)
            : base(LoweredKind.ArgList, syntax, type)
        {

            RoslynDebug.Assert(type is object, "Field 'type' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

        }


        public new TypeSymbol Type => base.Type!;
        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitArgList(this);

        public LoweredArgList Update(TypeSymbol type)
        {
            if (!TypeSymbol.Equals(type, this.Type, TypeCompareKind.ConsiderEverything))
            {
                var result = new LoweredArgList(this.Syntax, type, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal sealed partial class LoweredArgListOperator : LoweredExpression
    {
        public LoweredArgListOperator(SyntaxNode syntax, ImmutableArray<LoweredExpression> arguments, ImmutableArray<RefKind> argumentRefKindsOpt, TypeSymbol? type, bool hasErrors = false)
            : base(LoweredKind.ArgListOperator, syntax, type, hasErrors || arguments.HasErrors())
        {

            RoslynDebug.Assert(!arguments.IsDefault, "Field 'arguments' cannot be null (use Null=\"allow\" in LoweredNodes.xml to remove this check)");

            this.Arguments = arguments;
            this.ArgumentRefKindsOpt = argumentRefKindsOpt;
        }


        public new TypeSymbol? Type => base.Type!;

        public ImmutableArray<LoweredExpression> Arguments { get; }

        public ImmutableArray<RefKind> ArgumentRefKindsOpt { get; }
        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitArgListOperator(this);

        public LoweredArgListOperator Update(ImmutableArray<LoweredExpression> arguments, ImmutableArray<RefKind> argumentRefKindsOpt, TypeSymbol? type)
        {
            if (arguments != this.Arguments || argumentRefKindsOpt != this.ArgumentRefKindsOpt || !TypeSymbol.Equals(type, this.Type, TypeCompareKind.ConsiderEverything))
            {
                var result = new LoweredArgListOperator(this.Syntax, arguments, argumentRefKindsOpt, type, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal sealed partial class LoweredFixedLocalCollectionInitializer : LoweredExpression
    {
        public LoweredFixedLocalCollectionInitializer(SyntaxNode syntax, TypeSymbol elementPointerType, Conversion elementPointerTypeConversion, LoweredExpression expression, MethodSymbol? getPinnableOpt, TypeSymbol type, bool hasErrors = false)
            : base(LoweredKind.FixedLocalCollectionInitializer, syntax, type, hasErrors || expression.HasErrors())
        {

            RoslynDebug.Assert(elementPointerType is object, "Field 'elementPointerType' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(expression is object, "Field 'expression' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(type is object, "Field 'type' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

            this.ElementPointerType = elementPointerType;
            this.ElementPointerTypeConversion = elementPointerTypeConversion;
            this.Expression = expression;
            this.GetPinnableOpt = getPinnableOpt;
        }


        public new TypeSymbol Type => base.Type!;

        public TypeSymbol ElementPointerType { get; }

        public Conversion ElementPointerTypeConversion { get; }

        public LoweredExpression Expression { get; }

        public MethodSymbol? GetPinnableOpt { get; }
        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitFixedLocalCollectionInitializer(this);

        public LoweredFixedLocalCollectionInitializer Update(TypeSymbol elementPointerType, Conversion elementPointerTypeConversion, LoweredExpression expression, MethodSymbol? getPinnableOpt, TypeSymbol type)
        {
            if (!TypeSymbol.Equals(elementPointerType, this.ElementPointerType, TypeCompareKind.ConsiderEverything) || elementPointerTypeConversion != this.ElementPointerTypeConversion || expression != this.Expression || !Symbols.SymbolEqualityComparer.ConsiderEverything.Equals(getPinnableOpt, this.GetPinnableOpt) || !TypeSymbol.Equals(type, this.Type, TypeCompareKind.ConsiderEverything))
            {
                var result = new LoweredFixedLocalCollectionInitializer(this.Syntax, elementPointerType, elementPointerTypeConversion, expression, getPinnableOpt, type, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal abstract partial class LoweredStatement : LoweredNode
    {
        protected LoweredStatement(LoweredKind kind, SyntaxNode syntax, bool hasErrors)
            : base(kind, syntax, hasErrors)
        {
        }

        protected LoweredStatement(LoweredKind kind, SyntaxNode syntax)
            : base(kind, syntax)
        {
        }

    }

    internal sealed partial class LoweredSequencePoint : LoweredStatement
    {
        public LoweredSequencePoint(SyntaxNode syntax, LoweredStatement? statementOpt, bool hasErrors = false)
            : base(LoweredKind.SequencePoint, syntax, hasErrors || statementOpt.HasErrors())
        {
            this.StatementOpt = statementOpt;
        }


        public LoweredStatement? StatementOpt { get; }
        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitSequencePoint(this);

        public LoweredSequencePoint Update(LoweredStatement? statementOpt)
        {
            if (statementOpt != this.StatementOpt)
            {
                var result = new LoweredSequencePoint(this.Syntax, statementOpt, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal sealed partial class LoweredSequencePointWithSpan : LoweredStatement
    {
        public LoweredSequencePointWithSpan(SyntaxNode syntax, LoweredStatement? statementOpt, TextSpan span, bool hasErrors = false)
            : base(LoweredKind.SequencePointWithSpan, syntax, hasErrors || statementOpt.HasErrors())
        {
            this.StatementOpt = statementOpt;
            this.Span = span;
        }


        public LoweredStatement? StatementOpt { get; }

        public TextSpan Span { get; }
        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitSequencePointWithSpan(this);

        public LoweredSequencePointWithSpan Update(LoweredStatement? statementOpt, TextSpan span)
        {
            if (statementOpt != this.StatementOpt || span != this.Span)
            {
                var result = new LoweredSequencePointWithSpan(this.Syntax, statementOpt, span, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal sealed partial class LoweredBlock : LoweredStatementList
    {
        public LoweredBlock(SyntaxNode syntax, ImmutableArray<LocalSymbol> locals, ImmutableArray<LocalFunctionSymbol> localFunctions, ImmutableArray<LoweredStatement> statements, bool hasErrors = false)
            : base(LoweredKind.Block, syntax, statements, hasErrors || statements.HasErrors())
        {

            RoslynDebug.Assert(!locals.IsDefault, "Field 'locals' cannot be null (use Null=\"allow\" in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(!localFunctions.IsDefault, "Field 'localFunctions' cannot be null (use Null=\"allow\" in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(!statements.IsDefault, "Field 'statements' cannot be null (use Null=\"allow\" in LoweredNodes.xml to remove this check)");

            this.Locals = locals;
            this.LocalFunctions = localFunctions;
        }


        public ImmutableArray<LocalSymbol> Locals { get; }

        public ImmutableArray<LocalFunctionSymbol> LocalFunctions { get; }
        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitBlock(this);

        public LoweredBlock Update(ImmutableArray<LocalSymbol> locals, ImmutableArray<LocalFunctionSymbol> localFunctions, ImmutableArray<LoweredStatement> statements)
        {
            if (locals != this.Locals || localFunctions != this.LocalFunctions || statements != this.Statements)
            {
                var result = new LoweredBlock(this.Syntax, locals, localFunctions, statements, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal sealed partial class LoweredScope : LoweredStatementList
    {
        public LoweredScope(SyntaxNode syntax, ImmutableArray<LocalSymbol> locals, ImmutableArray<LoweredStatement> statements, bool hasErrors = false)
            : base(LoweredKind.Scope, syntax, statements, hasErrors || statements.HasErrors())
        {

            RoslynDebug.Assert(!locals.IsDefault, "Field 'locals' cannot be null (use Null=\"allow\" in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(!statements.IsDefault, "Field 'statements' cannot be null (use Null=\"allow\" in LoweredNodes.xml to remove this check)");

            this.Locals = locals;
        }


        public ImmutableArray<LocalSymbol> Locals { get; }
        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitScope(this);

        public LoweredScope Update(ImmutableArray<LocalSymbol> locals, ImmutableArray<LoweredStatement> statements)
        {
            if (locals != this.Locals || statements != this.Statements)
            {
                var result = new LoweredScope(this.Syntax, locals, statements, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal sealed partial class LoweredStateMachineScope : LoweredStatement
    {
        public LoweredStateMachineScope(SyntaxNode syntax, ImmutableArray<StateMachineFieldSymbol> fields, LoweredStatement statement, bool hasErrors = false)
            : base(LoweredKind.StateMachineScope, syntax, hasErrors || statement.HasErrors())
        {

            RoslynDebug.Assert(!fields.IsDefault, "Field 'fields' cannot be null (use Null=\"allow\" in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(statement is object, "Field 'statement' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

            this.Fields = fields;
            this.Statement = statement;
        }


        public ImmutableArray<StateMachineFieldSymbol> Fields { get; }

        public LoweredStatement Statement { get; }
        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitStateMachineScope(this);

        public LoweredStateMachineScope Update(ImmutableArray<StateMachineFieldSymbol> fields, LoweredStatement statement)
        {
            if (fields != this.Fields || statement != this.Statement)
            {
                var result = new LoweredStateMachineScope(this.Syntax, fields, statement, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal sealed partial class LoweredLocalDeclaration : LoweredStatement
    {
        public LoweredLocalDeclaration(SyntaxNode syntax, LocalSymbol localSymbol, LoweredTypeExpression? declaredTypeOpt, LoweredExpression? initializerOpt, ImmutableArray<LoweredExpression> argumentsOpt, bool inferredType, bool hasErrors = false)
            : base(LoweredKind.LocalDeclaration, syntax, hasErrors || declaredTypeOpt.HasErrors() || initializerOpt.HasErrors() || argumentsOpt.HasErrors())
        {

            RoslynDebug.Assert(localSymbol is object, "Field 'localSymbol' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

            this.LocalSymbol = localSymbol;
            this.DeclaredTypeOpt = declaredTypeOpt;
            this.InitializerOpt = initializerOpt;
            this.ArgumentsOpt = argumentsOpt;
            this.InferredType = inferredType;
        }


        public LocalSymbol LocalSymbol { get; }

        public LoweredTypeExpression? DeclaredTypeOpt { get; }

        public LoweredExpression? InitializerOpt { get; }

        public ImmutableArray<LoweredExpression> ArgumentsOpt { get; }

        public bool InferredType { get; }
        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitLocalDeclaration(this);

        public LoweredLocalDeclaration Update(LocalSymbol localSymbol, LoweredTypeExpression? declaredTypeOpt, LoweredExpression? initializerOpt, ImmutableArray<LoweredExpression> argumentsOpt, bool inferredType)
        {
            if (!Symbols.SymbolEqualityComparer.ConsiderEverything.Equals(localSymbol, this.LocalSymbol) || declaredTypeOpt != this.DeclaredTypeOpt || initializerOpt != this.InitializerOpt || argumentsOpt != this.ArgumentsOpt || inferredType != this.InferredType)
            {
                var result = new LoweredLocalDeclaration(this.Syntax, localSymbol, declaredTypeOpt, initializerOpt, argumentsOpt, inferredType, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal abstract partial class LoweredMultipleLocalDeclarationsBase : LoweredStatement
    {
        protected LoweredMultipleLocalDeclarationsBase(LoweredKind kind, SyntaxNode syntax, ImmutableArray<LoweredLocalDeclaration> localDeclarations, bool hasErrors = false)
            : base(kind, syntax, hasErrors)
        {

            RoslynDebug.Assert(!localDeclarations.IsDefault, "Field 'localDeclarations' cannot be null (use Null=\"allow\" in LoweredNodes.xml to remove this check)");

            this.LocalDeclarations = localDeclarations;
        }


        public ImmutableArray<LoweredLocalDeclaration> LocalDeclarations { get; }
    }

    internal sealed partial class LoweredMultipleLocalDeclarations : LoweredMultipleLocalDeclarationsBase
    {
        public LoweredMultipleLocalDeclarations(SyntaxNode syntax, ImmutableArray<LoweredLocalDeclaration> localDeclarations, bool hasErrors = false)
            : base(LoweredKind.MultipleLocalDeclarations, syntax, localDeclarations, hasErrors || localDeclarations.HasErrors())
        {

            RoslynDebug.Assert(!localDeclarations.IsDefault, "Field 'localDeclarations' cannot be null (use Null=\"allow\" in LoweredNodes.xml to remove this check)");

        }

        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitMultipleLocalDeclarations(this);

        public LoweredMultipleLocalDeclarations Update(ImmutableArray<LoweredLocalDeclaration> localDeclarations)
        {
            if (localDeclarations != this.LocalDeclarations)
            {
                var result = new LoweredMultipleLocalDeclarations(this.Syntax, localDeclarations, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal sealed partial class LoweredUsingLocalDeclarations : LoweredMultipleLocalDeclarationsBase
    {
        public LoweredUsingLocalDeclarations(SyntaxNode syntax, MethodSymbol? disposeMethodOpt, Conversion iDisposableConversion, LoweredAwaitableInfo? awaitOpt, ImmutableArray<LoweredLocalDeclaration> localDeclarations, bool hasErrors = false)
            : base(LoweredKind.UsingLocalDeclarations, syntax, localDeclarations, hasErrors || awaitOpt.HasErrors() || localDeclarations.HasErrors())
        {

            RoslynDebug.Assert(!localDeclarations.IsDefault, "Field 'localDeclarations' cannot be null (use Null=\"allow\" in LoweredNodes.xml to remove this check)");

            this.DisposeMethodOpt = disposeMethodOpt;
            this.IDisposableConversion = iDisposableConversion;
            this.AwaitOpt = awaitOpt;
        }


        public MethodSymbol? DisposeMethodOpt { get; }

        public Conversion IDisposableConversion { get; }

        public LoweredAwaitableInfo? AwaitOpt { get; }
        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitUsingLocalDeclarations(this);

        public LoweredUsingLocalDeclarations Update(MethodSymbol? disposeMethodOpt, Conversion iDisposableConversion, LoweredAwaitableInfo? awaitOpt, ImmutableArray<LoweredLocalDeclaration> localDeclarations)
        {
            if (!Symbols.SymbolEqualityComparer.ConsiderEverything.Equals(disposeMethodOpt, this.DisposeMethodOpt) || iDisposableConversion != this.IDisposableConversion || awaitOpt != this.AwaitOpt || localDeclarations != this.LocalDeclarations)
            {
                var result = new LoweredUsingLocalDeclarations(this.Syntax, disposeMethodOpt, iDisposableConversion, awaitOpt, localDeclarations, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal sealed partial class LoweredLocalFunctionStatement : LoweredStatement
    {
        public LoweredLocalFunctionStatement(SyntaxNode syntax, LocalFunctionSymbol symbol, LoweredBlock? blockBody, LoweredBlock? expressionBody, bool hasErrors = false)
            : base(LoweredKind.LocalFunctionStatement, syntax, hasErrors || blockBody.HasErrors() || expressionBody.HasErrors())
        {

            RoslynDebug.Assert(symbol is object, "Field 'symbol' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

            this.Symbol = symbol;
            this.BlockBody = blockBody;
            this.ExpressionBody = expressionBody;
        }


        public LocalFunctionSymbol Symbol { get; }

        public LoweredBlock? BlockBody { get; }

        public LoweredBlock? ExpressionBody { get; }
        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitLocalFunctionStatement(this);

        public LoweredLocalFunctionStatement Update(LocalFunctionSymbol symbol, LoweredBlock? blockBody, LoweredBlock? expressionBody)
        {
            if (!Symbols.SymbolEqualityComparer.ConsiderEverything.Equals(symbol, this.Symbol) || blockBody != this.BlockBody || expressionBody != this.ExpressionBody)
            {
                var result = new LoweredLocalFunctionStatement(this.Syntax, symbol, blockBody, expressionBody, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal sealed partial class LoweredNoOpStatement : LoweredStatement
    {
        public LoweredNoOpStatement(SyntaxNode syntax, NoOpStatementFlavor flavor, bool hasErrors)
            : base(LoweredKind.NoOpStatement, syntax, hasErrors)
        {
            this.Flavor = flavor;
        }

        public LoweredNoOpStatement(SyntaxNode syntax, NoOpStatementFlavor flavor)
            : base(LoweredKind.NoOpStatement, syntax)
        {
            this.Flavor = flavor;
        }


        public NoOpStatementFlavor Flavor { get; }
        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitNoOpStatement(this);

        public LoweredNoOpStatement Update(NoOpStatementFlavor flavor)
        {
            if (flavor != this.Flavor)
            {
                var result = new LoweredNoOpStatement(this.Syntax, flavor, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal sealed partial class LoweredReturnStatement : LoweredStatement
    {
        public LoweredReturnStatement(SyntaxNode syntax, RefKind refKind, LoweredExpression? expressionOpt, bool hasErrors = false)
            : base(LoweredKind.ReturnStatement, syntax, hasErrors || expressionOpt.HasErrors())
        {
            this.RefKind = refKind;
            this.ExpressionOpt = expressionOpt;
        }


        public RefKind RefKind { get; }

        public LoweredExpression? ExpressionOpt { get; }
        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitReturnStatement(this);

        public LoweredReturnStatement Update(RefKind refKind, LoweredExpression? expressionOpt)
        {
            if (refKind != this.RefKind || expressionOpt != this.ExpressionOpt)
            {
                var result = new LoweredReturnStatement(this.Syntax, refKind, expressionOpt, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal sealed partial class LoweredYieldReturnStatement : LoweredStatement
    {
        public LoweredYieldReturnStatement(SyntaxNode syntax, LoweredExpression expression, bool hasErrors = false)
            : base(LoweredKind.YieldReturnStatement, syntax, hasErrors || expression.HasErrors())
        {

            RoslynDebug.Assert(expression is object, "Field 'expression' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

            this.Expression = expression;
        }


        public LoweredExpression Expression { get; }
        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitYieldReturnStatement(this);

        public LoweredYieldReturnStatement Update(LoweredExpression expression)
        {
            if (expression != this.Expression)
            {
                var result = new LoweredYieldReturnStatement(this.Syntax, expression, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal sealed partial class LoweredYieldBreakStatement : LoweredStatement
    {
        public LoweredYieldBreakStatement(SyntaxNode syntax, bool hasErrors)
            : base(LoweredKind.YieldBreakStatement, syntax, hasErrors)
        {
        }

        public LoweredYieldBreakStatement(SyntaxNode syntax)
            : base(LoweredKind.YieldBreakStatement, syntax)
        {
        }

        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitYieldBreakStatement(this);
    }

    internal sealed partial class LoweredThrowStatement : LoweredStatement
    {
        public LoweredThrowStatement(SyntaxNode syntax, LoweredExpression? expressionOpt, bool hasErrors = false)
            : base(LoweredKind.ThrowStatement, syntax, hasErrors || expressionOpt.HasErrors())
        {
            this.ExpressionOpt = expressionOpt;
        }


        public LoweredExpression? ExpressionOpt { get; }
        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitThrowStatement(this);

        public LoweredThrowStatement Update(LoweredExpression? expressionOpt)
        {
            if (expressionOpt != this.ExpressionOpt)
            {
                var result = new LoweredThrowStatement(this.Syntax, expressionOpt, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal sealed partial class LoweredExpressionStatement : LoweredStatement
    {
        public LoweredExpressionStatement(SyntaxNode syntax, LoweredExpression expression, bool hasErrors = false)
            : base(LoweredKind.ExpressionStatement, syntax, hasErrors || expression.HasErrors())
        {

            RoslynDebug.Assert(expression is object, "Field 'expression' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

            this.Expression = expression;
        }


        public LoweredExpression Expression { get; }
        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitExpressionStatement(this);

        public LoweredExpressionStatement Update(LoweredExpression expression)
        {
            if (expression != this.Expression)
            {
                var result = new LoweredExpressionStatement(this.Syntax, expression, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal sealed partial class LoweredBreakStatement : LoweredStatement
    {
        public LoweredBreakStatement(SyntaxNode syntax, GeneratedLabelSymbol label, bool hasErrors)
            : base(LoweredKind.BreakStatement, syntax, hasErrors)
        {

            RoslynDebug.Assert(label is object, "Field 'label' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

            this.Label = label;
        }

        public LoweredBreakStatement(SyntaxNode syntax, GeneratedLabelSymbol label)
            : base(LoweredKind.BreakStatement, syntax)
        {

            RoslynDebug.Assert(label is object, "Field 'label' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

            this.Label = label;
        }


        public GeneratedLabelSymbol Label { get; }
        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitBreakStatement(this);

        public LoweredBreakStatement Update(GeneratedLabelSymbol label)
        {
            if (!Symbols.SymbolEqualityComparer.ConsiderEverything.Equals(label, this.Label))
            {
                var result = new LoweredBreakStatement(this.Syntax, label, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal sealed partial class LoweredContinueStatement : LoweredStatement
    {
        public LoweredContinueStatement(SyntaxNode syntax, GeneratedLabelSymbol label, bool hasErrors)
            : base(LoweredKind.ContinueStatement, syntax, hasErrors)
        {

            RoslynDebug.Assert(label is object, "Field 'label' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

            this.Label = label;
        }

        public LoweredContinueStatement(SyntaxNode syntax, GeneratedLabelSymbol label)
            : base(LoweredKind.ContinueStatement, syntax)
        {

            RoslynDebug.Assert(label is object, "Field 'label' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

            this.Label = label;
        }


        public GeneratedLabelSymbol Label { get; }
        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitContinueStatement(this);

        public LoweredContinueStatement Update(GeneratedLabelSymbol label)
        {
            if (!Symbols.SymbolEqualityComparer.ConsiderEverything.Equals(label, this.Label))
            {
                var result = new LoweredContinueStatement(this.Syntax, label, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal sealed partial class LoweredSwitchStatement : LoweredStatement
    {
        public LoweredSwitchStatement(SyntaxNode syntax, LoweredExpression expression, ImmutableArray<LocalSymbol> innerLocals, ImmutableArray<LocalFunctionSymbol> innerLocalFunctions, ImmutableArray<LoweredSwitchSection> switchSections, LoweredDecisionDag decisionDag, LoweredSwitchLabel? defaultLabel, GeneratedLabelSymbol breakLabel, bool hasErrors = false)
            : base(LoweredKind.SwitchStatement, syntax, hasErrors || expression.HasErrors() || switchSections.HasErrors() || decisionDag.HasErrors() || defaultLabel.HasErrors())
        {

            RoslynDebug.Assert(expression is object, "Field 'expression' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(!innerLocals.IsDefault, "Field 'innerLocals' cannot be null (use Null=\"allow\" in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(!innerLocalFunctions.IsDefault, "Field 'innerLocalFunctions' cannot be null (use Null=\"allow\" in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(!switchSections.IsDefault, "Field 'switchSections' cannot be null (use Null=\"allow\" in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(decisionDag is object, "Field 'decisionDag' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(breakLabel is object, "Field 'breakLabel' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

            this.Expression = expression;
            this.InnerLocals = innerLocals;
            this.InnerLocalFunctions = innerLocalFunctions;
            this.SwitchSections = switchSections;
            this.DecisionDag = decisionDag;
            this.DefaultLabel = defaultLabel;
            this.BreakLabel = breakLabel;
        }


        public LoweredExpression Expression { get; }

        public ImmutableArray<LocalSymbol> InnerLocals { get; }

        public ImmutableArray<LocalFunctionSymbol> InnerLocalFunctions { get; }

        public ImmutableArray<LoweredSwitchSection> SwitchSections { get; }

        public LoweredDecisionDag DecisionDag { get; }

        public LoweredSwitchLabel? DefaultLabel { get; }

        public GeneratedLabelSymbol BreakLabel { get; }
        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitSwitchStatement(this);

        public LoweredSwitchStatement Update(LoweredExpression expression, ImmutableArray<LocalSymbol> innerLocals, ImmutableArray<LocalFunctionSymbol> innerLocalFunctions, ImmutableArray<LoweredSwitchSection> switchSections, LoweredDecisionDag decisionDag, LoweredSwitchLabel? defaultLabel, GeneratedLabelSymbol breakLabel)
        {
            if (expression != this.Expression || innerLocals != this.InnerLocals || innerLocalFunctions != this.InnerLocalFunctions || switchSections != this.SwitchSections || decisionDag != this.DecisionDag || defaultLabel != this.DefaultLabel || !Symbols.SymbolEqualityComparer.ConsiderEverything.Equals(breakLabel, this.BreakLabel))
            {
                var result = new LoweredSwitchStatement(this.Syntax, expression, innerLocals, innerLocalFunctions, switchSections, decisionDag, defaultLabel, breakLabel, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal sealed partial class LoweredSwitchDispatch : LoweredStatement
    {
        public LoweredSwitchDispatch(SyntaxNode syntax, LoweredExpression expression, ImmutableArray<(ConstantValue value, LabelSymbol label)> cases, LabelSymbol defaultLabel, MethodSymbol? equalityMethod, bool hasErrors = false)
            : base(LoweredKind.SwitchDispatch, syntax, hasErrors || expression.HasErrors())
        {

            RoslynDebug.Assert(expression is object, "Field 'expression' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(!cases.IsDefault, "Field 'cases' cannot be null (use Null=\"allow\" in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(defaultLabel is object, "Field 'defaultLabel' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

            this.Expression = expression;
            this.Cases = cases;
            this.DefaultLabel = defaultLabel;
            this.EqualityMethod = equalityMethod;
        }


        public LoweredExpression Expression { get; }

        public ImmutableArray<(ConstantValue value, LabelSymbol label)> Cases { get; }

        public LabelSymbol DefaultLabel { get; }

        public MethodSymbol? EqualityMethod { get; }
        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitSwitchDispatch(this);

        public LoweredSwitchDispatch Update(LoweredExpression expression, ImmutableArray<(ConstantValue value, LabelSymbol label)> cases, LabelSymbol defaultLabel, MethodSymbol? equalityMethod)
        {
            if (expression != this.Expression || cases != this.Cases || !Symbols.SymbolEqualityComparer.ConsiderEverything.Equals(defaultLabel, this.DefaultLabel) || !Symbols.SymbolEqualityComparer.ConsiderEverything.Equals(equalityMethod, this.EqualityMethod))
            {
                var result = new LoweredSwitchDispatch(this.Syntax, expression, cases, defaultLabel, equalityMethod, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal sealed partial class LoweredIfStatement : LoweredStatement
    {
        public LoweredIfStatement(SyntaxNode syntax, LoweredExpression condition, LoweredStatement consequence, LoweredStatement? alternativeOpt, bool hasErrors = false)
            : base(LoweredKind.IfStatement, syntax, hasErrors || condition.HasErrors() || consequence.HasErrors() || alternativeOpt.HasErrors())
        {

            RoslynDebug.Assert(condition is object, "Field 'condition' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(consequence is object, "Field 'consequence' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

            this.Condition = condition;
            this.Consequence = consequence;
            this.AlternativeOpt = alternativeOpt;
        }


        public LoweredExpression Condition { get; }

        public LoweredStatement Consequence { get; }

        public LoweredStatement? AlternativeOpt { get; }
        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitIfStatement(this);

        public LoweredIfStatement Update(LoweredExpression condition, LoweredStatement consequence, LoweredStatement? alternativeOpt)
        {
            if (condition != this.Condition || consequence != this.Consequence || alternativeOpt != this.AlternativeOpt)
            {
                var result = new LoweredIfStatement(this.Syntax, condition, consequence, alternativeOpt, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal abstract partial class LoweredLoopStatement : LoweredStatement
    {
        protected LoweredLoopStatement(LoweredKind kind, SyntaxNode syntax, GeneratedLabelSymbol breakLabel, GeneratedLabelSymbol continueLabel, bool hasErrors)
            : base(kind, syntax, hasErrors)
        {

            RoslynDebug.Assert(breakLabel is object, "Field 'breakLabel' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(continueLabel is object, "Field 'continueLabel' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

            this.BreakLabel = breakLabel;
            this.ContinueLabel = continueLabel;
        }

        protected LoweredLoopStatement(LoweredKind kind, SyntaxNode syntax, GeneratedLabelSymbol breakLabel, GeneratedLabelSymbol continueLabel)
            : base(kind, syntax)
        {

            RoslynDebug.Assert(breakLabel is object, "Field 'breakLabel' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(continueLabel is object, "Field 'continueLabel' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

            this.BreakLabel = breakLabel;
            this.ContinueLabel = continueLabel;
        }


        public GeneratedLabelSymbol BreakLabel { get; }

        public GeneratedLabelSymbol ContinueLabel { get; }
    }

    internal abstract partial class LoweredConditionalLoopStatement : LoweredLoopStatement
    {
        protected LoweredConditionalLoopStatement(LoweredKind kind, SyntaxNode syntax, ImmutableArray<LocalSymbol> locals, LoweredExpression condition, LoweredStatement body, GeneratedLabelSymbol breakLabel, GeneratedLabelSymbol continueLabel, bool hasErrors = false)
            : base(kind, syntax, breakLabel, continueLabel, hasErrors)
        {

            RoslynDebug.Assert(!locals.IsDefault, "Field 'locals' cannot be null (use Null=\"allow\" in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(condition is object, "Field 'condition' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(body is object, "Field 'body' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(breakLabel is object, "Field 'breakLabel' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(continueLabel is object, "Field 'continueLabel' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

            this.Locals = locals;
            this.Condition = condition;
            this.Body = body;
        }


        public ImmutableArray<LocalSymbol> Locals { get; }

        public LoweredExpression Condition { get; }

        public LoweredStatement Body { get; }
    }

    internal sealed partial class LoweredDoStatement : LoweredConditionalLoopStatement
    {
        public LoweredDoStatement(SyntaxNode syntax, ImmutableArray<LocalSymbol> locals, LoweredExpression condition, LoweredStatement body, GeneratedLabelSymbol breakLabel, GeneratedLabelSymbol continueLabel, bool hasErrors = false)
            : base(LoweredKind.DoStatement, syntax, locals, condition, body, breakLabel, continueLabel, hasErrors || condition.HasErrors() || body.HasErrors())
        {

            RoslynDebug.Assert(!locals.IsDefault, "Field 'locals' cannot be null (use Null=\"allow\" in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(condition is object, "Field 'condition' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(body is object, "Field 'body' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(breakLabel is object, "Field 'breakLabel' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(continueLabel is object, "Field 'continueLabel' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

        }

        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitDoStatement(this);

        public LoweredDoStatement Update(ImmutableArray<LocalSymbol> locals, LoweredExpression condition, LoweredStatement body, GeneratedLabelSymbol breakLabel, GeneratedLabelSymbol continueLabel)
        {
            if (locals != this.Locals || condition != this.Condition || body != this.Body || !Symbols.SymbolEqualityComparer.ConsiderEverything.Equals(breakLabel, this.BreakLabel) || !Symbols.SymbolEqualityComparer.ConsiderEverything.Equals(continueLabel, this.ContinueLabel))
            {
                var result = new LoweredDoStatement(this.Syntax, locals, condition, body, breakLabel, continueLabel, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal sealed partial class LoweredWhileStatement : LoweredConditionalLoopStatement
    {
        public LoweredWhileStatement(SyntaxNode syntax, ImmutableArray<LocalSymbol> locals, LoweredExpression condition, LoweredStatement body, GeneratedLabelSymbol breakLabel, GeneratedLabelSymbol continueLabel, bool hasErrors = false)
            : base(LoweredKind.WhileStatement, syntax, locals, condition, body, breakLabel, continueLabel, hasErrors || condition.HasErrors() || body.HasErrors())
        {

            RoslynDebug.Assert(!locals.IsDefault, "Field 'locals' cannot be null (use Null=\"allow\" in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(condition is object, "Field 'condition' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(body is object, "Field 'body' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(breakLabel is object, "Field 'breakLabel' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(continueLabel is object, "Field 'continueLabel' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

        }

        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitWhileStatement(this);

        public LoweredWhileStatement Update(ImmutableArray<LocalSymbol> locals, LoweredExpression condition, LoweredStatement body, GeneratedLabelSymbol breakLabel, GeneratedLabelSymbol continueLabel)
        {
            if (locals != this.Locals || condition != this.Condition || body != this.Body || !Symbols.SymbolEqualityComparer.ConsiderEverything.Equals(breakLabel, this.BreakLabel) || !Symbols.SymbolEqualityComparer.ConsiderEverything.Equals(continueLabel, this.ContinueLabel))
            {
                var result = new LoweredWhileStatement(this.Syntax, locals, condition, body, breakLabel, continueLabel, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal sealed partial class LoweredForStatement : LoweredLoopStatement
    {
        public LoweredForStatement(SyntaxNode syntax, ImmutableArray<LocalSymbol> outerLocals, LoweredStatement? initializer, ImmutableArray<LocalSymbol> innerLocals, LoweredExpression? condition, LoweredStatement? increment, LoweredStatement body, GeneratedLabelSymbol breakLabel, GeneratedLabelSymbol continueLabel, bool hasErrors = false)
            : base(LoweredKind.ForStatement, syntax, breakLabel, continueLabel, hasErrors || initializer.HasErrors() || condition.HasErrors() || increment.HasErrors() || body.HasErrors())
        {

            RoslynDebug.Assert(!outerLocals.IsDefault, "Field 'outerLocals' cannot be null (use Null=\"allow\" in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(!innerLocals.IsDefault, "Field 'innerLocals' cannot be null (use Null=\"allow\" in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(body is object, "Field 'body' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(breakLabel is object, "Field 'breakLabel' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(continueLabel is object, "Field 'continueLabel' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

            this.OuterLocals = outerLocals;
            this.Initializer = initializer;
            this.InnerLocals = innerLocals;
            this.Condition = condition;
            this.Increment = increment;
            this.Body = body;
        }


        public ImmutableArray<LocalSymbol> OuterLocals { get; }

        public LoweredStatement? Initializer { get; }

        public ImmutableArray<LocalSymbol> InnerLocals { get; }

        public LoweredExpression? Condition { get; }

        public LoweredStatement? Increment { get; }

        public LoweredStatement Body { get; }
        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitForStatement(this);

        public LoweredForStatement Update(ImmutableArray<LocalSymbol> outerLocals, LoweredStatement? initializer, ImmutableArray<LocalSymbol> innerLocals, LoweredExpression? condition, LoweredStatement? increment, LoweredStatement body, GeneratedLabelSymbol breakLabel, GeneratedLabelSymbol continueLabel)
        {
            if (outerLocals != this.OuterLocals || initializer != this.Initializer || innerLocals != this.InnerLocals || condition != this.Condition || increment != this.Increment || body != this.Body || !Symbols.SymbolEqualityComparer.ConsiderEverything.Equals(breakLabel, this.BreakLabel) || !Symbols.SymbolEqualityComparer.ConsiderEverything.Equals(continueLabel, this.ContinueLabel))
            {
                var result = new LoweredForStatement(this.Syntax, outerLocals, initializer, innerLocals, condition, increment, body, breakLabel, continueLabel, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal sealed partial class LoweredForEachStatement : LoweredLoopStatement
    {
        public LoweredForEachStatement(SyntaxNode syntax, ForEachEnumeratorInfo? enumeratorInfoOpt, Conversion elementConversion, LoweredTypeExpression iterationVariableType, ImmutableArray<LocalSymbol> iterationVariables, LoweredExpression? iterationErrorExpressionOpt, LoweredExpression expression, LoweredForEachDeconstructStep? deconstructionOpt, LoweredAwaitableInfo? awaitOpt, LoweredStatement body, bool @checked, GeneratedLabelSymbol breakLabel, GeneratedLabelSymbol continueLabel, bool hasErrors = false)
            : base(LoweredKind.ForEachStatement, syntax, breakLabel, continueLabel, hasErrors || iterationVariableType.HasErrors() || iterationErrorExpressionOpt.HasErrors() || expression.HasErrors() || deconstructionOpt.HasErrors() || awaitOpt.HasErrors() || body.HasErrors())
        {

            RoslynDebug.Assert(iterationVariableType is object, "Field 'iterationVariableType' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(!iterationVariables.IsDefault, "Field 'iterationVariables' cannot be null (use Null=\"allow\" in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(expression is object, "Field 'expression' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(body is object, "Field 'body' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(breakLabel is object, "Field 'breakLabel' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(continueLabel is object, "Field 'continueLabel' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

            this.EnumeratorInfoOpt = enumeratorInfoOpt;
            this.ElementConversion = elementConversion;
            this.IterationVariableType = iterationVariableType;
            this.IterationVariables = iterationVariables;
            this.IterationErrorExpressionOpt = iterationErrorExpressionOpt;
            this.Expression = expression;
            this.DeconstructionOpt = deconstructionOpt;
            this.AwaitOpt = awaitOpt;
            this.Body = body;
            this.Checked = @checked;
        }


        public ForEachEnumeratorInfo? EnumeratorInfoOpt { get; }

        public Conversion ElementConversion { get; }

        public LoweredTypeExpression IterationVariableType { get; }

        public ImmutableArray<LocalSymbol> IterationVariables { get; }

        public LoweredExpression? IterationErrorExpressionOpt { get; }

        public LoweredExpression Expression { get; }

        public LoweredForEachDeconstructStep? DeconstructionOpt { get; }

        public LoweredAwaitableInfo? AwaitOpt { get; }

        public LoweredStatement Body { get; }

        public bool Checked { get; }
        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitForEachStatement(this);

        public LoweredForEachStatement Update(ForEachEnumeratorInfo? enumeratorInfoOpt, Conversion elementConversion, LoweredTypeExpression iterationVariableType, ImmutableArray<LocalSymbol> iterationVariables, LoweredExpression? iterationErrorExpressionOpt, LoweredExpression expression, LoweredForEachDeconstructStep? deconstructionOpt, LoweredAwaitableInfo? awaitOpt, LoweredStatement body, bool @checked, GeneratedLabelSymbol breakLabel, GeneratedLabelSymbol continueLabel)
        {
            if (enumeratorInfoOpt != this.EnumeratorInfoOpt || elementConversion != this.ElementConversion || iterationVariableType != this.IterationVariableType || iterationVariables != this.IterationVariables || iterationErrorExpressionOpt != this.IterationErrorExpressionOpt || expression != this.Expression || deconstructionOpt != this.DeconstructionOpt || awaitOpt != this.AwaitOpt || body != this.Body || @checked != this.Checked || !Symbols.SymbolEqualityComparer.ConsiderEverything.Equals(breakLabel, this.BreakLabel) || !Symbols.SymbolEqualityComparer.ConsiderEverything.Equals(continueLabel, this.ContinueLabel))
            {
                var result = new LoweredForEachStatement(this.Syntax, enumeratorInfoOpt, elementConversion, iterationVariableType, iterationVariables, iterationErrorExpressionOpt, expression, deconstructionOpt, awaitOpt, body, @checked, breakLabel, continueLabel, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal sealed partial class LoweredForEachDeconstructStep : LoweredNode
    {
        public LoweredForEachDeconstructStep(SyntaxNode syntax, LoweredDeconstructionAssignmentOperator deconstructionAssignment, LoweredDeconstructValuePlaceholder targetPlaceholder, bool hasErrors = false)
            : base(LoweredKind.ForEachDeconstructStep, syntax, hasErrors || deconstructionAssignment.HasErrors() || targetPlaceholder.HasErrors())
        {

            RoslynDebug.Assert(deconstructionAssignment is object, "Field 'deconstructionAssignment' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(targetPlaceholder is object, "Field 'targetPlaceholder' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

            this.DeconstructionAssignment = deconstructionAssignment;
            this.TargetPlaceholder = targetPlaceholder;
        }


        public LoweredDeconstructionAssignmentOperator DeconstructionAssignment { get; }

        public LoweredDeconstructValuePlaceholder TargetPlaceholder { get; }
        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitForEachDeconstructStep(this);

        public LoweredForEachDeconstructStep Update(LoweredDeconstructionAssignmentOperator deconstructionAssignment, LoweredDeconstructValuePlaceholder targetPlaceholder)
        {
            if (deconstructionAssignment != this.DeconstructionAssignment || targetPlaceholder != this.TargetPlaceholder)
            {
                var result = new LoweredForEachDeconstructStep(this.Syntax, deconstructionAssignment, targetPlaceholder, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal sealed partial class LoweredUsingStatement : LoweredStatement
    {
        public LoweredUsingStatement(SyntaxNode syntax, ImmutableArray<LocalSymbol> locals, LoweredMultipleLocalDeclarations? declarationsOpt, LoweredExpression? expressionOpt, Conversion iDisposableConversion, LoweredStatement body, LoweredAwaitableInfo? awaitOpt, MethodSymbol? disposeMethodOpt, bool hasErrors = false)
            : base(LoweredKind.UsingStatement, syntax, hasErrors || declarationsOpt.HasErrors() || expressionOpt.HasErrors() || body.HasErrors() || awaitOpt.HasErrors())
        {

            RoslynDebug.Assert(!locals.IsDefault, "Field 'locals' cannot be null (use Null=\"allow\" in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(body is object, "Field 'body' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

            this.Locals = locals;
            this.DeclarationsOpt = declarationsOpt;
            this.ExpressionOpt = expressionOpt;
            this.IDisposableConversion = iDisposableConversion;
            this.Body = body;
            this.AwaitOpt = awaitOpt;
            this.DisposeMethodOpt = disposeMethodOpt;
        }


        public ImmutableArray<LocalSymbol> Locals { get; }

        public LoweredMultipleLocalDeclarations? DeclarationsOpt { get; }

        public LoweredExpression? ExpressionOpt { get; }

        public Conversion IDisposableConversion { get; }

        public LoweredStatement Body { get; }

        public LoweredAwaitableInfo? AwaitOpt { get; }

        public MethodSymbol? DisposeMethodOpt { get; }
        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitUsingStatement(this);

        public LoweredUsingStatement Update(ImmutableArray<LocalSymbol> locals, LoweredMultipleLocalDeclarations? declarationsOpt, LoweredExpression? expressionOpt, Conversion iDisposableConversion, LoweredStatement body, LoweredAwaitableInfo? awaitOpt, MethodSymbol? disposeMethodOpt)
        {
            if (locals != this.Locals || declarationsOpt != this.DeclarationsOpt || expressionOpt != this.ExpressionOpt || iDisposableConversion != this.IDisposableConversion || body != this.Body || awaitOpt != this.AwaitOpt || !Symbols.SymbolEqualityComparer.ConsiderEverything.Equals(disposeMethodOpt, this.DisposeMethodOpt))
            {
                var result = new LoweredUsingStatement(this.Syntax, locals, declarationsOpt, expressionOpt, iDisposableConversion, body, awaitOpt, disposeMethodOpt, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal sealed partial class LoweredFixedStatement : LoweredStatement
    {
        public LoweredFixedStatement(SyntaxNode syntax, ImmutableArray<LocalSymbol> locals, LoweredMultipleLocalDeclarations declarations, LoweredStatement body, bool hasErrors = false)
            : base(LoweredKind.FixedStatement, syntax, hasErrors || declarations.HasErrors() || body.HasErrors())
        {

            RoslynDebug.Assert(!locals.IsDefault, "Field 'locals' cannot be null (use Null=\"allow\" in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(declarations is object, "Field 'declarations' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(body is object, "Field 'body' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

            this.Locals = locals;
            this.Declarations = declarations;
            this.Body = body;
        }


        public ImmutableArray<LocalSymbol> Locals { get; }

        public LoweredMultipleLocalDeclarations Declarations { get; }

        public LoweredStatement Body { get; }
        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitFixedStatement(this);

        public LoweredFixedStatement Update(ImmutableArray<LocalSymbol> locals, LoweredMultipleLocalDeclarations declarations, LoweredStatement body)
        {
            if (locals != this.Locals || declarations != this.Declarations || body != this.Body)
            {
                var result = new LoweredFixedStatement(this.Syntax, locals, declarations, body, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal sealed partial class LoweredLockStatement : LoweredStatement
    {
        public LoweredLockStatement(SyntaxNode syntax, LoweredExpression argument, LoweredStatement body, bool hasErrors = false)
            : base(LoweredKind.LockStatement, syntax, hasErrors || argument.HasErrors() || body.HasErrors())
        {

            RoslynDebug.Assert(argument is object, "Field 'argument' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(body is object, "Field 'body' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

            this.Argument = argument;
            this.Body = body;
        }


        public LoweredExpression Argument { get; }

        public LoweredStatement Body { get; }
        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitLockStatement(this);

        public LoweredLockStatement Update(LoweredExpression argument, LoweredStatement body)
        {
            if (argument != this.Argument || body != this.Body)
            {
                var result = new LoweredLockStatement(this.Syntax, argument, body, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal sealed partial class LoweredTryStatement : LoweredStatement
    {
        public LoweredTryStatement(SyntaxNode syntax, LoweredBlock tryBlock, ImmutableArray<LoweredCatchBlock> catchBlocks, LoweredBlock? finallyBlockOpt, LabelSymbol? finallyLabelOpt, bool preferFaultHandler, bool hasErrors = false)
            : base(LoweredKind.TryStatement, syntax, hasErrors || tryBlock.HasErrors() || catchBlocks.HasErrors() || finallyBlockOpt.HasErrors())
        {

            RoslynDebug.Assert(tryBlock is object, "Field 'tryBlock' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(!catchBlocks.IsDefault, "Field 'catchBlocks' cannot be null (use Null=\"allow\" in LoweredNodes.xml to remove this check)");

            this.TryBlock = tryBlock;
            this.CatchBlocks = catchBlocks;
            this.FinallyBlockOpt = finallyBlockOpt;
            this.FinallyLabelOpt = finallyLabelOpt;
            this.PreferFaultHandler = preferFaultHandler;
        }


        public LoweredBlock TryBlock { get; }

        public ImmutableArray<LoweredCatchBlock> CatchBlocks { get; }

        public LoweredBlock? FinallyBlockOpt { get; }

        public LabelSymbol? FinallyLabelOpt { get; }

        public bool PreferFaultHandler { get; }
        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitTryStatement(this);

        public LoweredTryStatement Update(LoweredBlock tryBlock, ImmutableArray<LoweredCatchBlock> catchBlocks, LoweredBlock? finallyBlockOpt, LabelSymbol? finallyLabelOpt, bool preferFaultHandler)
        {
            if (tryBlock != this.TryBlock || catchBlocks != this.CatchBlocks || finallyBlockOpt != this.FinallyBlockOpt || !Symbols.SymbolEqualityComparer.ConsiderEverything.Equals(finallyLabelOpt, this.FinallyLabelOpt) || preferFaultHandler != this.PreferFaultHandler)
            {
                var result = new LoweredTryStatement(this.Syntax, tryBlock, catchBlocks, finallyBlockOpt, finallyLabelOpt, preferFaultHandler, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal sealed partial class LoweredCatchBlock : LoweredNode
    {
        public LoweredCatchBlock(SyntaxNode syntax, ImmutableArray<LocalSymbol> locals, LoweredExpression? exceptionSourceOpt, TypeSymbol? exceptionTypeOpt, LoweredExpression? exceptionFilterOpt, LoweredBlock body, bool isSynthesizedAsyncCatchAll, bool hasErrors = false)
            : base(LoweredKind.CatchBlock, syntax, hasErrors || exceptionSourceOpt.HasErrors() || exceptionFilterOpt.HasErrors() || body.HasErrors())
        {

            RoslynDebug.Assert(!locals.IsDefault, "Field 'locals' cannot be null (use Null=\"allow\" in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(body is object, "Field 'body' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

            this.Locals = locals;
            this.ExceptionSourceOpt = exceptionSourceOpt;
            this.ExceptionTypeOpt = exceptionTypeOpt;
            this.ExceptionFilterOpt = exceptionFilterOpt;
            this.Body = body;
            this.IsSynthesizedAsyncCatchAll = isSynthesizedAsyncCatchAll;
        }


        public ImmutableArray<LocalSymbol> Locals { get; }

        public LoweredExpression? ExceptionSourceOpt { get; }

        public TypeSymbol? ExceptionTypeOpt { get; }

        public LoweredExpression? ExceptionFilterOpt { get; }

        public LoweredBlock Body { get; }

        public bool IsSynthesizedAsyncCatchAll { get; }
        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitCatchBlock(this);

        public LoweredCatchBlock Update(ImmutableArray<LocalSymbol> locals, LoweredExpression? exceptionSourceOpt, TypeSymbol? exceptionTypeOpt, LoweredExpression? exceptionFilterOpt, LoweredBlock body, bool isSynthesizedAsyncCatchAll)
        {
            if (locals != this.Locals || exceptionSourceOpt != this.ExceptionSourceOpt || !TypeSymbol.Equals(exceptionTypeOpt, this.ExceptionTypeOpt, TypeCompareKind.ConsiderEverything) || exceptionFilterOpt != this.ExceptionFilterOpt || body != this.Body || isSynthesizedAsyncCatchAll != this.IsSynthesizedAsyncCatchAll)
            {
                var result = new LoweredCatchBlock(this.Syntax, locals, exceptionSourceOpt, exceptionTypeOpt, exceptionFilterOpt, body, isSynthesizedAsyncCatchAll, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal sealed partial class LoweredLiteral : LoweredExpression
    {
        public LoweredLiteral(SyntaxNode syntax, ConstantValue? constantValueOpt, TypeSymbol? type, bool hasErrors)
            : base(LoweredKind.Literal, syntax, type, hasErrors)
        {
            this.ConstantValueOpt = constantValueOpt;
        }

        public LoweredLiteral(SyntaxNode syntax, ConstantValue? constantValueOpt, TypeSymbol? type)
            : base(LoweredKind.Literal, syntax, type)
        {
            this.ConstantValueOpt = constantValueOpt;
        }


        public ConstantValue? ConstantValueOpt { get; }
        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitLiteral(this);

        public LoweredLiteral Update(ConstantValue? constantValueOpt, TypeSymbol? type)
        {
            if (constantValueOpt != this.ConstantValueOpt || !TypeSymbol.Equals(type, this.Type, TypeCompareKind.ConsiderEverything))
            {
                var result = new LoweredLiteral(this.Syntax, constantValueOpt, type, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal sealed partial class LoweredThisReference : LoweredExpression
    {
        public LoweredThisReference(SyntaxNode syntax, TypeSymbol type, bool hasErrors)
            : base(LoweredKind.ThisReference, syntax, type, hasErrors)
        {

            RoslynDebug.Assert(type is object, "Field 'type' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

        }

        public LoweredThisReference(SyntaxNode syntax, TypeSymbol type)
            : base(LoweredKind.ThisReference, syntax, type)
        {

            RoslynDebug.Assert(type is object, "Field 'type' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

        }


        public new TypeSymbol Type => base.Type!;
        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitThisReference(this);

        public LoweredThisReference Update(TypeSymbol type)
        {
            if (!TypeSymbol.Equals(type, this.Type, TypeCompareKind.ConsiderEverything))
            {
                var result = new LoweredThisReference(this.Syntax, type, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal sealed partial class LoweredPreviousSubmissionReference : LoweredExpression
    {
        public LoweredPreviousSubmissionReference(SyntaxNode syntax, TypeSymbol type, bool hasErrors)
            : base(LoweredKind.PreviousSubmissionReference, syntax, type, hasErrors)
        {

            RoslynDebug.Assert(type is object, "Field 'type' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

        }

        public LoweredPreviousSubmissionReference(SyntaxNode syntax, TypeSymbol type)
            : base(LoweredKind.PreviousSubmissionReference, syntax, type)
        {

            RoslynDebug.Assert(type is object, "Field 'type' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

        }


        public new TypeSymbol Type => base.Type!;
        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitPreviousSubmissionReference(this);

        public LoweredPreviousSubmissionReference Update(TypeSymbol type)
        {
            if (!TypeSymbol.Equals(type, this.Type, TypeCompareKind.ConsiderEverything))
            {
                var result = new LoweredPreviousSubmissionReference(this.Syntax, type, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal sealed partial class LoweredHostObjectMemberReference : LoweredExpression
    {
        public LoweredHostObjectMemberReference(SyntaxNode syntax, TypeSymbol type, bool hasErrors)
            : base(LoweredKind.HostObjectMemberReference, syntax, type, hasErrors)
        {

            RoslynDebug.Assert(type is object, "Field 'type' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

        }

        public LoweredHostObjectMemberReference(SyntaxNode syntax, TypeSymbol type)
            : base(LoweredKind.HostObjectMemberReference, syntax, type)
        {

            RoslynDebug.Assert(type is object, "Field 'type' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

        }


        public new TypeSymbol Type => base.Type!;
        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitHostObjectMemberReference(this);

        public LoweredHostObjectMemberReference Update(TypeSymbol type)
        {
            if (!TypeSymbol.Equals(type, this.Type, TypeCompareKind.ConsiderEverything))
            {
                var result = new LoweredHostObjectMemberReference(this.Syntax, type, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal sealed partial class LoweredBaseReference : LoweredExpression
    {
        public LoweredBaseReference(SyntaxNode syntax, TypeSymbol? type, bool hasErrors)
            : base(LoweredKind.BaseReference, syntax, type, hasErrors)
        {
        }

        public LoweredBaseReference(SyntaxNode syntax, TypeSymbol? type)
            : base(LoweredKind.BaseReference, syntax, type)
        {
        }


        public new TypeSymbol? Type => base.Type!;
        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitBaseReference(this);

        public LoweredBaseReference Update(TypeSymbol? type)
        {
            if (!TypeSymbol.Equals(type, this.Type, TypeCompareKind.ConsiderEverything))
            {
                var result = new LoweredBaseReference(this.Syntax, type, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal sealed partial class LoweredLocal : LoweredExpression
    {
        public LoweredLocal(SyntaxNode syntax, LocalSymbol localSymbol, LoweredLocalDeclarationKind declarationKind, ConstantValue? constantValueOpt, bool isNullableUnknown, TypeSymbol type, bool hasErrors)
            : base(LoweredKind.Local, syntax, type, hasErrors)
        {

            RoslynDebug.Assert(localSymbol is object, "Field 'localSymbol' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(type is object, "Field 'type' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

            this.LocalSymbol = localSymbol;
            this.DeclarationKind = declarationKind;
            this.ConstantValueOpt = constantValueOpt;
            this.IsNullableUnknown = isNullableUnknown;
        }

        public LoweredLocal(SyntaxNode syntax, LocalSymbol localSymbol, LoweredLocalDeclarationKind declarationKind, ConstantValue? constantValueOpt, bool isNullableUnknown, TypeSymbol type)
            : base(LoweredKind.Local, syntax, type)
        {

            RoslynDebug.Assert(localSymbol is object, "Field 'localSymbol' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(type is object, "Field 'type' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

            this.LocalSymbol = localSymbol;
            this.DeclarationKind = declarationKind;
            this.ConstantValueOpt = constantValueOpt;
            this.IsNullableUnknown = isNullableUnknown;
        }


        public new TypeSymbol Type => base.Type!;

        public LocalSymbol LocalSymbol { get; }

        public LoweredLocalDeclarationKind DeclarationKind { get; }

        public ConstantValue? ConstantValueOpt { get; }

        public bool IsNullableUnknown { get; }
        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitLocal(this);

        public LoweredLocal Update(LocalSymbol localSymbol, LoweredLocalDeclarationKind declarationKind, ConstantValue? constantValueOpt, bool isNullableUnknown, TypeSymbol type)
        {
            if (!Symbols.SymbolEqualityComparer.ConsiderEverything.Equals(localSymbol, this.LocalSymbol) || declarationKind != this.DeclarationKind || constantValueOpt != this.ConstantValueOpt || isNullableUnknown != this.IsNullableUnknown || !TypeSymbol.Equals(type, this.Type, TypeCompareKind.ConsiderEverything))
            {
                var result = new LoweredLocal(this.Syntax, localSymbol, declarationKind, constantValueOpt, isNullableUnknown, type, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal sealed partial class LoweredPseudoVariable : LoweredExpression
    {
        public LoweredPseudoVariable(SyntaxNode syntax, LocalSymbol localSymbol, PseudoVariableExpressions emitExpressions, TypeSymbol type, bool hasErrors)
            : base(LoweredKind.PseudoVariable, syntax, type, hasErrors)
        {

            RoslynDebug.Assert(localSymbol is object, "Field 'localSymbol' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(emitExpressions is object, "Field 'emitExpressions' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(type is object, "Field 'type' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

            this.LocalSymbol = localSymbol;
            this.EmitExpressions = emitExpressions;
        }

        public LoweredPseudoVariable(SyntaxNode syntax, LocalSymbol localSymbol, PseudoVariableExpressions emitExpressions, TypeSymbol type)
            : base(LoweredKind.PseudoVariable, syntax, type)
        {

            RoslynDebug.Assert(localSymbol is object, "Field 'localSymbol' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(emitExpressions is object, "Field 'emitExpressions' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(type is object, "Field 'type' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

            this.LocalSymbol = localSymbol;
            this.EmitExpressions = emitExpressions;
        }


        public new TypeSymbol Type => base.Type!;

        public LocalSymbol LocalSymbol { get; }

        public PseudoVariableExpressions EmitExpressions { get; }
        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitPseudoVariable(this);

        public LoweredPseudoVariable Update(LocalSymbol localSymbol, PseudoVariableExpressions emitExpressions, TypeSymbol type)
        {
            if (!Symbols.SymbolEqualityComparer.ConsiderEverything.Equals(localSymbol, this.LocalSymbol) || emitExpressions != this.EmitExpressions || !TypeSymbol.Equals(type, this.Type, TypeCompareKind.ConsiderEverything))
            {
                var result = new LoweredPseudoVariable(this.Syntax, localSymbol, emitExpressions, type, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal sealed partial class LoweredRangeVariable : LoweredExpression
    {
        public LoweredRangeVariable(SyntaxNode syntax, RangeVariableSymbol rangeVariableSymbol, LoweredExpression value, TypeSymbol type, bool hasErrors = false)
            : base(LoweredKind.RangeVariable, syntax, type, hasErrors || value.HasErrors())
        {

            RoslynDebug.Assert(rangeVariableSymbol is object, "Field 'rangeVariableSymbol' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(value is object, "Field 'value' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(type is object, "Field 'type' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

            this.RangeVariableSymbol = rangeVariableSymbol;
            this.Value = value;
        }


        public new TypeSymbol Type => base.Type!;

        public RangeVariableSymbol RangeVariableSymbol { get; }

        public LoweredExpression Value { get; }
        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitRangeVariable(this);

        public LoweredRangeVariable Update(RangeVariableSymbol rangeVariableSymbol, LoweredExpression value, TypeSymbol type)
        {
            if (!Symbols.SymbolEqualityComparer.ConsiderEverything.Equals(rangeVariableSymbol, this.RangeVariableSymbol) || value != this.Value || !TypeSymbol.Equals(type, this.Type, TypeCompareKind.ConsiderEverything))
            {
                var result = new LoweredRangeVariable(this.Syntax, rangeVariableSymbol, value, type, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal sealed partial class LoweredParameter : LoweredExpression
    {
        public LoweredParameter(SyntaxNode syntax, ParameterSymbol parameterSymbol, TypeSymbol type, bool hasErrors)
            : base(LoweredKind.Parameter, syntax, type, hasErrors)
        {

            RoslynDebug.Assert(parameterSymbol is object, "Field 'parameterSymbol' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(type is object, "Field 'type' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

            this.ParameterSymbol = parameterSymbol;
        }

        public LoweredParameter(SyntaxNode syntax, ParameterSymbol parameterSymbol, TypeSymbol type)
            : base(LoweredKind.Parameter, syntax, type)
        {

            RoslynDebug.Assert(parameterSymbol is object, "Field 'parameterSymbol' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(type is object, "Field 'type' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

            this.ParameterSymbol = parameterSymbol;
        }


        public new TypeSymbol Type => base.Type!;

        public ParameterSymbol ParameterSymbol { get; }
        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitParameter(this);

        public LoweredParameter Update(ParameterSymbol parameterSymbol, TypeSymbol type)
        {
            if (!Symbols.SymbolEqualityComparer.ConsiderEverything.Equals(parameterSymbol, this.ParameterSymbol) || !TypeSymbol.Equals(type, this.Type, TypeCompareKind.ConsiderEverything))
            {
                var result = new LoweredParameter(this.Syntax, parameterSymbol, type, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal sealed partial class LoweredLabelStatement : LoweredStatement
    {
        public LoweredLabelStatement(SyntaxNode syntax, LabelSymbol label, bool hasErrors)
            : base(LoweredKind.LabelStatement, syntax, hasErrors)
        {

            RoslynDebug.Assert(label is object, "Field 'label' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

            this.Label = label;
        }

        public LoweredLabelStatement(SyntaxNode syntax, LabelSymbol label)
            : base(LoweredKind.LabelStatement, syntax)
        {

            RoslynDebug.Assert(label is object, "Field 'label' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

            this.Label = label;
        }


        public LabelSymbol Label { get; }
        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitLabelStatement(this);

        public LoweredLabelStatement Update(LabelSymbol label)
        {
            if (!Symbols.SymbolEqualityComparer.ConsiderEverything.Equals(label, this.Label))
            {
                var result = new LoweredLabelStatement(this.Syntax, label, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal sealed partial class LoweredGotoStatement : LoweredStatement
    {
        public LoweredGotoStatement(SyntaxNode syntax, LabelSymbol label, LoweredExpression? caseExpressionOpt, LoweredLabel? labelExpressionOpt, bool hasErrors = false)
            : base(LoweredKind.GotoStatement, syntax, hasErrors || caseExpressionOpt.HasErrors() || labelExpressionOpt.HasErrors())
        {

            RoslynDebug.Assert(label is object, "Field 'label' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

            this.Label = label;
            this.CaseExpressionOpt = caseExpressionOpt;
            this.LabelExpressionOpt = labelExpressionOpt;
        }


        public LabelSymbol Label { get; }

        public LoweredExpression? CaseExpressionOpt { get; }

        public LoweredLabel? LabelExpressionOpt { get; }
        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitGotoStatement(this);

        public LoweredGotoStatement Update(LabelSymbol label, LoweredExpression? caseExpressionOpt, LoweredLabel? labelExpressionOpt)
        {
            if (!Symbols.SymbolEqualityComparer.ConsiderEverything.Equals(label, this.Label) || caseExpressionOpt != this.CaseExpressionOpt || labelExpressionOpt != this.LabelExpressionOpt)
            {
                var result = new LoweredGotoStatement(this.Syntax, label, caseExpressionOpt, labelExpressionOpt, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal sealed partial class LoweredLabeledStatement : LoweredStatement
    {
        public LoweredLabeledStatement(SyntaxNode syntax, LabelSymbol label, LoweredStatement body, bool hasErrors = false)
            : base(LoweredKind.LabeledStatement, syntax, hasErrors || body.HasErrors())
        {

            RoslynDebug.Assert(label is object, "Field 'label' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(body is object, "Field 'body' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

            this.Label = label;
            this.Body = body;
        }


        public LabelSymbol Label { get; }

        public LoweredStatement Body { get; }
        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitLabeledStatement(this);

        public LoweredLabeledStatement Update(LabelSymbol label, LoweredStatement body)
        {
            if (!Symbols.SymbolEqualityComparer.ConsiderEverything.Equals(label, this.Label) || body != this.Body)
            {
                var result = new LoweredLabeledStatement(this.Syntax, label, body, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal sealed partial class LoweredLabel : LoweredExpression
    {
        public LoweredLabel(SyntaxNode syntax, LabelSymbol label, TypeSymbol? type, bool hasErrors)
            : base(LoweredKind.Label, syntax, type, hasErrors)
        {

            RoslynDebug.Assert(label is object, "Field 'label' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

            this.Label = label;
        }

        public LoweredLabel(SyntaxNode syntax, LabelSymbol label, TypeSymbol? type)
            : base(LoweredKind.Label, syntax, type)
        {

            RoslynDebug.Assert(label is object, "Field 'label' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

            this.Label = label;
        }


        public LabelSymbol Label { get; }
        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitLabel(this);

        public LoweredLabel Update(LabelSymbol label, TypeSymbol? type)
        {
            if (!Symbols.SymbolEqualityComparer.ConsiderEverything.Equals(label, this.Label) || !TypeSymbol.Equals(type, this.Type, TypeCompareKind.ConsiderEverything))
            {
                var result = new LoweredLabel(this.Syntax, label, type, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal partial class LoweredStatementList : LoweredStatement
    {
        protected LoweredStatementList(LoweredKind kind, SyntaxNode syntax, ImmutableArray<LoweredStatement> statements, bool hasErrors = false)
            : base(kind, syntax, hasErrors)
        {

            RoslynDebug.Assert(!statements.IsDefault, "Field 'statements' cannot be null (use Null=\"allow\" in LoweredNodes.xml to remove this check)");

            this.Statements = statements;
        }

        public LoweredStatementList(SyntaxNode syntax, ImmutableArray<LoweredStatement> statements, bool hasErrors = false)
            : base(LoweredKind.StatementList, syntax, hasErrors || statements.HasErrors())
        {

            RoslynDebug.Assert(!statements.IsDefault, "Field 'statements' cannot be null (use Null=\"allow\" in LoweredNodes.xml to remove this check)");

            this.Statements = statements;
        }


        public ImmutableArray<LoweredStatement> Statements { get; }
        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitStatementList(this);

        public LoweredStatementList Update(ImmutableArray<LoweredStatement> statements)
        {
            if (statements != this.Statements)
            {
                var result = new LoweredStatementList(this.Syntax, statements, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal sealed partial class LoweredConditionalGoto : LoweredStatement
    {
        public LoweredConditionalGoto(SyntaxNode syntax, LoweredExpression condition, bool jumpIfTrue, LabelSymbol label, bool hasErrors = false)
            : base(LoweredKind.ConditionalGoto, syntax, hasErrors || condition.HasErrors())
        {

            RoslynDebug.Assert(condition is object, "Field 'condition' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(label is object, "Field 'label' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

            this.Condition = condition;
            this.JumpIfTrue = jumpIfTrue;
            this.Label = label;
        }


        public LoweredExpression Condition { get; }

        public bool JumpIfTrue { get; }

        public LabelSymbol Label { get; }
        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitConditionalGoto(this);

        public LoweredConditionalGoto Update(LoweredExpression condition, bool jumpIfTrue, LabelSymbol label)
        {
            if (condition != this.Condition || jumpIfTrue != this.JumpIfTrue || !Symbols.SymbolEqualityComparer.ConsiderEverything.Equals(label, this.Label))
            {
                var result = new LoweredConditionalGoto(this.Syntax, condition, jumpIfTrue, label, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal abstract partial class LoweredSwitchExpression : LoweredExpression
    {
        protected LoweredSwitchExpression(LoweredKind kind, SyntaxNode syntax, LoweredExpression expression, ImmutableArray<LoweredSwitchExpressionArm> switchArms, LoweredDecisionDag decisionDag, LabelSymbol? defaultLabel, bool reportedNotExhaustive, TypeSymbol? type, bool hasErrors = false)
            : base(kind, syntax, type, hasErrors)
        {

            RoslynDebug.Assert(expression is object, "Field 'expression' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(!switchArms.IsDefault, "Field 'switchArms' cannot be null (use Null=\"allow\" in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(decisionDag is object, "Field 'decisionDag' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

            this.Expression = expression;
            this.SwitchArms = switchArms;
            this.DecisionDag = decisionDag;
            this.DefaultLabel = defaultLabel;
            this.ReportedNotExhaustive = reportedNotExhaustive;
        }


        public LoweredExpression Expression { get; }

        public ImmutableArray<LoweredSwitchExpressionArm> SwitchArms { get; }

        public LoweredDecisionDag DecisionDag { get; }

        public LabelSymbol? DefaultLabel { get; }

        public bool ReportedNotExhaustive { get; }
    }

    internal sealed partial class LoweredSwitchExpressionArm : LoweredNode
    {
        public LoweredSwitchExpressionArm(SyntaxNode syntax, ImmutableArray<LocalSymbol> locals, LoweredPattern pattern, LoweredExpression? whenClause, LoweredExpression value, LabelSymbol label, bool hasErrors = false)
            : base(LoweredKind.SwitchExpressionArm, syntax, hasErrors || pattern.HasErrors() || whenClause.HasErrors() || value.HasErrors())
        {

            RoslynDebug.Assert(!locals.IsDefault, "Field 'locals' cannot be null (use Null=\"allow\" in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(pattern is object, "Field 'pattern' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(value is object, "Field 'value' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(label is object, "Field 'label' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

            this.Locals = locals;
            this.Pattern = pattern;
            this.WhenClause = whenClause;
            this.Value = value;
            this.Label = label;
        }


        public ImmutableArray<LocalSymbol> Locals { get; }

        public LoweredPattern Pattern { get; }

        public LoweredExpression? WhenClause { get; }

        public LoweredExpression Value { get; }

        public LabelSymbol Label { get; }
        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitSwitchExpressionArm(this);

        public LoweredSwitchExpressionArm Update(ImmutableArray<LocalSymbol> locals, LoweredPattern pattern, LoweredExpression? whenClause, LoweredExpression value, LabelSymbol label)
        {
            if (locals != this.Locals || pattern != this.Pattern || whenClause != this.WhenClause || value != this.Value || !Symbols.SymbolEqualityComparer.ConsiderEverything.Equals(label, this.Label))
            {
                var result = new LoweredSwitchExpressionArm(this.Syntax, locals, pattern, whenClause, value, label, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal sealed partial class LoweredUnconvertedSwitchExpression : LoweredSwitchExpression
    {
        public LoweredUnconvertedSwitchExpression(SyntaxNode syntax, LoweredExpression expression, ImmutableArray<LoweredSwitchExpressionArm> switchArms, LoweredDecisionDag decisionDag, LabelSymbol? defaultLabel, bool reportedNotExhaustive, TypeSymbol? type, bool hasErrors = false)
            : base(LoweredKind.UnconvertedSwitchExpression, syntax, expression, switchArms, decisionDag, defaultLabel, reportedNotExhaustive, type, hasErrors || expression.HasErrors() || switchArms.HasErrors() || decisionDag.HasErrors())
        {

            RoslynDebug.Assert(expression is object, "Field 'expression' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(!switchArms.IsDefault, "Field 'switchArms' cannot be null (use Null=\"allow\" in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(decisionDag is object, "Field 'decisionDag' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

        }

        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitUnconvertedSwitchExpression(this);

        public LoweredUnconvertedSwitchExpression Update(LoweredExpression expression, ImmutableArray<LoweredSwitchExpressionArm> switchArms, LoweredDecisionDag decisionDag, LabelSymbol? defaultLabel, bool reportedNotExhaustive, TypeSymbol? type)
        {
            if (expression != this.Expression || switchArms != this.SwitchArms || decisionDag != this.DecisionDag || !Symbols.SymbolEqualityComparer.ConsiderEverything.Equals(defaultLabel, this.DefaultLabel) || reportedNotExhaustive != this.ReportedNotExhaustive || !TypeSymbol.Equals(type, this.Type, TypeCompareKind.ConsiderEverything))
            {
                var result = new LoweredUnconvertedSwitchExpression(this.Syntax, expression, switchArms, decisionDag, defaultLabel, reportedNotExhaustive, type, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal sealed partial class LoweredConvertedSwitchExpression : LoweredSwitchExpression
    {
        public LoweredConvertedSwitchExpression(SyntaxNode syntax, TypeSymbol? naturalTypeOpt, bool wasTargetTyped, LoweredExpression expression, ImmutableArray<LoweredSwitchExpressionArm> switchArms, LoweredDecisionDag decisionDag, LabelSymbol? defaultLabel, bool reportedNotExhaustive, TypeSymbol type, bool hasErrors = false)
            : base(LoweredKind.ConvertedSwitchExpression, syntax, expression, switchArms, decisionDag, defaultLabel, reportedNotExhaustive, type, hasErrors || expression.HasErrors() || switchArms.HasErrors() || decisionDag.HasErrors())
        {

            RoslynDebug.Assert(expression is object, "Field 'expression' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(!switchArms.IsDefault, "Field 'switchArms' cannot be null (use Null=\"allow\" in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(decisionDag is object, "Field 'decisionDag' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(type is object, "Field 'type' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

            this.NaturalTypeOpt = naturalTypeOpt;
            this.WasTargetTyped = wasTargetTyped;
        }


        public new TypeSymbol Type => base.Type!;

        public TypeSymbol? NaturalTypeOpt { get; }

        public bool WasTargetTyped { get; }
        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitConvertedSwitchExpression(this);

        public LoweredConvertedSwitchExpression Update(TypeSymbol? naturalTypeOpt, bool wasTargetTyped, LoweredExpression expression, ImmutableArray<LoweredSwitchExpressionArm> switchArms, LoweredDecisionDag decisionDag, LabelSymbol? defaultLabel, bool reportedNotExhaustive, TypeSymbol type)
        {
            if (!TypeSymbol.Equals(naturalTypeOpt, this.NaturalTypeOpt, TypeCompareKind.ConsiderEverything) || wasTargetTyped != this.WasTargetTyped || expression != this.Expression || switchArms != this.SwitchArms || decisionDag != this.DecisionDag || !Symbols.SymbolEqualityComparer.ConsiderEverything.Equals(defaultLabel, this.DefaultLabel) || reportedNotExhaustive != this.ReportedNotExhaustive || !TypeSymbol.Equals(type, this.Type, TypeCompareKind.ConsiderEverything))
            {
                var result = new LoweredConvertedSwitchExpression(this.Syntax, naturalTypeOpt, wasTargetTyped, expression, switchArms, decisionDag, defaultLabel, reportedNotExhaustive, type, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal sealed partial class LoweredDecisionDag : LoweredNode
    {
        public LoweredDecisionDag(SyntaxNode syntax, LoweredDecisionDagNode rootNode, bool hasErrors)
            : base(LoweredKind.DecisionDag, syntax, hasErrors)
        {

            RoslynDebug.Assert(rootNode is object, "Field 'rootNode' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

            this.RootNode = rootNode;
        }

        public LoweredDecisionDag(SyntaxNode syntax, LoweredDecisionDagNode rootNode)
            : base(LoweredKind.DecisionDag, syntax)
        {

            RoslynDebug.Assert(rootNode is object, "Field 'rootNode' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

            this.RootNode = rootNode;
        }


        public LoweredDecisionDagNode RootNode { get; }
        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitDecisionDag(this);

        public LoweredDecisionDag Update(LoweredDecisionDagNode rootNode)
        {
            if (rootNode != this.RootNode)
            {
                var result = new LoweredDecisionDag(this.Syntax, rootNode, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal abstract partial class LoweredDecisionDagNode  : LoweredNode
    {
        protected LoweredDecisionDagNode (LoweredKind kind, SyntaxNode syntax, bool hasErrors)
            : base(kind, syntax, hasErrors)
        {
        }

        protected LoweredDecisionDagNode (LoweredKind kind, SyntaxNode syntax)
            : base(kind, syntax)
        {
        }

    }

    internal sealed partial class LoweredEvaluationDecisionDagNode : LoweredDecisionDagNode 
    {
        public LoweredEvaluationDecisionDagNode(SyntaxNode syntax, LoweredDagEvaluation evaluation, LoweredDecisionDagNode  next, bool hasErrors = false)
            : base(LoweredKind.EvaluationDecisionDagNode, syntax, hasErrors || evaluation.HasErrors() || next.HasErrors())
        {

            RoslynDebug.Assert(evaluation is object, "Field 'evaluation' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(next is object, "Field 'next' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

            this.Evaluation = evaluation;
            this.Next = next;
        }


        public LoweredDagEvaluation Evaluation { get; }

        public LoweredDecisionDagNode  Next { get; }
        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitEvaluationDecisionDagNode(this);

        public LoweredEvaluationDecisionDagNode Update(LoweredDagEvaluation evaluation, LoweredDecisionDagNode  next)
        {
            if (evaluation != this.Evaluation || next != this.Next)
            {
                var result = new LoweredEvaluationDecisionDagNode(this.Syntax, evaluation, next, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal sealed partial class LoweredTestDecisionDagNode : LoweredDecisionDagNode 
    {
        public LoweredTestDecisionDagNode(SyntaxNode syntax, LoweredDagTest test, LoweredDecisionDagNode  whenTrue, LoweredDecisionDagNode  whenFalse, bool hasErrors = false)
            : base(LoweredKind.TestDecisionDagNode, syntax, hasErrors || test.HasErrors() || whenTrue.HasErrors() || whenFalse.HasErrors())
        {

            RoslynDebug.Assert(test is object, "Field 'test' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(whenTrue is object, "Field 'whenTrue' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(whenFalse is object, "Field 'whenFalse' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

            this.Test = test;
            this.WhenTrue = whenTrue;
            this.WhenFalse = whenFalse;
        }


        public LoweredDagTest Test { get; }

        public LoweredDecisionDagNode  WhenTrue { get; }

        public LoweredDecisionDagNode  WhenFalse { get; }
        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitTestDecisionDagNode(this);

        public LoweredTestDecisionDagNode Update(LoweredDagTest test, LoweredDecisionDagNode  whenTrue, LoweredDecisionDagNode  whenFalse)
        {
            if (test != this.Test || whenTrue != this.WhenTrue || whenFalse != this.WhenFalse)
            {
                var result = new LoweredTestDecisionDagNode(this.Syntax, test, whenTrue, whenFalse, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal sealed partial class LoweredWhenDecisionDagNode : LoweredDecisionDagNode 
    {
        public LoweredWhenDecisionDagNode(SyntaxNode syntax, ImmutableArray<LoweredPatternBinding> bindings, LoweredExpression? whenExpression, LoweredDecisionDagNode  whenTrue, LoweredDecisionDagNode ? whenFalse, bool hasErrors = false)
            : base(LoweredKind.WhenDecisionDagNode, syntax, hasErrors || whenExpression.HasErrors() || whenTrue.HasErrors() || whenFalse.HasErrors())
        {

            RoslynDebug.Assert(!bindings.IsDefault, "Field 'bindings' cannot be null (use Null=\"allow\" in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(whenTrue is object, "Field 'whenTrue' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

            this.Bindings = bindings;
            this.WhenExpression = whenExpression;
            this.WhenTrue = whenTrue;
            this.WhenFalse = whenFalse;
        }


        public ImmutableArray<LoweredPatternBinding> Bindings { get; }

        public LoweredExpression? WhenExpression { get; }

        public LoweredDecisionDagNode  WhenTrue { get; }

        public LoweredDecisionDagNode ? WhenFalse { get; }
        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitWhenDecisionDagNode(this);

        public LoweredWhenDecisionDagNode Update(ImmutableArray<LoweredPatternBinding> bindings, LoweredExpression? whenExpression, LoweredDecisionDagNode  whenTrue, LoweredDecisionDagNode ? whenFalse)
        {
            if (bindings != this.Bindings || whenExpression != this.WhenExpression || whenTrue != this.WhenTrue || whenFalse != this.WhenFalse)
            {
                var result = new LoweredWhenDecisionDagNode(this.Syntax, bindings, whenExpression, whenTrue, whenFalse, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal sealed partial class LoweredLeafDecisionDagNode : LoweredDecisionDagNode 
    {
        public LoweredLeafDecisionDagNode(SyntaxNode syntax, LabelSymbol label, bool hasErrors)
            : base(LoweredKind.LeafDecisionDagNode, syntax, hasErrors)
        {

            RoslynDebug.Assert(label is object, "Field 'label' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

            this.Label = label;
        }

        public LoweredLeafDecisionDagNode(SyntaxNode syntax, LabelSymbol label)
            : base(LoweredKind.LeafDecisionDagNode, syntax)
        {

            RoslynDebug.Assert(label is object, "Field 'label' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

            this.Label = label;
        }


        public LabelSymbol Label { get; }
        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitLeafDecisionDagNode(this);

        public LoweredLeafDecisionDagNode Update(LabelSymbol label)
        {
            if (!Symbols.SymbolEqualityComparer.ConsiderEverything.Equals(label, this.Label))
            {
                var result = new LoweredLeafDecisionDagNode(this.Syntax, label, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal abstract partial class LoweredDagTest : LoweredNode
    {
        protected LoweredDagTest(LoweredKind kind, SyntaxNode syntax, LoweredDagTemp input, bool hasErrors = false)
            : base(kind, syntax, hasErrors)
        {

            RoslynDebug.Assert(input is object, "Field 'input' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

            this.Input = input;
        }


        public LoweredDagTemp Input { get; }
    }

    internal sealed partial class LoweredDagTemp : LoweredNode
    {
        public LoweredDagTemp(SyntaxNode syntax, TypeSymbol type, LoweredDagEvaluation? source, int index, bool hasErrors = false)
            : base(LoweredKind.DagTemp, syntax, hasErrors || source.HasErrors())
        {

            RoslynDebug.Assert(type is object, "Field 'type' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

            this.Type = type;
            this.Source = source;
            this.Index = index;
        }


        public TypeSymbol Type { get; }

        public LoweredDagEvaluation? Source { get; }

        public int Index { get; }
        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitDagTemp(this);

        public LoweredDagTemp Update(TypeSymbol type, LoweredDagEvaluation? source, int index)
        {
            if (!TypeSymbol.Equals(type, this.Type, TypeCompareKind.ConsiderEverything) || source != this.Source || index != this.Index)
            {
                var result = new LoweredDagTemp(this.Syntax, type, source, index, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal sealed partial class LoweredDagTypeTest : LoweredDagTest
    {
        public LoweredDagTypeTest(SyntaxNode syntax, TypeSymbol type, LoweredDagTemp input, bool hasErrors = false)
            : base(LoweredKind.DagTypeTest, syntax, input, hasErrors || input.HasErrors())
        {

            RoslynDebug.Assert(type is object, "Field 'type' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(input is object, "Field 'input' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

            this.Type = type;
        }


        public TypeSymbol Type { get; }
        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitDagTypeTest(this);

        public LoweredDagTypeTest Update(TypeSymbol type, LoweredDagTemp input)
        {
            if (!TypeSymbol.Equals(type, this.Type, TypeCompareKind.ConsiderEverything) || input != this.Input)
            {
                var result = new LoweredDagTypeTest(this.Syntax, type, input, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal sealed partial class LoweredDagNonNullTest : LoweredDagTest
    {
        public LoweredDagNonNullTest(SyntaxNode syntax, bool isExplicitTest, LoweredDagTemp input, bool hasErrors = false)
            : base(LoweredKind.DagNonNullTest, syntax, input, hasErrors || input.HasErrors())
        {

            RoslynDebug.Assert(input is object, "Field 'input' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

            this.IsExplicitTest = isExplicitTest;
        }


        public bool IsExplicitTest { get; }
        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitDagNonNullTest(this);

        public LoweredDagNonNullTest Update(bool isExplicitTest, LoweredDagTemp input)
        {
            if (isExplicitTest != this.IsExplicitTest || input != this.Input)
            {
                var result = new LoweredDagNonNullTest(this.Syntax, isExplicitTest, input, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal sealed partial class LoweredDagExplicitNullTest : LoweredDagTest
    {
        public LoweredDagExplicitNullTest(SyntaxNode syntax, LoweredDagTemp input, bool hasErrors = false)
            : base(LoweredKind.DagExplicitNullTest, syntax, input, hasErrors || input.HasErrors())
        {

            RoslynDebug.Assert(input is object, "Field 'input' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

        }

        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitDagExplicitNullTest(this);

        public LoweredDagExplicitNullTest Update(LoweredDagTemp input)
        {
            if (input != this.Input)
            {
                var result = new LoweredDagExplicitNullTest(this.Syntax, input, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal sealed partial class LoweredDagValueTest : LoweredDagTest
    {
        public LoweredDagValueTest(SyntaxNode syntax, ConstantValue value, LoweredDagTemp input, bool hasErrors = false)
            : base(LoweredKind.DagValueTest, syntax, input, hasErrors || input.HasErrors())
        {

            RoslynDebug.Assert(value is object, "Field 'value' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(input is object, "Field 'input' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

            this.Value = value;
        }


        public ConstantValue Value { get; }
        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitDagValueTest(this);

        public LoweredDagValueTest Update(ConstantValue value, LoweredDagTemp input)
        {
            if (value != this.Value || input != this.Input)
            {
                var result = new LoweredDagValueTest(this.Syntax, value, input, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal abstract partial class LoweredDagEvaluation : LoweredDagTest
    {
        protected LoweredDagEvaluation(LoweredKind kind, SyntaxNode syntax, LoweredDagTemp input, bool hasErrors = false)
            : base(kind, syntax, input, hasErrors)
        {

            RoslynDebug.Assert(input is object, "Field 'input' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

        }

    }

    internal sealed partial class LoweredDagDeconstructEvaluation : LoweredDagEvaluation
    {
        public LoweredDagDeconstructEvaluation(SyntaxNode syntax, MethodSymbol deconstructMethod, LoweredDagTemp input, bool hasErrors = false)
            : base(LoweredKind.DagDeconstructEvaluation, syntax, input, hasErrors || input.HasErrors())
        {

            RoslynDebug.Assert(deconstructMethod is object, "Field 'deconstructMethod' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(input is object, "Field 'input' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

            this.DeconstructMethod = deconstructMethod;
        }


        public MethodSymbol DeconstructMethod { get; }
        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitDagDeconstructEvaluation(this);

        public LoweredDagDeconstructEvaluation Update(MethodSymbol deconstructMethod, LoweredDagTemp input)
        {
            if (!Symbols.SymbolEqualityComparer.ConsiderEverything.Equals(deconstructMethod, this.DeconstructMethod) || input != this.Input)
            {
                var result = new LoweredDagDeconstructEvaluation(this.Syntax, deconstructMethod, input, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal sealed partial class LoweredDagTypeEvaluation : LoweredDagEvaluation
    {
        public LoweredDagTypeEvaluation(SyntaxNode syntax, TypeSymbol type, LoweredDagTemp input, bool hasErrors = false)
            : base(LoweredKind.DagTypeEvaluation, syntax, input, hasErrors || input.HasErrors())
        {

            RoslynDebug.Assert(type is object, "Field 'type' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(input is object, "Field 'input' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

            this.Type = type;
        }


        public TypeSymbol Type { get; }
        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitDagTypeEvaluation(this);

        public LoweredDagTypeEvaluation Update(TypeSymbol type, LoweredDagTemp input)
        {
            if (!TypeSymbol.Equals(type, this.Type, TypeCompareKind.ConsiderEverything) || input != this.Input)
            {
                var result = new LoweredDagTypeEvaluation(this.Syntax, type, input, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal sealed partial class LoweredDagFieldEvaluation : LoweredDagEvaluation
    {
        public LoweredDagFieldEvaluation(SyntaxNode syntax, FieldSymbol field, LoweredDagTemp input, bool hasErrors = false)
            : base(LoweredKind.DagFieldEvaluation, syntax, input, hasErrors || input.HasErrors())
        {

            RoslynDebug.Assert(field is object, "Field 'field' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(input is object, "Field 'input' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

            this.Field = field;
        }


        public FieldSymbol Field { get; }
        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitDagFieldEvaluation(this);

        public LoweredDagFieldEvaluation Update(FieldSymbol field, LoweredDagTemp input)
        {
            if (!Symbols.SymbolEqualityComparer.ConsiderEverything.Equals(field, this.Field) || input != this.Input)
            {
                var result = new LoweredDagFieldEvaluation(this.Syntax, field, input, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal sealed partial class LoweredDagPropertyEvaluation : LoweredDagEvaluation
    {
        public LoweredDagPropertyEvaluation(SyntaxNode syntax, PropertySymbol property, LoweredDagTemp input, bool hasErrors = false)
            : base(LoweredKind.DagPropertyEvaluation, syntax, input, hasErrors || input.HasErrors())
        {

            RoslynDebug.Assert(property is object, "Field 'property' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(input is object, "Field 'input' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

            this.Property = property;
        }


        public PropertySymbol Property { get; }
        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitDagPropertyEvaluation(this);

        public LoweredDagPropertyEvaluation Update(PropertySymbol property, LoweredDagTemp input)
        {
            if (!Symbols.SymbolEqualityComparer.ConsiderEverything.Equals(property, this.Property) || input != this.Input)
            {
                var result = new LoweredDagPropertyEvaluation(this.Syntax, property, input, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal sealed partial class LoweredDagIndexEvaluation : LoweredDagEvaluation
    {
        public LoweredDagIndexEvaluation(SyntaxNode syntax, PropertySymbol property, int index, LoweredDagTemp input, bool hasErrors = false)
            : base(LoweredKind.DagIndexEvaluation, syntax, input, hasErrors || input.HasErrors())
        {

            RoslynDebug.Assert(property is object, "Field 'property' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(input is object, "Field 'input' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

            this.Property = property;
            this.Index = index;
        }


        public PropertySymbol Property { get; }

        public int Index { get; }
        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitDagIndexEvaluation(this);

        public LoweredDagIndexEvaluation Update(PropertySymbol property, int index, LoweredDagTemp input)
        {
            if (!Symbols.SymbolEqualityComparer.ConsiderEverything.Equals(property, this.Property) || index != this.Index || input != this.Input)
            {
                var result = new LoweredDagIndexEvaluation(this.Syntax, property, index, input, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal sealed partial class LoweredSwitchSection : LoweredStatementList
    {
        public LoweredSwitchSection(SyntaxNode syntax, ImmutableArray<LocalSymbol> locals, ImmutableArray<LoweredSwitchLabel> switchLabels, ImmutableArray<LoweredStatement> statements, bool hasErrors = false)
            : base(LoweredKind.SwitchSection, syntax, statements, hasErrors || switchLabels.HasErrors() || statements.HasErrors())
        {

            RoslynDebug.Assert(!locals.IsDefault, "Field 'locals' cannot be null (use Null=\"allow\" in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(!switchLabels.IsDefault, "Field 'switchLabels' cannot be null (use Null=\"allow\" in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(!statements.IsDefault, "Field 'statements' cannot be null (use Null=\"allow\" in LoweredNodes.xml to remove this check)");

            this.Locals = locals;
            this.SwitchLabels = switchLabels;
        }


        public ImmutableArray<LocalSymbol> Locals { get; }

        public ImmutableArray<LoweredSwitchLabel> SwitchLabels { get; }
        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitSwitchSection(this);

        public LoweredSwitchSection Update(ImmutableArray<LocalSymbol> locals, ImmutableArray<LoweredSwitchLabel> switchLabels, ImmutableArray<LoweredStatement> statements)
        {
            if (locals != this.Locals || switchLabels != this.SwitchLabels || statements != this.Statements)
            {
                var result = new LoweredSwitchSection(this.Syntax, locals, switchLabels, statements, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal sealed partial class LoweredSwitchLabel : LoweredNode
    {
        public LoweredSwitchLabel(SyntaxNode syntax, LabelSymbol label, LoweredPattern pattern, LoweredExpression? whenClause, bool hasErrors = false)
            : base(LoweredKind.SwitchLabel, syntax, hasErrors || pattern.HasErrors() || whenClause.HasErrors())
        {

            RoslynDebug.Assert(label is object, "Field 'label' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(pattern is object, "Field 'pattern' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

            this.Label = label;
            this.Pattern = pattern;
            this.WhenClause = whenClause;
        }


        public LabelSymbol Label { get; }

        public LoweredPattern Pattern { get; }

        public LoweredExpression? WhenClause { get; }
        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitSwitchLabel(this);

        public LoweredSwitchLabel Update(LabelSymbol label, LoweredPattern pattern, LoweredExpression? whenClause)
        {
            if (!Symbols.SymbolEqualityComparer.ConsiderEverything.Equals(label, this.Label) || pattern != this.Pattern || whenClause != this.WhenClause)
            {
                var result = new LoweredSwitchLabel(this.Syntax, label, pattern, whenClause, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal abstract partial class LoweredMethodOrPropertyGroup : LoweredExpression
    {
        protected LoweredMethodOrPropertyGroup(LoweredKind kind, SyntaxNode syntax, LoweredExpression? receiverOpt, LookupResultKind resultKind, bool hasErrors = false)
            : base(kind, syntax, null, hasErrors)
        {
            this.ReceiverOpt = receiverOpt;
            this._ResultKind = resultKind;
        }


        public new TypeSymbol Type => base.Type!;

        public LoweredExpression? ReceiverOpt { get; }

        private readonly LookupResultKind _ResultKind;
        public override LookupResultKind ResultKind { get { return _ResultKind;} }
    }

    internal sealed partial class LoweredSequencePointExpression : LoweredExpression
    {
        public LoweredSequencePointExpression(SyntaxNode syntax, LoweredExpression expression, TypeSymbol? type, bool hasErrors = false)
            : base(LoweredKind.SequencePointExpression, syntax, type, hasErrors || expression.HasErrors())
        {

            RoslynDebug.Assert(expression is object, "Field 'expression' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

            this.Expression = expression;
        }


        public LoweredExpression Expression { get; }
        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitSequencePointExpression(this);

        public LoweredSequencePointExpression Update(LoweredExpression expression, TypeSymbol? type)
        {
            if (expression != this.Expression || !TypeSymbol.Equals(type, this.Type, TypeCompareKind.ConsiderEverything))
            {
                var result = new LoweredSequencePointExpression(this.Syntax, expression, type, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal sealed partial class LoweredSequence : LoweredExpression
    {
        public LoweredSequence(SyntaxNode syntax, ImmutableArray<LocalSymbol> locals, ImmutableArray<LoweredExpression> sideEffects, LoweredExpression value, TypeSymbol type, bool hasErrors = false)
            : base(LoweredKind.Sequence, syntax, type, hasErrors || sideEffects.HasErrors() || value.HasErrors())
        {

            RoslynDebug.Assert(!locals.IsDefault, "Field 'locals' cannot be null (use Null=\"allow\" in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(!sideEffects.IsDefault, "Field 'sideEffects' cannot be null (use Null=\"allow\" in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(value is object, "Field 'value' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(type is object, "Field 'type' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

            this.Locals = locals;
            this.SideEffects = sideEffects;
            this.Value = value;
        }


        public new TypeSymbol Type => base.Type!;

        public ImmutableArray<LocalSymbol> Locals { get; }

        public ImmutableArray<LoweredExpression> SideEffects { get; }

        public LoweredExpression Value { get; }
        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitSequence(this);

        public LoweredSequence Update(ImmutableArray<LocalSymbol> locals, ImmutableArray<LoweredExpression> sideEffects, LoweredExpression value, TypeSymbol type)
        {
            if (locals != this.Locals || sideEffects != this.SideEffects || value != this.Value || !TypeSymbol.Equals(type, this.Type, TypeCompareKind.ConsiderEverything))
            {
                var result = new LoweredSequence(this.Syntax, locals, sideEffects, value, type, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal sealed partial class LoweredSpillSequence : LoweredExpression
    {
        public LoweredSpillSequence(SyntaxNode syntax, ImmutableArray<LocalSymbol> locals, ImmutableArray<LoweredStatement> sideEffects, LoweredExpression value, TypeSymbol type, bool hasErrors = false)
            : base(LoweredKind.SpillSequence, syntax, type, hasErrors || sideEffects.HasErrors() || value.HasErrors())
        {

            RoslynDebug.Assert(!locals.IsDefault, "Field 'locals' cannot be null (use Null=\"allow\" in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(!sideEffects.IsDefault, "Field 'sideEffects' cannot be null (use Null=\"allow\" in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(value is object, "Field 'value' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(type is object, "Field 'type' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

            this.Locals = locals;
            this.SideEffects = sideEffects;
            this.Value = value;
        }


        public new TypeSymbol Type => base.Type!;

        public ImmutableArray<LocalSymbol> Locals { get; }

        public ImmutableArray<LoweredStatement> SideEffects { get; }

        public LoweredExpression Value { get; }
        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitSpillSequence(this);

        public LoweredSpillSequence Update(ImmutableArray<LocalSymbol> locals, ImmutableArray<LoweredStatement> sideEffects, LoweredExpression value, TypeSymbol type)
        {
            if (locals != this.Locals || sideEffects != this.SideEffects || value != this.Value || !TypeSymbol.Equals(type, this.Type, TypeCompareKind.ConsiderEverything))
            {
                var result = new LoweredSpillSequence(this.Syntax, locals, sideEffects, value, type, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal sealed partial class LoweredDynamicMemberAccess : LoweredExpression
    {
        public LoweredDynamicMemberAccess(SyntaxNode syntax, LoweredExpression receiver, ImmutableArray<TypeWithAnnotations> typeArgumentsOpt, string name, bool invoked, bool indexed, TypeSymbol type, bool hasErrors = false)
            : base(LoweredKind.DynamicMemberAccess, syntax, type, hasErrors || receiver.HasErrors())
        {

            RoslynDebug.Assert(receiver is object, "Field 'receiver' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(name is object, "Field 'name' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(type is object, "Field 'type' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

            this.Receiver = receiver;
            this.TypeArgumentsOpt = typeArgumentsOpt;
            this.Name = name;
            this.Invoked = invoked;
            this.Indexed = indexed;
        }


        public new TypeSymbol Type => base.Type!;

        public LoweredExpression Receiver { get; }

        public ImmutableArray<TypeWithAnnotations> TypeArgumentsOpt { get; }

        public string Name { get; }

        public bool Invoked { get; }

        public bool Indexed { get; }
        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitDynamicMemberAccess(this);

        public LoweredDynamicMemberAccess Update(LoweredExpression receiver, ImmutableArray<TypeWithAnnotations> typeArgumentsOpt, string name, bool invoked, bool indexed, TypeSymbol type)
        {
            if (receiver != this.Receiver || typeArgumentsOpt != this.TypeArgumentsOpt || name != this.Name || invoked != this.Invoked || indexed != this.Indexed || !TypeSymbol.Equals(type, this.Type, TypeCompareKind.ConsiderEverything))
            {
                var result = new LoweredDynamicMemberAccess(this.Syntax, receiver, typeArgumentsOpt, name, invoked, indexed, type, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal abstract partial class LoweredDynamicInvocableBase : LoweredExpression
    {
        protected LoweredDynamicInvocableBase(LoweredKind kind, SyntaxNode syntax, LoweredExpression expression, ImmutableArray<LoweredExpression> arguments, TypeSymbol? type, bool hasErrors = false)
            : base(kind, syntax, type, hasErrors)
        {

            RoslynDebug.Assert(expression is object, "Field 'expression' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(!arguments.IsDefault, "Field 'arguments' cannot be null (use Null=\"allow\" in LoweredNodes.xml to remove this check)");

            this.Expression = expression;
            this.Arguments = arguments;
        }


        public LoweredExpression Expression { get; }

        public ImmutableArray<LoweredExpression> Arguments { get; }
    }

    internal sealed partial class LoweredDynamicInvocation : LoweredDynamicInvocableBase
    {
        public LoweredDynamicInvocation(SyntaxNode syntax, ImmutableArray<string> argumentNamesOpt, ImmutableArray<RefKind> argumentRefKindsOpt, ImmutableArray<MethodSymbol> applicableMethods, LoweredExpression expression, ImmutableArray<LoweredExpression> arguments, TypeSymbol type, bool hasErrors = false)
            : base(LoweredKind.DynamicInvocation, syntax, expression, arguments, type, hasErrors || expression.HasErrors() || arguments.HasErrors())
        {

            RoslynDebug.Assert(!applicableMethods.IsDefault, "Field 'applicableMethods' cannot be null (use Null=\"allow\" in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(expression is object, "Field 'expression' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(!arguments.IsDefault, "Field 'arguments' cannot be null (use Null=\"allow\" in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(type is object, "Field 'type' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

            this.ArgumentNamesOpt = argumentNamesOpt;
            this.ArgumentRefKindsOpt = argumentRefKindsOpt;
            this.ApplicableMethods = applicableMethods;
        }


        public new TypeSymbol Type => base.Type!;

        public ImmutableArray<string> ArgumentNamesOpt { get; }

        public ImmutableArray<RefKind> ArgumentRefKindsOpt { get; }

        public ImmutableArray<MethodSymbol> ApplicableMethods { get; }
        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitDynamicInvocation(this);

        public LoweredDynamicInvocation Update(ImmutableArray<string> argumentNamesOpt, ImmutableArray<RefKind> argumentRefKindsOpt, ImmutableArray<MethodSymbol> applicableMethods, LoweredExpression expression, ImmutableArray<LoweredExpression> arguments, TypeSymbol type)
        {
            if (argumentNamesOpt != this.ArgumentNamesOpt || argumentRefKindsOpt != this.ArgumentRefKindsOpt || applicableMethods != this.ApplicableMethods || expression != this.Expression || arguments != this.Arguments || !TypeSymbol.Equals(type, this.Type, TypeCompareKind.ConsiderEverything))
            {
                var result = new LoweredDynamicInvocation(this.Syntax, argumentNamesOpt, argumentRefKindsOpt, applicableMethods, expression, arguments, type, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal sealed partial class LoweredConditionalAccess : LoweredExpression
    {
        public LoweredConditionalAccess(SyntaxNode syntax, LoweredExpression receiver, LoweredExpression accessExpression, TypeSymbol type, bool hasErrors = false)
            : base(LoweredKind.ConditionalAccess, syntax, type, hasErrors || receiver.HasErrors() || accessExpression.HasErrors())
        {

            RoslynDebug.Assert(receiver is object, "Field 'receiver' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(accessExpression is object, "Field 'accessExpression' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(type is object, "Field 'type' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

            this.Receiver = receiver;
            this.AccessExpression = accessExpression;
        }


        public new TypeSymbol Type => base.Type!;

        public LoweredExpression Receiver { get; }

        public LoweredExpression AccessExpression { get; }
        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitConditionalAccess(this);

        public LoweredConditionalAccess Update(LoweredExpression receiver, LoweredExpression accessExpression, TypeSymbol type)
        {
            if (receiver != this.Receiver || accessExpression != this.AccessExpression || !TypeSymbol.Equals(type, this.Type, TypeCompareKind.ConsiderEverything))
            {
                var result = new LoweredConditionalAccess(this.Syntax, receiver, accessExpression, type, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal sealed partial class LoweredLoweredConditionalAccess : LoweredExpression
    {
        public LoweredLoweredConditionalAccess(SyntaxNode syntax, LoweredExpression receiver, MethodSymbol? hasValueMethodOpt, LoweredExpression whenNotNull, LoweredExpression? whenNullOpt, int id, TypeSymbol type, bool hasErrors = false)
            : base(LoweredKind.LoweredConditionalAccess, syntax, type, hasErrors || receiver.HasErrors() || whenNotNull.HasErrors() || whenNullOpt.HasErrors())
        {

            RoslynDebug.Assert(receiver is object, "Field 'receiver' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(whenNotNull is object, "Field 'whenNotNull' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(type is object, "Field 'type' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

            this.Receiver = receiver;
            this.HasValueMethodOpt = hasValueMethodOpt;
            this.WhenNotNull = whenNotNull;
            this.WhenNullOpt = whenNullOpt;
            this.Id = id;
        }


        public new TypeSymbol Type => base.Type!;

        public LoweredExpression Receiver { get; }

        public MethodSymbol? HasValueMethodOpt { get; }

        public LoweredExpression WhenNotNull { get; }

        public LoweredExpression? WhenNullOpt { get; }

        public int Id { get; }
        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitLoweredConditionalAccess(this);

        public LoweredLoweredConditionalAccess Update(LoweredExpression receiver, MethodSymbol? hasValueMethodOpt, LoweredExpression whenNotNull, LoweredExpression? whenNullOpt, int id, TypeSymbol type)
        {
            if (receiver != this.Receiver || !Symbols.SymbolEqualityComparer.ConsiderEverything.Equals(hasValueMethodOpt, this.HasValueMethodOpt) || whenNotNull != this.WhenNotNull || whenNullOpt != this.WhenNullOpt || id != this.Id || !TypeSymbol.Equals(type, this.Type, TypeCompareKind.ConsiderEverything))
            {
                var result = new LoweredLoweredConditionalAccess(this.Syntax, receiver, hasValueMethodOpt, whenNotNull, whenNullOpt, id, type, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal sealed partial class LoweredConditionalReceiver : LoweredExpression
    {
        public LoweredConditionalReceiver(SyntaxNode syntax, int id, TypeSymbol type, bool hasErrors)
            : base(LoweredKind.ConditionalReceiver, syntax, type, hasErrors)
        {

            RoslynDebug.Assert(type is object, "Field 'type' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

            this.Id = id;
        }

        public LoweredConditionalReceiver(SyntaxNode syntax, int id, TypeSymbol type)
            : base(LoweredKind.ConditionalReceiver, syntax, type)
        {

            RoslynDebug.Assert(type is object, "Field 'type' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

            this.Id = id;
        }


        public new TypeSymbol Type => base.Type!;

        public int Id { get; }
        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitConditionalReceiver(this);

        public LoweredConditionalReceiver Update(int id, TypeSymbol type)
        {
            if (id != this.Id || !TypeSymbol.Equals(type, this.Type, TypeCompareKind.ConsiderEverything))
            {
                var result = new LoweredConditionalReceiver(this.Syntax, id, type, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal sealed partial class LoweredComplexConditionalReceiver : LoweredExpression
    {
        public LoweredComplexConditionalReceiver(SyntaxNode syntax, LoweredExpression valueTypeReceiver, LoweredExpression referenceTypeReceiver, TypeSymbol type, bool hasErrors = false)
            : base(LoweredKind.ComplexConditionalReceiver, syntax, type, hasErrors || valueTypeReceiver.HasErrors() || referenceTypeReceiver.HasErrors())
        {

            RoslynDebug.Assert(valueTypeReceiver is object, "Field 'valueTypeReceiver' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(referenceTypeReceiver is object, "Field 'referenceTypeReceiver' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(type is object, "Field 'type' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

            this.ValueTypeReceiver = valueTypeReceiver;
            this.ReferenceTypeReceiver = referenceTypeReceiver;
        }


        public new TypeSymbol Type => base.Type!;

        public LoweredExpression ValueTypeReceiver { get; }

        public LoweredExpression ReferenceTypeReceiver { get; }
        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitComplexConditionalReceiver(this);

        public LoweredComplexConditionalReceiver Update(LoweredExpression valueTypeReceiver, LoweredExpression referenceTypeReceiver, TypeSymbol type)
        {
            if (valueTypeReceiver != this.ValueTypeReceiver || referenceTypeReceiver != this.ReferenceTypeReceiver || !TypeSymbol.Equals(type, this.Type, TypeCompareKind.ConsiderEverything))
            {
                var result = new LoweredComplexConditionalReceiver(this.Syntax, valueTypeReceiver, referenceTypeReceiver, type, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal sealed partial class LoweredMethodGroup : LoweredMethodOrPropertyGroup
    {
        public LoweredMethodGroup(SyntaxNode syntax, ImmutableArray<TypeWithAnnotations> typeArgumentsOpt, string name, ImmutableArray<MethodSymbol> methods, Symbol? lookupSymbolOpt, DiagnosticInfo? lookupError, LoweredMethodGroupFlags? flags, LoweredExpression? receiverOpt, LookupResultKind resultKind, bool hasErrors = false)
            : base(LoweredKind.MethodGroup, syntax, receiverOpt, resultKind, hasErrors || receiverOpt.HasErrors())
        {

            RoslynDebug.Assert(name is object, "Field 'name' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(!methods.IsDefault, "Field 'methods' cannot be null (use Null=\"allow\" in LoweredNodes.xml to remove this check)");

            this.TypeArgumentsOpt = typeArgumentsOpt;
            this.Name = name;
            this.Methods = methods;
            this.LookupSymbolOpt = lookupSymbolOpt;
            this.LookupError = lookupError;
            this.Flags = flags;
        }


        public ImmutableArray<TypeWithAnnotations> TypeArgumentsOpt { get; }

        public string Name { get; }

        public ImmutableArray<MethodSymbol> Methods { get; }

        public Symbol? LookupSymbolOpt { get; }

        public DiagnosticInfo? LookupError { get; }

        public LoweredMethodGroupFlags? Flags { get; }
        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitMethodGroup(this);

        public LoweredMethodGroup Update(ImmutableArray<TypeWithAnnotations> typeArgumentsOpt, string name, ImmutableArray<MethodSymbol> methods, Symbol? lookupSymbolOpt, DiagnosticInfo? lookupError, LoweredMethodGroupFlags? flags, LoweredExpression? receiverOpt, LookupResultKind resultKind)
        {
            if (typeArgumentsOpt != this.TypeArgumentsOpt || name != this.Name || methods != this.Methods || !Symbols.SymbolEqualityComparer.ConsiderEverything.Equals(lookupSymbolOpt, this.LookupSymbolOpt) || lookupError != this.LookupError || flags != this.Flags || receiverOpt != this.ReceiverOpt || resultKind != this.ResultKind)
            {
                var result = new LoweredMethodGroup(this.Syntax, typeArgumentsOpt, name, methods, lookupSymbolOpt, lookupError, flags, receiverOpt, resultKind, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal sealed partial class LoweredPropertyGroup : LoweredMethodOrPropertyGroup
    {
        public LoweredPropertyGroup(SyntaxNode syntax, ImmutableArray<PropertySymbol> properties, LoweredExpression? receiverOpt, LookupResultKind resultKind, bool hasErrors = false)
            : base(LoweredKind.PropertyGroup, syntax, receiverOpt, resultKind, hasErrors || receiverOpt.HasErrors())
        {

            RoslynDebug.Assert(!properties.IsDefault, "Field 'properties' cannot be null (use Null=\"allow\" in LoweredNodes.xml to remove this check)");

            this.Properties = properties;
        }


        public ImmutableArray<PropertySymbol> Properties { get; }
        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitPropertyGroup(this);

        public LoweredPropertyGroup Update(ImmutableArray<PropertySymbol> properties, LoweredExpression? receiverOpt, LookupResultKind resultKind)
        {
            if (properties != this.Properties || receiverOpt != this.ReceiverOpt || resultKind != this.ResultKind)
            {
                var result = new LoweredPropertyGroup(this.Syntax, properties, receiverOpt, resultKind, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal sealed partial class LoweredCall : LoweredExpression
    {
        public LoweredCall(SyntaxNode syntax, LoweredExpression? receiverOpt, MethodSymbol method, ImmutableArray<LoweredExpression> arguments, ImmutableArray<string> argumentNamesOpt, ImmutableArray<RefKind> argumentRefKindsOpt, bool isDelegateCall, bool expanded, bool invokedAsExtensionMethod, ImmutableArray<int> argsToParamsOpt, LookupResultKind resultKind, ImmutableArray<MethodSymbol> originalMethodsOpt, Binder? binderOpt, TypeSymbol type, bool hasErrors = false)
            : base(LoweredKind.Call, syntax, type, hasErrors || receiverOpt.HasErrors() || arguments.HasErrors())
        {

            RoslynDebug.Assert(method is object, "Field 'method' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(!arguments.IsDefault, "Field 'arguments' cannot be null (use Null=\"allow\" in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(type is object, "Field 'type' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

            this.ReceiverOpt = receiverOpt;
            this.Method = method;
            this.Arguments = arguments;
            this.ArgumentNamesOpt = argumentNamesOpt;
            this.ArgumentRefKindsOpt = argumentRefKindsOpt;
            this.IsDelegateCall = isDelegateCall;
            this.Expanded = expanded;
            this.InvokedAsExtensionMethod = invokedAsExtensionMethod;
            this.ArgsToParamsOpt = argsToParamsOpt;
            this._ResultKind = resultKind;
            this.OriginalMethodsOpt = originalMethodsOpt;
            this.BinderOpt = binderOpt;
        }


        public new TypeSymbol Type => base.Type!;

        public LoweredExpression? ReceiverOpt { get; }

        public MethodSymbol Method { get; }

        public ImmutableArray<LoweredExpression> Arguments { get; }

        public ImmutableArray<string> ArgumentNamesOpt { get; }

        public ImmutableArray<RefKind> ArgumentRefKindsOpt { get; }

        public bool IsDelegateCall { get; }

        public bool Expanded { get; }

        public bool InvokedAsExtensionMethod { get; }

        public ImmutableArray<int> ArgsToParamsOpt { get; }

        private readonly LookupResultKind _ResultKind;
        public override LookupResultKind ResultKind { get { return _ResultKind;} }

        public ImmutableArray<MethodSymbol> OriginalMethodsOpt { get; }

        public Binder? BinderOpt { get; }
        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitCall(this);

        public LoweredCall Update(LoweredExpression? receiverOpt, MethodSymbol method, ImmutableArray<LoweredExpression> arguments, ImmutableArray<string> argumentNamesOpt, ImmutableArray<RefKind> argumentRefKindsOpt, bool isDelegateCall, bool expanded, bool invokedAsExtensionMethod, ImmutableArray<int> argsToParamsOpt, LookupResultKind resultKind, ImmutableArray<MethodSymbol> originalMethodsOpt, Binder? binderOpt, TypeSymbol type)
        {
            if (receiverOpt != this.ReceiverOpt || !Symbols.SymbolEqualityComparer.ConsiderEverything.Equals(method, this.Method) || arguments != this.Arguments || argumentNamesOpt != this.ArgumentNamesOpt || argumentRefKindsOpt != this.ArgumentRefKindsOpt || isDelegateCall != this.IsDelegateCall || expanded != this.Expanded || invokedAsExtensionMethod != this.InvokedAsExtensionMethod || argsToParamsOpt != this.ArgsToParamsOpt || resultKind != this.ResultKind || originalMethodsOpt != this.OriginalMethodsOpt || binderOpt != this.BinderOpt || !TypeSymbol.Equals(type, this.Type, TypeCompareKind.ConsiderEverything))
            {
                var result = new LoweredCall(this.Syntax, receiverOpt, method, arguments, argumentNamesOpt, argumentRefKindsOpt, isDelegateCall, expanded, invokedAsExtensionMethod, argsToParamsOpt, resultKind, originalMethodsOpt, binderOpt, type, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal sealed partial class LoweredEventAssignmentOperator : LoweredExpression
    {
        public LoweredEventAssignmentOperator(SyntaxNode syntax, EventSymbol @event, bool isAddition, bool isDynamic, LoweredExpression? receiverOpt, LoweredExpression argument, TypeSymbol type, bool hasErrors = false)
            : base(LoweredKind.EventAssignmentOperator, syntax, type, hasErrors || receiverOpt.HasErrors() || argument.HasErrors())
        {

            RoslynDebug.Assert(@event is object, "Field '@event' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(argument is object, "Field 'argument' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(type is object, "Field 'type' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

            this.Event = @event;
            this.IsAddition = isAddition;
            this.IsDynamic = isDynamic;
            this.ReceiverOpt = receiverOpt;
            this.Argument = argument;
        }


        public new TypeSymbol Type => base.Type!;

        public EventSymbol Event { get; }

        public bool IsAddition { get; }

        public bool IsDynamic { get; }

        public LoweredExpression? ReceiverOpt { get; }

        public LoweredExpression Argument { get; }
        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitEventAssignmentOperator(this);

        public LoweredEventAssignmentOperator Update(EventSymbol @event, bool isAddition, bool isDynamic, LoweredExpression? receiverOpt, LoweredExpression argument, TypeSymbol type)
        {
            if (!Symbols.SymbolEqualityComparer.ConsiderEverything.Equals(@event, this.Event) || isAddition != this.IsAddition || isDynamic != this.IsDynamic || receiverOpt != this.ReceiverOpt || argument != this.Argument || !TypeSymbol.Equals(type, this.Type, TypeCompareKind.ConsiderEverything))
            {
                var result = new LoweredEventAssignmentOperator(this.Syntax, @event, isAddition, isDynamic, receiverOpt, argument, type, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal sealed partial class LoweredAttribute : LoweredExpression
    {
        public LoweredAttribute(SyntaxNode syntax, MethodSymbol? constructor, ImmutableArray<LoweredExpression> constructorArguments, ImmutableArray<string> constructorArgumentNamesOpt, ImmutableArray<int> constructorArgumentsToParamsOpt, bool constructorExpanded, ImmutableArray<LoweredExpression> namedArguments, LookupResultKind resultKind, TypeSymbol type, bool hasErrors = false)
            : base(LoweredKind.Attribute, syntax, type, hasErrors || constructorArguments.HasErrors() || namedArguments.HasErrors())
        {

            RoslynDebug.Assert(!constructorArguments.IsDefault, "Field 'constructorArguments' cannot be null (use Null=\"allow\" in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(!namedArguments.IsDefault, "Field 'namedArguments' cannot be null (use Null=\"allow\" in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(type is object, "Field 'type' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

            this.Constructor = constructor;
            this.ConstructorArguments = constructorArguments;
            this.ConstructorArgumentNamesOpt = constructorArgumentNamesOpt;
            this.ConstructorArgumentsToParamsOpt = constructorArgumentsToParamsOpt;
            this.ConstructorExpanded = constructorExpanded;
            this.NamedArguments = namedArguments;
            this._ResultKind = resultKind;
        }


        public new TypeSymbol Type => base.Type!;

        public MethodSymbol? Constructor { get; }

        public ImmutableArray<LoweredExpression> ConstructorArguments { get; }

        public ImmutableArray<string> ConstructorArgumentNamesOpt { get; }

        public ImmutableArray<int> ConstructorArgumentsToParamsOpt { get; }

        public bool ConstructorExpanded { get; }

        public ImmutableArray<LoweredExpression> NamedArguments { get; }

        private readonly LookupResultKind _ResultKind;
        public override LookupResultKind ResultKind { get { return _ResultKind;} }
        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitAttribute(this);

        public LoweredAttribute Update(MethodSymbol? constructor, ImmutableArray<LoweredExpression> constructorArguments, ImmutableArray<string> constructorArgumentNamesOpt, ImmutableArray<int> constructorArgumentsToParamsOpt, bool constructorExpanded, ImmutableArray<LoweredExpression> namedArguments, LookupResultKind resultKind, TypeSymbol type)
        {
            if (!Symbols.SymbolEqualityComparer.ConsiderEverything.Equals(constructor, this.Constructor) || constructorArguments != this.ConstructorArguments || constructorArgumentNamesOpt != this.ConstructorArgumentNamesOpt || constructorArgumentsToParamsOpt != this.ConstructorArgumentsToParamsOpt || constructorExpanded != this.ConstructorExpanded || namedArguments != this.NamedArguments || resultKind != this.ResultKind || !TypeSymbol.Equals(type, this.Type, TypeCompareKind.ConsiderEverything))
            {
                var result = new LoweredAttribute(this.Syntax, constructor, constructorArguments, constructorArgumentNamesOpt, constructorArgumentsToParamsOpt, constructorExpanded, namedArguments, resultKind, type, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal sealed partial class LoweredObjectCreationExpression : LoweredExpression
    {
        public LoweredObjectCreationExpression(SyntaxNode syntax, MethodSymbol constructor, ImmutableArray<MethodSymbol> constructorsGroup, ImmutableArray<LoweredExpression> arguments, ImmutableArray<string> argumentNamesOpt, ImmutableArray<RefKind> argumentRefKindsOpt, bool expanded, ImmutableArray<int> argsToParamsOpt, ConstantValue? constantValueOpt, LoweredObjectInitializerExpressionBase? initializerExpressionOpt, Binder? binderOpt, TypeSymbol type, bool hasErrors = false)
            : base(LoweredKind.ObjectCreationExpression, syntax, type, hasErrors || arguments.HasErrors() || initializerExpressionOpt.HasErrors())
        {

            RoslynDebug.Assert(constructor is object, "Field 'constructor' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(!constructorsGroup.IsDefault, "Field 'constructorsGroup' cannot be null (use Null=\"allow\" in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(!arguments.IsDefault, "Field 'arguments' cannot be null (use Null=\"allow\" in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(type is object, "Field 'type' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

            this.Constructor = constructor;
            this.ConstructorsGroup = constructorsGroup;
            this.Arguments = arguments;
            this.ArgumentNamesOpt = argumentNamesOpt;
            this.ArgumentRefKindsOpt = argumentRefKindsOpt;
            this.Expanded = expanded;
            this.ArgsToParamsOpt = argsToParamsOpt;
            this.ConstantValueOpt = constantValueOpt;
            this.InitializerExpressionOpt = initializerExpressionOpt;
            this.BinderOpt = binderOpt;
        }


        public new TypeSymbol Type => base.Type!;

        public MethodSymbol Constructor { get; }

        public ImmutableArray<MethodSymbol> ConstructorsGroup { get; }

        public ImmutableArray<LoweredExpression> Arguments { get; }

        public ImmutableArray<string> ArgumentNamesOpt { get; }

        public ImmutableArray<RefKind> ArgumentRefKindsOpt { get; }

        public bool Expanded { get; }

        public ImmutableArray<int> ArgsToParamsOpt { get; }

        public ConstantValue? ConstantValueOpt { get; }

        public LoweredObjectInitializerExpressionBase? InitializerExpressionOpt { get; }

        public Binder? BinderOpt { get; }
        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitObjectCreationExpression(this);

        public LoweredObjectCreationExpression Update(MethodSymbol constructor, ImmutableArray<MethodSymbol> constructorsGroup, ImmutableArray<LoweredExpression> arguments, ImmutableArray<string> argumentNamesOpt, ImmutableArray<RefKind> argumentRefKindsOpt, bool expanded, ImmutableArray<int> argsToParamsOpt, ConstantValue? constantValueOpt, LoweredObjectInitializerExpressionBase? initializerExpressionOpt, Binder? binderOpt, TypeSymbol type)
        {
            if (!Symbols.SymbolEqualityComparer.ConsiderEverything.Equals(constructor, this.Constructor) || constructorsGroup != this.ConstructorsGroup || arguments != this.Arguments || argumentNamesOpt != this.ArgumentNamesOpt || argumentRefKindsOpt != this.ArgumentRefKindsOpt || expanded != this.Expanded || argsToParamsOpt != this.ArgsToParamsOpt || constantValueOpt != this.ConstantValueOpt || initializerExpressionOpt != this.InitializerExpressionOpt || binderOpt != this.BinderOpt || !TypeSymbol.Equals(type, this.Type, TypeCompareKind.ConsiderEverything))
            {
                var result = new LoweredObjectCreationExpression(this.Syntax, constructor, constructorsGroup, arguments, argumentNamesOpt, argumentRefKindsOpt, expanded, argsToParamsOpt, constantValueOpt, initializerExpressionOpt, binderOpt, type, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal abstract partial class LoweredTupleExpression : LoweredExpression
    {
        protected LoweredTupleExpression(LoweredKind kind, SyntaxNode syntax, ImmutableArray<LoweredExpression> arguments, ImmutableArray<string> argumentNamesOpt, ImmutableArray<bool> inferredNamesOpt, TypeSymbol? type, bool hasErrors = false)
            : base(kind, syntax, type, hasErrors)
        {

            RoslynDebug.Assert(!arguments.IsDefault, "Field 'arguments' cannot be null (use Null=\"allow\" in LoweredNodes.xml to remove this check)");

            this.Arguments = arguments;
            this.ArgumentNamesOpt = argumentNamesOpt;
            this.InferredNamesOpt = inferredNamesOpt;
        }


        public ImmutableArray<LoweredExpression> Arguments { get; }

        public ImmutableArray<string> ArgumentNamesOpt { get; }

        public ImmutableArray<bool> InferredNamesOpt { get; }
    }

    internal sealed partial class LoweredTupleLiteral : LoweredTupleExpression
    {
        public LoweredTupleLiteral(SyntaxNode syntax, ImmutableArray<LoweredExpression> arguments, ImmutableArray<string> argumentNamesOpt, ImmutableArray<bool> inferredNamesOpt, TypeSymbol? type, bool hasErrors = false)
            : base(LoweredKind.TupleLiteral, syntax, arguments, argumentNamesOpt, inferredNamesOpt, type, hasErrors || arguments.HasErrors())
        {

            RoslynDebug.Assert(!arguments.IsDefault, "Field 'arguments' cannot be null (use Null=\"allow\" in LoweredNodes.xml to remove this check)");

        }


        public new TypeSymbol? Type => base.Type!;
        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitTupleLiteral(this);

        public LoweredTupleLiteral Update(ImmutableArray<LoweredExpression> arguments, ImmutableArray<string> argumentNamesOpt, ImmutableArray<bool> inferredNamesOpt, TypeSymbol? type)
        {
            if (arguments != this.Arguments || argumentNamesOpt != this.ArgumentNamesOpt || inferredNamesOpt != this.InferredNamesOpt || !TypeSymbol.Equals(type, this.Type, TypeCompareKind.ConsiderEverything))
            {
                var result = new LoweredTupleLiteral(this.Syntax, arguments, argumentNamesOpt, inferredNamesOpt, type, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal sealed partial class LoweredConvertedTupleLiteral : LoweredTupleExpression
    {
        public LoweredConvertedTupleLiteral(SyntaxNode syntax, LoweredTupleLiteral? sourceTuple, bool wasTargetTyped, ImmutableArray<LoweredExpression> arguments, ImmutableArray<string> argumentNamesOpt, ImmutableArray<bool> inferredNamesOpt, TypeSymbol? type, bool hasErrors = false)
            : base(LoweredKind.ConvertedTupleLiteral, syntax, arguments, argumentNamesOpt, inferredNamesOpt, type, hasErrors || sourceTuple.HasErrors() || arguments.HasErrors())
        {

            RoslynDebug.Assert(!arguments.IsDefault, "Field 'arguments' cannot be null (use Null=\"allow\" in LoweredNodes.xml to remove this check)");

            this.SourceTuple = sourceTuple;
            this.WasTargetTyped = wasTargetTyped;
        }


        public LoweredTupleLiteral? SourceTuple { get; }

        public bool WasTargetTyped { get; }
        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitConvertedTupleLiteral(this);

        public LoweredConvertedTupleLiteral Update(LoweredTupleLiteral? sourceTuple, bool wasTargetTyped, ImmutableArray<LoweredExpression> arguments, ImmutableArray<string> argumentNamesOpt, ImmutableArray<bool> inferredNamesOpt, TypeSymbol? type)
        {
            if (sourceTuple != this.SourceTuple || wasTargetTyped != this.WasTargetTyped || arguments != this.Arguments || argumentNamesOpt != this.ArgumentNamesOpt || inferredNamesOpt != this.InferredNamesOpt || !TypeSymbol.Equals(type, this.Type, TypeCompareKind.ConsiderEverything))
            {
                var result = new LoweredConvertedTupleLiteral(this.Syntax, sourceTuple, wasTargetTyped, arguments, argumentNamesOpt, inferredNamesOpt, type, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal sealed partial class LoweredDynamicObjectCreationExpression : LoweredExpression
    {
        public LoweredDynamicObjectCreationExpression(SyntaxNode syntax, string name, ImmutableArray<LoweredExpression> arguments, ImmutableArray<string> argumentNamesOpt, ImmutableArray<RefKind> argumentRefKindsOpt, LoweredObjectInitializerExpressionBase? initializerExpressionOpt, ImmutableArray<MethodSymbol> applicableMethods, TypeSymbol type, bool hasErrors = false)
            : base(LoweredKind.DynamicObjectCreationExpression, syntax, type, hasErrors || arguments.HasErrors() || initializerExpressionOpt.HasErrors())
        {

            RoslynDebug.Assert(name is object, "Field 'name' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(!arguments.IsDefault, "Field 'arguments' cannot be null (use Null=\"allow\" in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(!applicableMethods.IsDefault, "Field 'applicableMethods' cannot be null (use Null=\"allow\" in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(type is object, "Field 'type' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

            this.Name = name;
            this.Arguments = arguments;
            this.ArgumentNamesOpt = argumentNamesOpt;
            this.ArgumentRefKindsOpt = argumentRefKindsOpt;
            this.InitializerExpressionOpt = initializerExpressionOpt;
            this.ApplicableMethods = applicableMethods;
        }


        public new TypeSymbol Type => base.Type!;

        public string Name { get; }

        public ImmutableArray<LoweredExpression> Arguments { get; }

        public ImmutableArray<string> ArgumentNamesOpt { get; }

        public ImmutableArray<RefKind> ArgumentRefKindsOpt { get; }

        public LoweredObjectInitializerExpressionBase? InitializerExpressionOpt { get; }

        public ImmutableArray<MethodSymbol> ApplicableMethods { get; }
        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitDynamicObjectCreationExpression(this);

        public LoweredDynamicObjectCreationExpression Update(string name, ImmutableArray<LoweredExpression> arguments, ImmutableArray<string> argumentNamesOpt, ImmutableArray<RefKind> argumentRefKindsOpt, LoweredObjectInitializerExpressionBase? initializerExpressionOpt, ImmutableArray<MethodSymbol> applicableMethods, TypeSymbol type)
        {
            if (name != this.Name || arguments != this.Arguments || argumentNamesOpt != this.ArgumentNamesOpt || argumentRefKindsOpt != this.ArgumentRefKindsOpt || initializerExpressionOpt != this.InitializerExpressionOpt || applicableMethods != this.ApplicableMethods || !TypeSymbol.Equals(type, this.Type, TypeCompareKind.ConsiderEverything))
            {
                var result = new LoweredDynamicObjectCreationExpression(this.Syntax, name, arguments, argumentNamesOpt, argumentRefKindsOpt, initializerExpressionOpt, applicableMethods, type, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal sealed partial class LoweredNoPiaObjectCreationExpression : LoweredExpression
    {
        public LoweredNoPiaObjectCreationExpression(SyntaxNode syntax, string? guidString, LoweredObjectInitializerExpressionBase? initializerExpressionOpt, TypeSymbol type, bool hasErrors = false)
            : base(LoweredKind.NoPiaObjectCreationExpression, syntax, type, hasErrors || initializerExpressionOpt.HasErrors())
        {

            RoslynDebug.Assert(type is object, "Field 'type' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

            this.GuidString = guidString;
            this.InitializerExpressionOpt = initializerExpressionOpt;
        }


        public new TypeSymbol Type => base.Type!;

        public string? GuidString { get; }

        public LoweredObjectInitializerExpressionBase? InitializerExpressionOpt { get; }
        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitNoPiaObjectCreationExpression(this);

        public LoweredNoPiaObjectCreationExpression Update(string? guidString, LoweredObjectInitializerExpressionBase? initializerExpressionOpt, TypeSymbol type)
        {
            if (guidString != this.GuidString || initializerExpressionOpt != this.InitializerExpressionOpt || !TypeSymbol.Equals(type, this.Type, TypeCompareKind.ConsiderEverything))
            {
                var result = new LoweredNoPiaObjectCreationExpression(this.Syntax, guidString, initializerExpressionOpt, type, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal abstract partial class LoweredObjectInitializerExpressionBase : LoweredExpression
    {
        protected LoweredObjectInitializerExpressionBase(LoweredKind kind, SyntaxNode syntax, LoweredObjectOrCollectionValuePlaceholder placeholder, ImmutableArray<LoweredExpression> initializers, TypeSymbol type, bool hasErrors = false)
            : base(kind, syntax, type, hasErrors)
        {

            RoslynDebug.Assert(placeholder is object, "Field 'placeholder' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(!initializers.IsDefault, "Field 'initializers' cannot be null (use Null=\"allow\" in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(type is object, "Field 'type' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

            this.Placeholder = placeholder;
            this.Initializers = initializers;
        }


        public new TypeSymbol Type => base.Type!;

        public LoweredObjectOrCollectionValuePlaceholder Placeholder { get; }

        public ImmutableArray<LoweredExpression> Initializers { get; }
    }

    internal sealed partial class LoweredObjectInitializerExpression : LoweredObjectInitializerExpressionBase
    {
        public LoweredObjectInitializerExpression(SyntaxNode syntax, LoweredObjectOrCollectionValuePlaceholder placeholder, ImmutableArray<LoweredExpression> initializers, TypeSymbol type, bool hasErrors = false)
            : base(LoweredKind.ObjectInitializerExpression, syntax, placeholder, initializers, type, hasErrors || placeholder.HasErrors() || initializers.HasErrors())
        {

            RoslynDebug.Assert(placeholder is object, "Field 'placeholder' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(!initializers.IsDefault, "Field 'initializers' cannot be null (use Null=\"allow\" in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(type is object, "Field 'type' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

        }

        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitObjectInitializerExpression(this);

        public LoweredObjectInitializerExpression Update(LoweredObjectOrCollectionValuePlaceholder placeholder, ImmutableArray<LoweredExpression> initializers, TypeSymbol type)
        {
            if (placeholder != this.Placeholder || initializers != this.Initializers || !TypeSymbol.Equals(type, this.Type, TypeCompareKind.ConsiderEverything))
            {
                var result = new LoweredObjectInitializerExpression(this.Syntax, placeholder, initializers, type, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal sealed partial class LoweredObjectInitializerMember : LoweredExpression
    {
        public LoweredObjectInitializerMember(SyntaxNode syntax, Symbol? memberSymbol, ImmutableArray<LoweredExpression> arguments, ImmutableArray<string> argumentNamesOpt, ImmutableArray<RefKind> argumentRefKindsOpt, bool expanded, ImmutableArray<int> argsToParamsOpt, LookupResultKind resultKind, TypeSymbol receiverType, Binder? binderOpt, TypeSymbol type, bool hasErrors = false)
            : base(LoweredKind.ObjectInitializerMember, syntax, type, hasErrors || arguments.HasErrors())
        {

            RoslynDebug.Assert(!arguments.IsDefault, "Field 'arguments' cannot be null (use Null=\"allow\" in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(receiverType is object, "Field 'receiverType' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(type is object, "Field 'type' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

            this.MemberSymbol = memberSymbol;
            this.Arguments = arguments;
            this.ArgumentNamesOpt = argumentNamesOpt;
            this.ArgumentRefKindsOpt = argumentRefKindsOpt;
            this.Expanded = expanded;
            this.ArgsToParamsOpt = argsToParamsOpt;
            this._ResultKind = resultKind;
            this.ReceiverType = receiverType;
            this.BinderOpt = binderOpt;
        }


        public new TypeSymbol Type => base.Type!;

        public Symbol? MemberSymbol { get; }

        public ImmutableArray<LoweredExpression> Arguments { get; }

        public ImmutableArray<string> ArgumentNamesOpt { get; }

        public ImmutableArray<RefKind> ArgumentRefKindsOpt { get; }

        public bool Expanded { get; }

        public ImmutableArray<int> ArgsToParamsOpt { get; }

        private readonly LookupResultKind _ResultKind;
        public override LookupResultKind ResultKind { get { return _ResultKind;} }

        public TypeSymbol ReceiverType { get; }

        public Binder? BinderOpt { get; }
        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitObjectInitializerMember(this);

        public LoweredObjectInitializerMember Update(Symbol? memberSymbol, ImmutableArray<LoweredExpression> arguments, ImmutableArray<string> argumentNamesOpt, ImmutableArray<RefKind> argumentRefKindsOpt, bool expanded, ImmutableArray<int> argsToParamsOpt, LookupResultKind resultKind, TypeSymbol receiverType, Binder? binderOpt, TypeSymbol type)
        {
            if (!Symbols.SymbolEqualityComparer.ConsiderEverything.Equals(memberSymbol, this.MemberSymbol) || arguments != this.Arguments || argumentNamesOpt != this.ArgumentNamesOpt || argumentRefKindsOpt != this.ArgumentRefKindsOpt || expanded != this.Expanded || argsToParamsOpt != this.ArgsToParamsOpt || resultKind != this.ResultKind || !TypeSymbol.Equals(receiverType, this.ReceiverType, TypeCompareKind.ConsiderEverything) || binderOpt != this.BinderOpt || !TypeSymbol.Equals(type, this.Type, TypeCompareKind.ConsiderEverything))
            {
                var result = new LoweredObjectInitializerMember(this.Syntax, memberSymbol, arguments, argumentNamesOpt, argumentRefKindsOpt, expanded, argsToParamsOpt, resultKind, receiverType, binderOpt, type, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal sealed partial class LoweredDynamicObjectInitializerMember : LoweredExpression
    {
        public LoweredDynamicObjectInitializerMember(SyntaxNode syntax, string memberName, TypeSymbol receiverType, TypeSymbol type, bool hasErrors)
            : base(LoweredKind.DynamicObjectInitializerMember, syntax, type, hasErrors)
        {

            RoslynDebug.Assert(memberName is object, "Field 'memberName' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(receiverType is object, "Field 'receiverType' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(type is object, "Field 'type' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

            this.MemberName = memberName;
            this.ReceiverType = receiverType;
        }

        public LoweredDynamicObjectInitializerMember(SyntaxNode syntax, string memberName, TypeSymbol receiverType, TypeSymbol type)
            : base(LoweredKind.DynamicObjectInitializerMember, syntax, type)
        {

            RoslynDebug.Assert(memberName is object, "Field 'memberName' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(receiverType is object, "Field 'receiverType' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(type is object, "Field 'type' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

            this.MemberName = memberName;
            this.ReceiverType = receiverType;
        }


        public new TypeSymbol Type => base.Type!;

        public string MemberName { get; }

        public TypeSymbol ReceiverType { get; }
        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitDynamicObjectInitializerMember(this);

        public LoweredDynamicObjectInitializerMember Update(string memberName, TypeSymbol receiverType, TypeSymbol type)
        {
            if (memberName != this.MemberName || !TypeSymbol.Equals(receiverType, this.ReceiverType, TypeCompareKind.ConsiderEverything) || !TypeSymbol.Equals(type, this.Type, TypeCompareKind.ConsiderEverything))
            {
                var result = new LoweredDynamicObjectInitializerMember(this.Syntax, memberName, receiverType, type, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal sealed partial class LoweredCollectionInitializerExpression : LoweredObjectInitializerExpressionBase
    {
        public LoweredCollectionInitializerExpression(SyntaxNode syntax, LoweredObjectOrCollectionValuePlaceholder placeholder, ImmutableArray<LoweredExpression> initializers, TypeSymbol type, bool hasErrors = false)
            : base(LoweredKind.CollectionInitializerExpression, syntax, placeholder, initializers, type, hasErrors || placeholder.HasErrors() || initializers.HasErrors())
        {

            RoslynDebug.Assert(placeholder is object, "Field 'placeholder' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(!initializers.IsDefault, "Field 'initializers' cannot be null (use Null=\"allow\" in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(type is object, "Field 'type' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

        }

        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitCollectionInitializerExpression(this);

        public LoweredCollectionInitializerExpression Update(LoweredObjectOrCollectionValuePlaceholder placeholder, ImmutableArray<LoweredExpression> initializers, TypeSymbol type)
        {
            if (placeholder != this.Placeholder || initializers != this.Initializers || !TypeSymbol.Equals(type, this.Type, TypeCompareKind.ConsiderEverything))
            {
                var result = new LoweredCollectionInitializerExpression(this.Syntax, placeholder, initializers, type, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal sealed partial class LoweredCollectionElementInitializer : LoweredExpression
    {
        public LoweredCollectionElementInitializer(SyntaxNode syntax, MethodSymbol addMethod, ImmutableArray<LoweredExpression> arguments, LoweredExpression? implicitReceiverOpt, bool expanded, ImmutableArray<int> argsToParamsOpt, bool invokedAsExtensionMethod, LookupResultKind resultKind, Binder? binderOpt, TypeSymbol type, bool hasErrors = false)
            : base(LoweredKind.CollectionElementInitializer, syntax, type, hasErrors || arguments.HasErrors() || implicitReceiverOpt.HasErrors())
        {

            RoslynDebug.Assert(addMethod is object, "Field 'addMethod' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(!arguments.IsDefault, "Field 'arguments' cannot be null (use Null=\"allow\" in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(type is object, "Field 'type' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

            this.AddMethod = addMethod;
            this.Arguments = arguments;
            this.ImplicitReceiverOpt = implicitReceiverOpt;
            this.Expanded = expanded;
            this.ArgsToParamsOpt = argsToParamsOpt;
            this.InvokedAsExtensionMethod = invokedAsExtensionMethod;
            this._ResultKind = resultKind;
            this.BinderOpt = binderOpt;
        }


        public new TypeSymbol Type => base.Type!;

        public MethodSymbol AddMethod { get; }

        public ImmutableArray<LoweredExpression> Arguments { get; }

        public LoweredExpression? ImplicitReceiverOpt { get; }

        public bool Expanded { get; }

        public ImmutableArray<int> ArgsToParamsOpt { get; }

        public bool InvokedAsExtensionMethod { get; }

        private readonly LookupResultKind _ResultKind;
        public override LookupResultKind ResultKind { get { return _ResultKind;} }

        public Binder? BinderOpt { get; }
        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitCollectionElementInitializer(this);

        public LoweredCollectionElementInitializer Update(MethodSymbol addMethod, ImmutableArray<LoweredExpression> arguments, LoweredExpression? implicitReceiverOpt, bool expanded, ImmutableArray<int> argsToParamsOpt, bool invokedAsExtensionMethod, LookupResultKind resultKind, Binder? binderOpt, TypeSymbol type)
        {
            if (!Symbols.SymbolEqualityComparer.ConsiderEverything.Equals(addMethod, this.AddMethod) || arguments != this.Arguments || implicitReceiverOpt != this.ImplicitReceiverOpt || expanded != this.Expanded || argsToParamsOpt != this.ArgsToParamsOpt || invokedAsExtensionMethod != this.InvokedAsExtensionMethod || resultKind != this.ResultKind || binderOpt != this.BinderOpt || !TypeSymbol.Equals(type, this.Type, TypeCompareKind.ConsiderEverything))
            {
                var result = new LoweredCollectionElementInitializer(this.Syntax, addMethod, arguments, implicitReceiverOpt, expanded, argsToParamsOpt, invokedAsExtensionMethod, resultKind, binderOpt, type, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal sealed partial class LoweredDynamicCollectionElementInitializer : LoweredDynamicInvocableBase
    {
        public LoweredDynamicCollectionElementInitializer(SyntaxNode syntax, ImmutableArray<MethodSymbol> applicableMethods, LoweredExpression expression, ImmutableArray<LoweredExpression> arguments, TypeSymbol type, bool hasErrors = false)
            : base(LoweredKind.DynamicCollectionElementInitializer, syntax, expression, arguments, type, hasErrors || expression.HasErrors() || arguments.HasErrors())
        {

            RoslynDebug.Assert(!applicableMethods.IsDefault, "Field 'applicableMethods' cannot be null (use Null=\"allow\" in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(expression is object, "Field 'expression' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(!arguments.IsDefault, "Field 'arguments' cannot be null (use Null=\"allow\" in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(type is object, "Field 'type' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

            this.ApplicableMethods = applicableMethods;
        }


        public new TypeSymbol Type => base.Type!;

        public ImmutableArray<MethodSymbol> ApplicableMethods { get; }
        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitDynamicCollectionElementInitializer(this);

        public LoweredDynamicCollectionElementInitializer Update(ImmutableArray<MethodSymbol> applicableMethods, LoweredExpression expression, ImmutableArray<LoweredExpression> arguments, TypeSymbol type)
        {
            if (applicableMethods != this.ApplicableMethods || expression != this.Expression || arguments != this.Arguments || !TypeSymbol.Equals(type, this.Type, TypeCompareKind.ConsiderEverything))
            {
                var result = new LoweredDynamicCollectionElementInitializer(this.Syntax, applicableMethods, expression, arguments, type, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal sealed partial class LoweredImplicitReceiver : LoweredExpression
    {
        public LoweredImplicitReceiver(SyntaxNode syntax, TypeSymbol type, bool hasErrors)
            : base(LoweredKind.ImplicitReceiver, syntax, type, hasErrors)
        {

            RoslynDebug.Assert(type is object, "Field 'type' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

        }

        public LoweredImplicitReceiver(SyntaxNode syntax, TypeSymbol type)
            : base(LoweredKind.ImplicitReceiver, syntax, type)
        {

            RoslynDebug.Assert(type is object, "Field 'type' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

        }


        public new TypeSymbol Type => base.Type!;
        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitImplicitReceiver(this);

        public LoweredImplicitReceiver Update(TypeSymbol type)
        {
            if (!TypeSymbol.Equals(type, this.Type, TypeCompareKind.ConsiderEverything))
            {
                var result = new LoweredImplicitReceiver(this.Syntax, type, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal sealed partial class LoweredAnonymousObjectCreationExpression : LoweredExpression
    {
        public LoweredAnonymousObjectCreationExpression(SyntaxNode syntax, MethodSymbol constructor, ImmutableArray<LoweredExpression> arguments, ImmutableArray<LoweredAnonymousPropertyDeclaration> declarations, TypeSymbol type, bool hasErrors = false)
            : base(LoweredKind.AnonymousObjectCreationExpression, syntax, type, hasErrors || arguments.HasErrors() || declarations.HasErrors())
        {

            RoslynDebug.Assert(constructor is object, "Field 'constructor' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(!arguments.IsDefault, "Field 'arguments' cannot be null (use Null=\"allow\" in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(!declarations.IsDefault, "Field 'declarations' cannot be null (use Null=\"allow\" in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(type is object, "Field 'type' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

            this.Constructor = constructor;
            this.Arguments = arguments;
            this.Declarations = declarations;
        }


        public new TypeSymbol Type => base.Type!;

        public MethodSymbol Constructor { get; }

        public ImmutableArray<LoweredExpression> Arguments { get; }

        public ImmutableArray<LoweredAnonymousPropertyDeclaration> Declarations { get; }
        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitAnonymousObjectCreationExpression(this);

        public LoweredAnonymousObjectCreationExpression Update(MethodSymbol constructor, ImmutableArray<LoweredExpression> arguments, ImmutableArray<LoweredAnonymousPropertyDeclaration> declarations, TypeSymbol type)
        {
            if (!Symbols.SymbolEqualityComparer.ConsiderEverything.Equals(constructor, this.Constructor) || arguments != this.Arguments || declarations != this.Declarations || !TypeSymbol.Equals(type, this.Type, TypeCompareKind.ConsiderEverything))
            {
                var result = new LoweredAnonymousObjectCreationExpression(this.Syntax, constructor, arguments, declarations, type, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal sealed partial class LoweredAnonymousPropertyDeclaration : LoweredExpression
    {
        public LoweredAnonymousPropertyDeclaration(SyntaxNode syntax, PropertySymbol property, TypeSymbol type, bool hasErrors)
            : base(LoweredKind.AnonymousPropertyDeclaration, syntax, type, hasErrors)
        {

            RoslynDebug.Assert(property is object, "Field 'property' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(type is object, "Field 'type' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

            this.Property = property;
        }

        public LoweredAnonymousPropertyDeclaration(SyntaxNode syntax, PropertySymbol property, TypeSymbol type)
            : base(LoweredKind.AnonymousPropertyDeclaration, syntax, type)
        {

            RoslynDebug.Assert(property is object, "Field 'property' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(type is object, "Field 'type' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

            this.Property = property;
        }


        public new TypeSymbol Type => base.Type!;

        public PropertySymbol Property { get; }
        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitAnonymousPropertyDeclaration(this);

        public LoweredAnonymousPropertyDeclaration Update(PropertySymbol property, TypeSymbol type)
        {
            if (!Symbols.SymbolEqualityComparer.ConsiderEverything.Equals(property, this.Property) || !TypeSymbol.Equals(type, this.Type, TypeCompareKind.ConsiderEverything))
            {
                var result = new LoweredAnonymousPropertyDeclaration(this.Syntax, property, type, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal sealed partial class LoweredNewT : LoweredExpression
    {
        public LoweredNewT(SyntaxNode syntax, LoweredObjectInitializerExpressionBase? initializerExpressionOpt, TypeSymbol type, bool hasErrors = false)
            : base(LoweredKind.NewT, syntax, type, hasErrors || initializerExpressionOpt.HasErrors())
        {

            RoslynDebug.Assert(type is object, "Field 'type' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

            this.InitializerExpressionOpt = initializerExpressionOpt;
        }


        public new TypeSymbol Type => base.Type!;

        public LoweredObjectInitializerExpressionBase? InitializerExpressionOpt { get; }
        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitNewT(this);

        public LoweredNewT Update(LoweredObjectInitializerExpressionBase? initializerExpressionOpt, TypeSymbol type)
        {
            if (initializerExpressionOpt != this.InitializerExpressionOpt || !TypeSymbol.Equals(type, this.Type, TypeCompareKind.ConsiderEverything))
            {
                var result = new LoweredNewT(this.Syntax, initializerExpressionOpt, type, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal sealed partial class LoweredDelegateCreationExpression : LoweredExpression
    {
        public LoweredDelegateCreationExpression(SyntaxNode syntax, LoweredExpression argument, MethodSymbol? methodOpt, bool isExtensionMethod, TypeSymbol type, bool hasErrors = false)
            : base(LoweredKind.DelegateCreationExpression, syntax, type, hasErrors || argument.HasErrors())
        {

            RoslynDebug.Assert(argument is object, "Field 'argument' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(type is object, "Field 'type' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

            this.Argument = argument;
            this.MethodOpt = methodOpt;
            this.IsExtensionMethod = isExtensionMethod;
        }


        public new TypeSymbol Type => base.Type!;

        public LoweredExpression Argument { get; }

        public MethodSymbol? MethodOpt { get; }

        public bool IsExtensionMethod { get; }
        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitDelegateCreationExpression(this);

        public LoweredDelegateCreationExpression Update(LoweredExpression argument, MethodSymbol? methodOpt, bool isExtensionMethod, TypeSymbol type)
        {
            if (argument != this.Argument || !Symbols.SymbolEqualityComparer.ConsiderEverything.Equals(methodOpt, this.MethodOpt) || isExtensionMethod != this.IsExtensionMethod || !TypeSymbol.Equals(type, this.Type, TypeCompareKind.ConsiderEverything))
            {
                var result = new LoweredDelegateCreationExpression(this.Syntax, argument, methodOpt, isExtensionMethod, type, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal sealed partial class LoweredArrayCreation : LoweredExpression
    {
        public LoweredArrayCreation(SyntaxNode syntax, ImmutableArray<LoweredExpression> bounds, LoweredArrayInitialization? initializerOpt, TypeSymbol type, bool hasErrors = false)
            : base(LoweredKind.ArrayCreation, syntax, type, hasErrors || bounds.HasErrors() || initializerOpt.HasErrors())
        {

            RoslynDebug.Assert(!bounds.IsDefault, "Field 'bounds' cannot be null (use Null=\"allow\" in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(type is object, "Field 'type' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

            this.Lowereds = bounds;
            this.InitializerOpt = initializerOpt;
        }


        public new TypeSymbol Type => base.Type!;

        public ImmutableArray<LoweredExpression> Lowereds { get; }

        public LoweredArrayInitialization? InitializerOpt { get; }
        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitArrayCreation(this);

        public LoweredArrayCreation Update(ImmutableArray<LoweredExpression> bounds, LoweredArrayInitialization? initializerOpt, TypeSymbol type)
        {
            if (bounds != this.Lowereds || initializerOpt != this.InitializerOpt || !TypeSymbol.Equals(type, this.Type, TypeCompareKind.ConsiderEverything))
            {
                var result = new LoweredArrayCreation(this.Syntax, bounds, initializerOpt, type, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal sealed partial class LoweredArrayInitialization : LoweredExpression
    {
        public LoweredArrayInitialization(SyntaxNode syntax, ImmutableArray<LoweredExpression> initializers, bool hasErrors = false)
            : base(LoweredKind.ArrayInitialization, syntax, null, hasErrors || initializers.HasErrors())
        {

            RoslynDebug.Assert(!initializers.IsDefault, "Field 'initializers' cannot be null (use Null=\"allow\" in LoweredNodes.xml to remove this check)");

            this.Initializers = initializers;
        }


        public new TypeSymbol Type => base.Type!;

        public ImmutableArray<LoweredExpression> Initializers { get; }
        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitArrayInitialization(this);

        public LoweredArrayInitialization Update(ImmutableArray<LoweredExpression> initializers)
        {
            if (initializers != this.Initializers)
            {
                var result = new LoweredArrayInitialization(this.Syntax, initializers, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal abstract partial class LoweredStackAllocArrayCreationBase : LoweredExpression
    {
        protected LoweredStackAllocArrayCreationBase(LoweredKind kind, SyntaxNode syntax, TypeSymbol elementType, LoweredExpression count, LoweredArrayInitialization? initializerOpt, TypeSymbol? type, bool hasErrors = false)
            : base(kind, syntax, type, hasErrors)
        {

            RoslynDebug.Assert(elementType is object, "Field 'elementType' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(count is object, "Field 'count' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

            this.ElementType = elementType;
            this.Count = count;
            this.InitializerOpt = initializerOpt;
        }


        public new TypeSymbol? Type => base.Type!;

        public TypeSymbol ElementType { get; }

        public LoweredExpression Count { get; }

        public LoweredArrayInitialization? InitializerOpt { get; }
    }

    internal sealed partial class LoweredStackAllocArrayCreation : LoweredStackAllocArrayCreationBase
    {
        public LoweredStackAllocArrayCreation(SyntaxNode syntax, TypeSymbol elementType, LoweredExpression count, LoweredArrayInitialization? initializerOpt, TypeSymbol? type, bool hasErrors = false)
            : base(LoweredKind.StackAllocArrayCreation, syntax, elementType, count, initializerOpt, type, hasErrors || count.HasErrors() || initializerOpt.HasErrors())
        {

            RoslynDebug.Assert(elementType is object, "Field 'elementType' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(count is object, "Field 'count' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

        }


        public new TypeSymbol? Type => base.Type!;
        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitStackAllocArrayCreation(this);

        public LoweredStackAllocArrayCreation Update(TypeSymbol elementType, LoweredExpression count, LoweredArrayInitialization? initializerOpt, TypeSymbol? type)
        {
            if (!TypeSymbol.Equals(elementType, this.ElementType, TypeCompareKind.ConsiderEverything) || count != this.Count || initializerOpt != this.InitializerOpt || !TypeSymbol.Equals(type, this.Type, TypeCompareKind.ConsiderEverything))
            {
                var result = new LoweredStackAllocArrayCreation(this.Syntax, elementType, count, initializerOpt, type, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal sealed partial class LoweredConvertedStackAllocExpression : LoweredStackAllocArrayCreationBase
    {
        public LoweredConvertedStackAllocExpression(SyntaxNode syntax, TypeSymbol elementType, LoweredExpression count, LoweredArrayInitialization? initializerOpt, TypeSymbol type, bool hasErrors = false)
            : base(LoweredKind.ConvertedStackAllocExpression, syntax, elementType, count, initializerOpt, type, hasErrors || count.HasErrors() || initializerOpt.HasErrors())
        {

            RoslynDebug.Assert(elementType is object, "Field 'elementType' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(count is object, "Field 'count' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(type is object, "Field 'type' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

        }


        public new TypeSymbol Type => base.Type!;
        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitConvertedStackAllocExpression(this);

        public LoweredConvertedStackAllocExpression Update(TypeSymbol elementType, LoweredExpression count, LoweredArrayInitialization? initializerOpt, TypeSymbol type)
        {
            if (!TypeSymbol.Equals(elementType, this.ElementType, TypeCompareKind.ConsiderEverything) || count != this.Count || initializerOpt != this.InitializerOpt || !TypeSymbol.Equals(type, this.Type, TypeCompareKind.ConsiderEverything))
            {
                var result = new LoweredConvertedStackAllocExpression(this.Syntax, elementType, count, initializerOpt, type, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal sealed partial class LoweredFieldAccess : LoweredExpression
    {
        public LoweredFieldAccess(SyntaxNode syntax, LoweredExpression? receiverOpt, FieldSymbol fieldSymbol, ConstantValue? constantValueOpt, LookupResultKind resultKind, bool isByValue, bool isDeclaration, TypeSymbol type, bool hasErrors = false)
            : base(LoweredKind.FieldAccess, syntax, type, hasErrors || receiverOpt.HasErrors())
        {

            RoslynDebug.Assert(fieldSymbol is object, "Field 'fieldSymbol' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(type is object, "Field 'type' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

            this.ReceiverOpt = receiverOpt;
            this.FieldSymbol = fieldSymbol;
            this.ConstantValueOpt = constantValueOpt;
            this._ResultKind = resultKind;
            this.IsByValue = isByValue;
            this.IsDeclaration = isDeclaration;
        }


        public new TypeSymbol Type => base.Type!;

        public LoweredExpression? ReceiverOpt { get; }

        public FieldSymbol FieldSymbol { get; }

        public ConstantValue? ConstantValueOpt { get; }

        private readonly LookupResultKind _ResultKind;
        public override LookupResultKind ResultKind { get { return _ResultKind;} }

        public bool IsByValue { get; }

        public bool IsDeclaration { get; }
        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitFieldAccess(this);

        public LoweredFieldAccess Update(LoweredExpression? receiverOpt, FieldSymbol fieldSymbol, ConstantValue? constantValueOpt, LookupResultKind resultKind, bool isByValue, bool isDeclaration, TypeSymbol type)
        {
            if (receiverOpt != this.ReceiverOpt || !Symbols.SymbolEqualityComparer.ConsiderEverything.Equals(fieldSymbol, this.FieldSymbol) || constantValueOpt != this.ConstantValueOpt || resultKind != this.ResultKind || isByValue != this.IsByValue || isDeclaration != this.IsDeclaration || !TypeSymbol.Equals(type, this.Type, TypeCompareKind.ConsiderEverything))
            {
                var result = new LoweredFieldAccess(this.Syntax, receiverOpt, fieldSymbol, constantValueOpt, resultKind, isByValue, isDeclaration, type, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal sealed partial class LoweredHoistedFieldAccess : LoweredExpression
    {
        public LoweredHoistedFieldAccess(SyntaxNode syntax, FieldSymbol fieldSymbol, TypeSymbol type, bool hasErrors)
            : base(LoweredKind.HoistedFieldAccess, syntax, type, hasErrors)
        {

            RoslynDebug.Assert(fieldSymbol is object, "Field 'fieldSymbol' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(type is object, "Field 'type' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

            this.FieldSymbol = fieldSymbol;
        }

        public LoweredHoistedFieldAccess(SyntaxNode syntax, FieldSymbol fieldSymbol, TypeSymbol type)
            : base(LoweredKind.HoistedFieldAccess, syntax, type)
        {

            RoslynDebug.Assert(fieldSymbol is object, "Field 'fieldSymbol' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(type is object, "Field 'type' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

            this.FieldSymbol = fieldSymbol;
        }


        public new TypeSymbol Type => base.Type!;

        public FieldSymbol FieldSymbol { get; }
        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitHoistedFieldAccess(this);

        public LoweredHoistedFieldAccess Update(FieldSymbol fieldSymbol, TypeSymbol type)
        {
            if (!Symbols.SymbolEqualityComparer.ConsiderEverything.Equals(fieldSymbol, this.FieldSymbol) || !TypeSymbol.Equals(type, this.Type, TypeCompareKind.ConsiderEverything))
            {
                var result = new LoweredHoistedFieldAccess(this.Syntax, fieldSymbol, type, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal sealed partial class LoweredPropertyAccess : LoweredExpression
    {
        public LoweredPropertyAccess(SyntaxNode syntax, LoweredExpression? receiverOpt, PropertySymbol propertySymbol, LookupResultKind resultKind, TypeSymbol type, bool hasErrors = false)
            : base(LoweredKind.PropertyAccess, syntax, type, hasErrors || receiverOpt.HasErrors())
        {

            RoslynDebug.Assert(propertySymbol is object, "Field 'propertySymbol' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(type is object, "Field 'type' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

            this.ReceiverOpt = receiverOpt;
            this.PropertySymbol = propertySymbol;
            this._ResultKind = resultKind;
        }


        public new TypeSymbol Type => base.Type!;

        public LoweredExpression? ReceiverOpt { get; }

        public PropertySymbol PropertySymbol { get; }

        private readonly LookupResultKind _ResultKind;
        public override LookupResultKind ResultKind { get { return _ResultKind;} }
        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitPropertyAccess(this);

        public LoweredPropertyAccess Update(LoweredExpression? receiverOpt, PropertySymbol propertySymbol, LookupResultKind resultKind, TypeSymbol type)
        {
            if (receiverOpt != this.ReceiverOpt || !Symbols.SymbolEqualityComparer.ConsiderEverything.Equals(propertySymbol, this.PropertySymbol) || resultKind != this.ResultKind || !TypeSymbol.Equals(type, this.Type, TypeCompareKind.ConsiderEverything))
            {
                var result = new LoweredPropertyAccess(this.Syntax, receiverOpt, propertySymbol, resultKind, type, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal sealed partial class LoweredEventAccess : LoweredExpression
    {
        public LoweredEventAccess(SyntaxNode syntax, LoweredExpression? receiverOpt, EventSymbol eventSymbol, bool isUsableAsField, LookupResultKind resultKind, TypeSymbol type, bool hasErrors = false)
            : base(LoweredKind.EventAccess, syntax, type, hasErrors || receiverOpt.HasErrors())
        {

            RoslynDebug.Assert(eventSymbol is object, "Field 'eventSymbol' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(type is object, "Field 'type' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

            this.ReceiverOpt = receiverOpt;
            this.EventSymbol = eventSymbol;
            this.IsUsableAsField = isUsableAsField;
            this._ResultKind = resultKind;
        }


        public new TypeSymbol Type => base.Type!;

        public LoweredExpression? ReceiverOpt { get; }

        public EventSymbol EventSymbol { get; }

        public bool IsUsableAsField { get; }

        private readonly LookupResultKind _ResultKind;
        public override LookupResultKind ResultKind { get { return _ResultKind;} }
        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitEventAccess(this);

        public LoweredEventAccess Update(LoweredExpression? receiverOpt, EventSymbol eventSymbol, bool isUsableAsField, LookupResultKind resultKind, TypeSymbol type)
        {
            if (receiverOpt != this.ReceiverOpt || !Symbols.SymbolEqualityComparer.ConsiderEverything.Equals(eventSymbol, this.EventSymbol) || isUsableAsField != this.IsUsableAsField || resultKind != this.ResultKind || !TypeSymbol.Equals(type, this.Type, TypeCompareKind.ConsiderEverything))
            {
                var result = new LoweredEventAccess(this.Syntax, receiverOpt, eventSymbol, isUsableAsField, resultKind, type, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal sealed partial class LoweredIndexerAccess : LoweredExpression
    {
        public LoweredIndexerAccess(SyntaxNode syntax, LoweredExpression? receiverOpt, PropertySymbol indexer, ImmutableArray<LoweredExpression> arguments, ImmutableArray<string> argumentNamesOpt, ImmutableArray<RefKind> argumentRefKindsOpt, bool expanded, ImmutableArray<int> argsToParamsOpt, Binder? binderOpt, bool useSetterForDefaultArgumentGeneration, ImmutableArray<PropertySymbol> originalIndexersOpt, TypeSymbol type, bool hasErrors = false)
            : base(LoweredKind.IndexerAccess, syntax, type, hasErrors || receiverOpt.HasErrors() || arguments.HasErrors())
        {

            RoslynDebug.Assert(indexer is object, "Field 'indexer' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(!arguments.IsDefault, "Field 'arguments' cannot be null (use Null=\"allow\" in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(type is object, "Field 'type' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

            this.ReceiverOpt = receiverOpt;
            this.Indexer = indexer;
            this.Arguments = arguments;
            this.ArgumentNamesOpt = argumentNamesOpt;
            this.ArgumentRefKindsOpt = argumentRefKindsOpt;
            this.Expanded = expanded;
            this.ArgsToParamsOpt = argsToParamsOpt;
            this.BinderOpt = binderOpt;
            this.UseSetterForDefaultArgumentGeneration = useSetterForDefaultArgumentGeneration;
            this.OriginalIndexersOpt = originalIndexersOpt;
        }


        public new TypeSymbol Type => base.Type!;

        public LoweredExpression? ReceiverOpt { get; }

        public PropertySymbol Indexer { get; }

        public ImmutableArray<LoweredExpression> Arguments { get; }

        public ImmutableArray<string> ArgumentNamesOpt { get; }

        public ImmutableArray<RefKind> ArgumentRefKindsOpt { get; }

        public bool Expanded { get; }

        public ImmutableArray<int> ArgsToParamsOpt { get; }

        public Binder? BinderOpt { get; }

        public bool UseSetterForDefaultArgumentGeneration { get; }

        public ImmutableArray<PropertySymbol> OriginalIndexersOpt { get; }
        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitIndexerAccess(this);

        public LoweredIndexerAccess Update(LoweredExpression? receiverOpt, PropertySymbol indexer, ImmutableArray<LoweredExpression> arguments, ImmutableArray<string> argumentNamesOpt, ImmutableArray<RefKind> argumentRefKindsOpt, bool expanded, ImmutableArray<int> argsToParamsOpt, Binder? binderOpt, bool useSetterForDefaultArgumentGeneration, ImmutableArray<PropertySymbol> originalIndexersOpt, TypeSymbol type)
        {
            if (receiverOpt != this.ReceiverOpt || !Symbols.SymbolEqualityComparer.ConsiderEverything.Equals(indexer, this.Indexer) || arguments != this.Arguments || argumentNamesOpt != this.ArgumentNamesOpt || argumentRefKindsOpt != this.ArgumentRefKindsOpt || expanded != this.Expanded || argsToParamsOpt != this.ArgsToParamsOpt || binderOpt != this.BinderOpt || useSetterForDefaultArgumentGeneration != this.UseSetterForDefaultArgumentGeneration || originalIndexersOpt != this.OriginalIndexersOpt || !TypeSymbol.Equals(type, this.Type, TypeCompareKind.ConsiderEverything))
            {
                var result = new LoweredIndexerAccess(this.Syntax, receiverOpt, indexer, arguments, argumentNamesOpt, argumentRefKindsOpt, expanded, argsToParamsOpt, binderOpt, useSetterForDefaultArgumentGeneration, originalIndexersOpt, type, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal sealed partial class LoweredIndexOrRangePatternIndexerAccess : LoweredExpression
    {
        public LoweredIndexOrRangePatternIndexerAccess(SyntaxNode syntax, LoweredExpression receiver, PropertySymbol lengthOrCountProperty, Symbol patternSymbol, LoweredExpression argument, TypeSymbol type, bool hasErrors = false)
            : base(LoweredKind.IndexOrRangePatternIndexerAccess, syntax, type, hasErrors || receiver.HasErrors() || argument.HasErrors())
        {

            RoslynDebug.Assert(receiver is object, "Field 'receiver' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(lengthOrCountProperty is object, "Field 'lengthOrCountProperty' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(patternSymbol is object, "Field 'patternSymbol' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(argument is object, "Field 'argument' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(type is object, "Field 'type' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

            this.Receiver = receiver;
            this.LengthOrCountProperty = lengthOrCountProperty;
            this.PatternSymbol = patternSymbol;
            this.Argument = argument;
        }


        public new TypeSymbol Type => base.Type!;

        public LoweredExpression Receiver { get; }

        public PropertySymbol LengthOrCountProperty { get; }

        public Symbol PatternSymbol { get; }

        public LoweredExpression Argument { get; }
        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitIndexOrRangePatternIndexerAccess(this);

        public LoweredIndexOrRangePatternIndexerAccess Update(LoweredExpression receiver, PropertySymbol lengthOrCountProperty, Symbol patternSymbol, LoweredExpression argument, TypeSymbol type)
        {
            if (receiver != this.Receiver || !Symbols.SymbolEqualityComparer.ConsiderEverything.Equals(lengthOrCountProperty, this.LengthOrCountProperty) || !Symbols.SymbolEqualityComparer.ConsiderEverything.Equals(patternSymbol, this.PatternSymbol) || argument != this.Argument || !TypeSymbol.Equals(type, this.Type, TypeCompareKind.ConsiderEverything))
            {
                var result = new LoweredIndexOrRangePatternIndexerAccess(this.Syntax, receiver, lengthOrCountProperty, patternSymbol, argument, type, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal sealed partial class LoweredDynamicIndexerAccess : LoweredExpression
    {
        public LoweredDynamicIndexerAccess(SyntaxNode syntax, LoweredExpression? receiverOpt, ImmutableArray<LoweredExpression> arguments, ImmutableArray<string> argumentNamesOpt, ImmutableArray<RefKind> argumentRefKindsOpt, ImmutableArray<PropertySymbol> applicableIndexers, TypeSymbol type, bool hasErrors = false)
            : base(LoweredKind.DynamicIndexerAccess, syntax, type, hasErrors || receiverOpt.HasErrors() || arguments.HasErrors())
        {

            RoslynDebug.Assert(!arguments.IsDefault, "Field 'arguments' cannot be null (use Null=\"allow\" in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(!applicableIndexers.IsDefault, "Field 'applicableIndexers' cannot be null (use Null=\"allow\" in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(type is object, "Field 'type' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

            this.ReceiverOpt = receiverOpt;
            this.Arguments = arguments;
            this.ArgumentNamesOpt = argumentNamesOpt;
            this.ArgumentRefKindsOpt = argumentRefKindsOpt;
            this.ApplicableIndexers = applicableIndexers;
        }


        public new TypeSymbol Type => base.Type!;

        public LoweredExpression? ReceiverOpt { get; }

        public ImmutableArray<LoweredExpression> Arguments { get; }

        public ImmutableArray<string> ArgumentNamesOpt { get; }

        public ImmutableArray<RefKind> ArgumentRefKindsOpt { get; }

        public ImmutableArray<PropertySymbol> ApplicableIndexers { get; }
        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitDynamicIndexerAccess(this);

        public LoweredDynamicIndexerAccess Update(LoweredExpression? receiverOpt, ImmutableArray<LoweredExpression> arguments, ImmutableArray<string> argumentNamesOpt, ImmutableArray<RefKind> argumentRefKindsOpt, ImmutableArray<PropertySymbol> applicableIndexers, TypeSymbol type)
        {
            if (receiverOpt != this.ReceiverOpt || arguments != this.Arguments || argumentNamesOpt != this.ArgumentNamesOpt || argumentRefKindsOpt != this.ArgumentRefKindsOpt || applicableIndexers != this.ApplicableIndexers || !TypeSymbol.Equals(type, this.Type, TypeCompareKind.ConsiderEverything))
            {
                var result = new LoweredDynamicIndexerAccess(this.Syntax, receiverOpt, arguments, argumentNamesOpt, argumentRefKindsOpt, applicableIndexers, type, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal sealed partial class LoweredLambda : LoweredExpression
    {
        public LoweredLambda(SyntaxNode syntax, UnboundLambda unboundLambda, LambdaSymbol symbol, LoweredBlock body, ImmutableArray<Microsoft.CodeAnalysis.Diagnostic> diagnostics, Binder binder, TypeSymbol? type, bool hasErrors = false)
            : base(LoweredKind.Lambda, syntax, type, hasErrors || unboundLambda.HasErrors() || body.HasErrors())
        {

            RoslynDebug.Assert(unboundLambda is object, "Field 'unboundLambda' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(symbol is object, "Field 'symbol' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(body is object, "Field 'body' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(!diagnostics.IsDefault, "Field 'diagnostics' cannot be null (use Null=\"allow\" in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(binder is object, "Field 'binder' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

            this.UnboundLambda = unboundLambda;
            this.Symbol = symbol;
            this.Body = body;
            this.Diagnostics = diagnostics;
            this.Binder = binder;
        }


        public UnboundLambda UnboundLambda { get; }

        public LambdaSymbol Symbol { get; }

        public new TypeSymbol? Type => base.Type!;

        public LoweredBlock Body { get; }

        public ImmutableArray<Microsoft.CodeAnalysis.Diagnostic> Diagnostics { get; }

        public Binder Binder { get; }
        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitLambda(this);

        public LoweredLambda Update(UnboundLambda unboundLambda, LambdaSymbol symbol, LoweredBlock body, ImmutableArray<Microsoft.CodeAnalysis.Diagnostic> diagnostics, Binder binder, TypeSymbol? type)
        {
            if (unboundLambda != this.UnboundLambda || !Symbols.SymbolEqualityComparer.ConsiderEverything.Equals(symbol, this.Symbol) || body != this.Body || diagnostics != this.Diagnostics || binder != this.Binder || !TypeSymbol.Equals(type, this.Type, TypeCompareKind.ConsiderEverything))
            {
                var result = new LoweredLambda(this.Syntax, unboundLambda, symbol, body, diagnostics, binder, type, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal sealed partial class UnboundLambda : LoweredExpression
    {
        public UnboundLambda(SyntaxNode syntax, UnboundLambdaState data, bool hasErrors)
            : base(LoweredKind.UnboundLambda, syntax, null, hasErrors)
        {

            RoslynDebug.Assert(data is object, "Field 'data' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

            this.Data = data;
        }

        public UnboundLambda(SyntaxNode syntax, UnboundLambdaState data)
            : base(LoweredKind.UnboundLambda, syntax, null)
        {

            RoslynDebug.Assert(data is object, "Field 'data' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

            this.Data = data;
        }


        public new TypeSymbol Type => base.Type!;

        public UnboundLambdaState Data { get; }
        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitUnboundLambda(this);

        public UnboundLambda Update(UnboundLambdaState data)
        {
            if (data != this.Data)
            {
                var result = new UnboundLambda(this.Syntax, data, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal sealed partial class LoweredQueryClause : LoweredExpression
    {
        public LoweredQueryClause(SyntaxNode syntax, LoweredExpression value, RangeVariableSymbol? definedSymbol, LoweredExpression? operation, LoweredExpression? cast, Binder binder, LoweredExpression? unoptimizedForm, TypeSymbol type, bool hasErrors = false)
            : base(LoweredKind.QueryClause, syntax, type, hasErrors || value.HasErrors() || operation.HasErrors() || cast.HasErrors() || unoptimizedForm.HasErrors())
        {

            RoslynDebug.Assert(value is object, "Field 'value' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(binder is object, "Field 'binder' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(type is object, "Field 'type' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

            this.Value = value;
            this.DefinedSymbol = definedSymbol;
            this.Operation = operation;
            this.Cast = cast;
            this.Binder = binder;
            this.UnoptimizedForm = unoptimizedForm;
        }


        public new TypeSymbol Type => base.Type!;

        public LoweredExpression Value { get; }

        public RangeVariableSymbol? DefinedSymbol { get; }

        public LoweredExpression? Operation { get; }

        public LoweredExpression? Cast { get; }

        public Binder Binder { get; }

        public LoweredExpression? UnoptimizedForm { get; }
        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitQueryClause(this);

        public LoweredQueryClause Update(LoweredExpression value, RangeVariableSymbol? definedSymbol, LoweredExpression? operation, LoweredExpression? cast, Binder binder, LoweredExpression? unoptimizedForm, TypeSymbol type)
        {
            if (value != this.Value || !Symbols.SymbolEqualityComparer.ConsiderEverything.Equals(definedSymbol, this.DefinedSymbol) || operation != this.Operation || cast != this.Cast || binder != this.Binder || unoptimizedForm != this.UnoptimizedForm || !TypeSymbol.Equals(type, this.Type, TypeCompareKind.ConsiderEverything))
            {
                var result = new LoweredQueryClause(this.Syntax, value, definedSymbol, operation, cast, binder, unoptimizedForm, type, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal sealed partial class LoweredTypeOrInstanceInitializers : LoweredStatementList
    {
        public LoweredTypeOrInstanceInitializers(SyntaxNode syntax, ImmutableArray<LoweredStatement> statements, bool hasErrors = false)
            : base(LoweredKind.TypeOrInstanceInitializers, syntax, statements, hasErrors || statements.HasErrors())
        {

            RoslynDebug.Assert(!statements.IsDefault, "Field 'statements' cannot be null (use Null=\"allow\" in LoweredNodes.xml to remove this check)");

        }

        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitTypeOrInstanceInitializers(this);

        public new LoweredTypeOrInstanceInitializers Update(ImmutableArray<LoweredStatement> statements)
        {
            if (statements != this.Statements)
            {
                var result = new LoweredTypeOrInstanceInitializers(this.Syntax, statements, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal sealed partial class LoweredNameOfOperator : LoweredExpression
    {
        public LoweredNameOfOperator(SyntaxNode syntax, LoweredExpression argument, ConstantValue constantValueOpt, TypeSymbol type, bool hasErrors = false)
            : base(LoweredKind.NameOfOperator, syntax, type, hasErrors || argument.HasErrors())
        {

            RoslynDebug.Assert(argument is object, "Field 'argument' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(constantValueOpt is object, "Field 'constantValueOpt' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(type is object, "Field 'type' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

            this.Argument = argument;
            this.ConstantValueOpt = constantValueOpt;
        }


        public new TypeSymbol Type => base.Type!;

        public LoweredExpression Argument { get; }

        public ConstantValue ConstantValueOpt { get; }
        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitNameOfOperator(this);

        public LoweredNameOfOperator Update(LoweredExpression argument, ConstantValue constantValueOpt, TypeSymbol type)
        {
            if (argument != this.Argument || constantValueOpt != this.ConstantValueOpt || !TypeSymbol.Equals(type, this.Type, TypeCompareKind.ConsiderEverything))
            {
                var result = new LoweredNameOfOperator(this.Syntax, argument, constantValueOpt, type, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal sealed partial class LoweredInterpolatedString : LoweredExpression
    {
        public LoweredInterpolatedString(SyntaxNode syntax, ImmutableArray<LoweredExpression> parts, TypeSymbol? type, bool hasErrors = false)
            : base(LoweredKind.InterpolatedString, syntax, type, hasErrors || parts.HasErrors())
        {

            RoslynDebug.Assert(!parts.IsDefault, "Field 'parts' cannot be null (use Null=\"allow\" in LoweredNodes.xml to remove this check)");

            this.Parts = parts;
        }


        public ImmutableArray<LoweredExpression> Parts { get; }
        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitInterpolatedString(this);

        public LoweredInterpolatedString Update(ImmutableArray<LoweredExpression> parts, TypeSymbol? type)
        {
            if (parts != this.Parts || !TypeSymbol.Equals(type, this.Type, TypeCompareKind.ConsiderEverything))
            {
                var result = new LoweredInterpolatedString(this.Syntax, parts, type, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal sealed partial class LoweredStringInsert : LoweredExpression
    {
        public LoweredStringInsert(SyntaxNode syntax, LoweredExpression value, LoweredExpression? alignment, LoweredLiteral? format, TypeSymbol? type, bool hasErrors = false)
            : base(LoweredKind.StringInsert, syntax, type, hasErrors || value.HasErrors() || alignment.HasErrors() || format.HasErrors())
        {

            RoslynDebug.Assert(value is object, "Field 'value' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

            this.Value = value;
            this.Alignment = alignment;
            this.Format = format;
        }


        public LoweredExpression Value { get; }

        public LoweredExpression? Alignment { get; }

        public LoweredLiteral? Format { get; }
        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitStringInsert(this);

        public LoweredStringInsert Update(LoweredExpression value, LoweredExpression? alignment, LoweredLiteral? format, TypeSymbol? type)
        {
            if (value != this.Value || alignment != this.Alignment || format != this.Format || !TypeSymbol.Equals(type, this.Type, TypeCompareKind.ConsiderEverything))
            {
                var result = new LoweredStringInsert(this.Syntax, value, alignment, format, type, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal sealed partial class LoweredIsPatternExpression : LoweredExpression
    {
        public LoweredIsPatternExpression(SyntaxNode syntax, LoweredExpression expression, LoweredPattern pattern, LoweredDecisionDag decisionDag, LabelSymbol whenTrueLabel, LabelSymbol whenFalseLabel, TypeSymbol? type, bool hasErrors = false)
            : base(LoweredKind.IsPatternExpression, syntax, type, hasErrors || expression.HasErrors() || pattern.HasErrors() || decisionDag.HasErrors())
        {

            RoslynDebug.Assert(expression is object, "Field 'expression' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(pattern is object, "Field 'pattern' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(decisionDag is object, "Field 'decisionDag' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(whenTrueLabel is object, "Field 'whenTrueLabel' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(whenFalseLabel is object, "Field 'whenFalseLabel' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

            this.Expression = expression;
            this.Pattern = pattern;
            this.DecisionDag = decisionDag;
            this.WhenTrueLabel = whenTrueLabel;
            this.WhenFalseLabel = whenFalseLabel;
        }


        public LoweredExpression Expression { get; }

        public LoweredPattern Pattern { get; }

        public LoweredDecisionDag DecisionDag { get; }

        public LabelSymbol WhenTrueLabel { get; }

        public LabelSymbol WhenFalseLabel { get; }
        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitIsPatternExpression(this);

        public LoweredIsPatternExpression Update(LoweredExpression expression, LoweredPattern pattern, LoweredDecisionDag decisionDag, LabelSymbol whenTrueLabel, LabelSymbol whenFalseLabel, TypeSymbol? type)
        {
            if (expression != this.Expression || pattern != this.Pattern || decisionDag != this.DecisionDag || !Symbols.SymbolEqualityComparer.ConsiderEverything.Equals(whenTrueLabel, this.WhenTrueLabel) || !Symbols.SymbolEqualityComparer.ConsiderEverything.Equals(whenFalseLabel, this.WhenFalseLabel) || !TypeSymbol.Equals(type, this.Type, TypeCompareKind.ConsiderEverything))
            {
                var result = new LoweredIsPatternExpression(this.Syntax, expression, pattern, decisionDag, whenTrueLabel, whenFalseLabel, type, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal abstract partial class LoweredPattern : LoweredNode
    {
        protected LoweredPattern(LoweredKind kind, SyntaxNode syntax, TypeSymbol inputType, bool hasErrors)
            : base(kind, syntax, hasErrors)
        {

            RoslynDebug.Assert(inputType is object, "Field 'inputType' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

            this.InputType = inputType;
        }

        protected LoweredPattern(LoweredKind kind, SyntaxNode syntax, TypeSymbol inputType)
            : base(kind, syntax)
        {

            RoslynDebug.Assert(inputType is object, "Field 'inputType' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

            this.InputType = inputType;
        }


        public TypeSymbol InputType { get; }
    }

    internal sealed partial class LoweredConstantPattern : LoweredPattern
    {
        public LoweredConstantPattern(SyntaxNode syntax, LoweredExpression value, ConstantValue constantValue, TypeSymbol inputType, bool hasErrors = false)
            : base(LoweredKind.ConstantPattern, syntax, inputType, hasErrors || value.HasErrors())
        {

            RoslynDebug.Assert(value is object, "Field 'value' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(constantValue is object, "Field 'constantValue' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(inputType is object, "Field 'inputType' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

            this.Value = value;
            this.ConstantValue = constantValue;
        }


        public LoweredExpression Value { get; }

        public ConstantValue ConstantValue { get; }
        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitConstantPattern(this);

        public LoweredConstantPattern Update(LoweredExpression value, ConstantValue constantValue, TypeSymbol inputType)
        {
            if (value != this.Value || constantValue != this.ConstantValue || !TypeSymbol.Equals(inputType, this.InputType, TypeCompareKind.ConsiderEverything))
            {
                var result = new LoweredConstantPattern(this.Syntax, value, constantValue, inputType, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal sealed partial class LoweredDiscardPattern : LoweredPattern
    {
        public LoweredDiscardPattern(SyntaxNode syntax, TypeSymbol inputType, bool hasErrors)
            : base(LoweredKind.DiscardPattern, syntax, inputType, hasErrors)
        {

            RoslynDebug.Assert(inputType is object, "Field 'inputType' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

        }

        public LoweredDiscardPattern(SyntaxNode syntax, TypeSymbol inputType)
            : base(LoweredKind.DiscardPattern, syntax, inputType)
        {

            RoslynDebug.Assert(inputType is object, "Field 'inputType' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

        }

        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitDiscardPattern(this);

        public LoweredDiscardPattern Update(TypeSymbol inputType)
        {
            if (!TypeSymbol.Equals(inputType, this.InputType, TypeCompareKind.ConsiderEverything))
            {
                var result = new LoweredDiscardPattern(this.Syntax, inputType, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal sealed partial class LoweredDeclarationPattern : LoweredPattern
    {
        public LoweredDeclarationPattern(SyntaxNode syntax, Symbol? variable, LoweredExpression? variableAccess, LoweredTypeExpression? declaredType, bool isVar, TypeSymbol inputType, bool hasErrors = false)
            : base(LoweredKind.DeclarationPattern, syntax, inputType, hasErrors || variableAccess.HasErrors() || declaredType.HasErrors())
        {

            RoslynDebug.Assert(inputType is object, "Field 'inputType' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

            this.Variable = variable;
            this.VariableAccess = variableAccess;
            this.DeclaredType = declaredType;
            this.IsVar = isVar;
        }


        public Symbol? Variable { get; }

        public LoweredExpression? VariableAccess { get; }

        public LoweredTypeExpression? DeclaredType { get; }

        public bool IsVar { get; }
        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitDeclarationPattern(this);

        public LoweredDeclarationPattern Update(Symbol? variable, LoweredExpression? variableAccess, LoweredTypeExpression? declaredType, bool isVar, TypeSymbol inputType)
        {
            if (!Symbols.SymbolEqualityComparer.ConsiderEverything.Equals(variable, this.Variable) || variableAccess != this.VariableAccess || declaredType != this.DeclaredType || isVar != this.IsVar || !TypeSymbol.Equals(inputType, this.InputType, TypeCompareKind.ConsiderEverything))
            {
                var result = new LoweredDeclarationPattern(this.Syntax, variable, variableAccess, declaredType, isVar, inputType, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal sealed partial class LoweredRecursivePattern : LoweredPattern
    {
        public LoweredRecursivePattern(SyntaxNode syntax, LoweredTypeExpression? declaredType, MethodSymbol? deconstructMethod, ImmutableArray<LoweredSubpattern> deconstruction, ImmutableArray<LoweredSubpattern> properties, Symbol? variable, LoweredExpression? variableAccess, bool isExplicitNotNullTest, TypeSymbol inputType, bool hasErrors = false)
            : base(LoweredKind.RecursivePattern, syntax, inputType, hasErrors || declaredType.HasErrors() || deconstruction.HasErrors() || properties.HasErrors() || variableAccess.HasErrors())
        {

            RoslynDebug.Assert(inputType is object, "Field 'inputType' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

            this.DeclaredType = declaredType;
            this.DeconstructMethod = deconstructMethod;
            this.Deconstruction = deconstruction;
            this.Properties = properties;
            this.Variable = variable;
            this.VariableAccess = variableAccess;
            this.IsExplicitNotNullTest = isExplicitNotNullTest;
        }


        public LoweredTypeExpression? DeclaredType { get; }

        public MethodSymbol? DeconstructMethod { get; }

        public ImmutableArray<LoweredSubpattern> Deconstruction { get; }

        public ImmutableArray<LoweredSubpattern> Properties { get; }

        public Symbol? Variable { get; }

        public LoweredExpression? VariableAccess { get; }

        public bool IsExplicitNotNullTest { get; }
        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitRecursivePattern(this);

        public LoweredRecursivePattern Update(LoweredTypeExpression? declaredType, MethodSymbol? deconstructMethod, ImmutableArray<LoweredSubpattern> deconstruction, ImmutableArray<LoweredSubpattern> properties, Symbol? variable, LoweredExpression? variableAccess, bool isExplicitNotNullTest, TypeSymbol inputType)
        {
            if (declaredType != this.DeclaredType || !Symbols.SymbolEqualityComparer.ConsiderEverything.Equals(deconstructMethod, this.DeconstructMethod) || deconstruction != this.Deconstruction || properties != this.Properties || !Symbols.SymbolEqualityComparer.ConsiderEverything.Equals(variable, this.Variable) || variableAccess != this.VariableAccess || isExplicitNotNullTest != this.IsExplicitNotNullTest || !TypeSymbol.Equals(inputType, this.InputType, TypeCompareKind.ConsiderEverything))
            {
                var result = new LoweredRecursivePattern(this.Syntax, declaredType, deconstructMethod, deconstruction, properties, variable, variableAccess, isExplicitNotNullTest, inputType, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal sealed partial class LoweredITuplePattern : LoweredPattern
    {
        public LoweredITuplePattern(SyntaxNode syntax, MethodSymbol getLengthMethod, MethodSymbol getItemMethod, ImmutableArray<LoweredSubpattern> subpatterns, TypeSymbol inputType, bool hasErrors = false)
            : base(LoweredKind.ITuplePattern, syntax, inputType, hasErrors || subpatterns.HasErrors())
        {

            RoslynDebug.Assert(getLengthMethod is object, "Field 'getLengthMethod' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(getItemMethod is object, "Field 'getItemMethod' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(!subpatterns.IsDefault, "Field 'subpatterns' cannot be null (use Null=\"allow\" in LoweredNodes.xml to remove this check)");
            RoslynDebug.Assert(inputType is object, "Field 'inputType' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

            this.GetLengthMethod = getLengthMethod;
            this.GetItemMethod = getItemMethod;
            this.Subpatterns = subpatterns;
        }


        public MethodSymbol GetLengthMethod { get; }

        public MethodSymbol GetItemMethod { get; }

        public ImmutableArray<LoweredSubpattern> Subpatterns { get; }
        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitITuplePattern(this);

        public LoweredITuplePattern Update(MethodSymbol getLengthMethod, MethodSymbol getItemMethod, ImmutableArray<LoweredSubpattern> subpatterns, TypeSymbol inputType)
        {
            if (!Symbols.SymbolEqualityComparer.ConsiderEverything.Equals(getLengthMethod, this.GetLengthMethod) || !Symbols.SymbolEqualityComparer.ConsiderEverything.Equals(getItemMethod, this.GetItemMethod) || subpatterns != this.Subpatterns || !TypeSymbol.Equals(inputType, this.InputType, TypeCompareKind.ConsiderEverything))
            {
                var result = new LoweredITuplePattern(this.Syntax, getLengthMethod, getItemMethod, subpatterns, inputType, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal sealed partial class LoweredSubpattern : LoweredNode
    {
        public LoweredSubpattern(SyntaxNode syntax, Symbol? symbol, LoweredPattern pattern, bool hasErrors = false)
            : base(LoweredKind.Subpattern, syntax, hasErrors || pattern.HasErrors())
        {

            RoslynDebug.Assert(pattern is object, "Field 'pattern' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

            this.Symbol = symbol;
            this.Pattern = pattern;
        }


        public Symbol? Symbol { get; }

        public LoweredPattern Pattern { get; }
        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitSubpattern(this);

        public LoweredSubpattern Update(Symbol? symbol, LoweredPattern pattern)
        {
            if (!Symbols.SymbolEqualityComparer.ConsiderEverything.Equals(symbol, this.Symbol) || pattern != this.Pattern)
            {
                var result = new LoweredSubpattern(this.Syntax, symbol, pattern, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal sealed partial class LoweredDiscardExpression : LoweredExpression
    {
        public LoweredDiscardExpression(SyntaxNode syntax, TypeSymbol? type, bool hasErrors)
            : base(LoweredKind.DiscardExpression, syntax, type, hasErrors)
        {
        }

        public LoweredDiscardExpression(SyntaxNode syntax, TypeSymbol? type)
            : base(LoweredKind.DiscardExpression, syntax, type)
        {
        }


        public new TypeSymbol? Type => base.Type!;
        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitDiscardExpression(this);

        public LoweredDiscardExpression Update(TypeSymbol? type)
        {
            if (!TypeSymbol.Equals(type, this.Type, TypeCompareKind.ConsiderEverything))
            {
                var result = new LoweredDiscardExpression(this.Syntax, type, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal sealed partial class LoweredThrowExpression : LoweredExpression
    {
        public LoweredThrowExpression(SyntaxNode syntax, LoweredExpression expression, TypeSymbol? type, bool hasErrors = false)
            : base(LoweredKind.ThrowExpression, syntax, type, hasErrors || expression.HasErrors())
        {

            RoslynDebug.Assert(expression is object, "Field 'expression' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

            this.Expression = expression;
        }


        public LoweredExpression Expression { get; }
        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitThrowExpression(this);

        public LoweredThrowExpression Update(LoweredExpression expression, TypeSymbol? type)
        {
            if (expression != this.Expression || !TypeSymbol.Equals(type, this.Type, TypeCompareKind.ConsiderEverything))
            {
                var result = new LoweredThrowExpression(this.Syntax, expression, type, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal abstract partial class VariablePendingInference : LoweredExpression
    {
        protected VariablePendingInference(LoweredKind kind, SyntaxNode syntax, Symbol variableSymbol, LoweredExpression? receiverOpt, bool hasErrors = false)
            : base(kind, syntax, null, hasErrors)
        {

            RoslynDebug.Assert(variableSymbol is object, "Field 'variableSymbol' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

            this.VariableSymbol = variableSymbol;
            this.ReceiverOpt = receiverOpt;
        }


        public new TypeSymbol Type => base.Type!;

        public Symbol VariableSymbol { get; }

        public LoweredExpression? ReceiverOpt { get; }
    }

    internal sealed partial class OutVariablePendingInference : VariablePendingInference
    {
        public OutVariablePendingInference(SyntaxNode syntax, Symbol variableSymbol, LoweredExpression? receiverOpt, bool hasErrors = false)
            : base(LoweredKind.OutVariablePendingInference, syntax, variableSymbol, receiverOpt, hasErrors || receiverOpt.HasErrors())
        {

            RoslynDebug.Assert(variableSymbol is object, "Field 'variableSymbol' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

        }

        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitOutVariablePendingInference(this);

        public OutVariablePendingInference Update(Symbol variableSymbol, LoweredExpression? receiverOpt)
        {
            if (!Symbols.SymbolEqualityComparer.ConsiderEverything.Equals(variableSymbol, this.VariableSymbol) || receiverOpt != this.ReceiverOpt)
            {
                var result = new OutVariablePendingInference(this.Syntax, variableSymbol, receiverOpt, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal sealed partial class DeconstructionVariablePendingInference : VariablePendingInference
    {
        public DeconstructionVariablePendingInference(SyntaxNode syntax, Symbol variableSymbol, LoweredExpression? receiverOpt, bool hasErrors = false)
            : base(LoweredKind.DeconstructionVariablePendingInference, syntax, variableSymbol, receiverOpt, hasErrors || receiverOpt.HasErrors())
        {

            RoslynDebug.Assert(variableSymbol is object, "Field 'variableSymbol' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

        }

        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitDeconstructionVariablePendingInference(this);

        public DeconstructionVariablePendingInference Update(Symbol variableSymbol, LoweredExpression? receiverOpt)
        {
            if (!Symbols.SymbolEqualityComparer.ConsiderEverything.Equals(variableSymbol, this.VariableSymbol) || receiverOpt != this.ReceiverOpt)
            {
                var result = new DeconstructionVariablePendingInference(this.Syntax, variableSymbol, receiverOpt, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal sealed partial class OutDeconstructVarPendingInference : LoweredExpression
    {
        public OutDeconstructVarPendingInference(SyntaxNode syntax, bool hasErrors)
            : base(LoweredKind.OutDeconstructVarPendingInference, syntax, null, hasErrors)
        {
        }

        public OutDeconstructVarPendingInference(SyntaxNode syntax)
            : base(LoweredKind.OutDeconstructVarPendingInference, syntax, null)
        {
        }


        public new TypeSymbol Type => base.Type!;
        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitOutDeconstructVarPendingInference(this);

        public OutDeconstructVarPendingInference Update()
        {
            return this;
        }
    }

    internal abstract partial class LoweredMethodBodyBase : LoweredNode
    {
        protected LoweredMethodBodyBase(LoweredKind kind, SyntaxNode syntax, LoweredBlock? blockBody, LoweredBlock? expressionBody, bool hasErrors = false)
            : base(kind, syntax, hasErrors)
        {
            this.BlockBody = blockBody;
            this.ExpressionBody = expressionBody;
        }


        public LoweredBlock? BlockBody { get; }

        public LoweredBlock? ExpressionBody { get; }
    }

    internal sealed partial class LoweredNonConstructorMethodBody : LoweredMethodBodyBase
    {
        public LoweredNonConstructorMethodBody(SyntaxNode syntax, LoweredBlock? blockBody, LoweredBlock? expressionBody, bool hasErrors = false)
            : base(LoweredKind.NonConstructorMethodBody, syntax, blockBody, expressionBody, hasErrors || blockBody.HasErrors() || expressionBody.HasErrors())
        {
        }

        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitNonConstructorMethodBody(this);

        public LoweredNonConstructorMethodBody Update(LoweredBlock? blockBody, LoweredBlock? expressionBody)
        {
            if (blockBody != this.BlockBody || expressionBody != this.ExpressionBody)
            {
                var result = new LoweredNonConstructorMethodBody(this.Syntax, blockBody, expressionBody, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal sealed partial class LoweredConstructorMethodBody : LoweredMethodBodyBase
    {
        public LoweredConstructorMethodBody(SyntaxNode syntax, ImmutableArray<LocalSymbol> locals, LoweredExpressionStatement? initializer, LoweredBlock? blockBody, LoweredBlock? expressionBody, bool hasErrors = false)
            : base(LoweredKind.ConstructorMethodBody, syntax, blockBody, expressionBody, hasErrors || initializer.HasErrors() || blockBody.HasErrors() || expressionBody.HasErrors())
        {

            RoslynDebug.Assert(!locals.IsDefault, "Field 'locals' cannot be null (use Null=\"allow\" in LoweredNodes.xml to remove this check)");

            this.Locals = locals;
            this.Initializer = initializer;
        }


        public ImmutableArray<LocalSymbol> Locals { get; }

        public LoweredExpressionStatement? Initializer { get; }
        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitConstructorMethodBody(this);

        public LoweredConstructorMethodBody Update(ImmutableArray<LocalSymbol> locals, LoweredExpressionStatement? initializer, LoweredBlock? blockBody, LoweredBlock? expressionBody)
        {
            if (locals != this.Locals || initializer != this.Initializer || blockBody != this.BlockBody || expressionBody != this.ExpressionBody)
            {
                var result = new LoweredConstructorMethodBody(this.Syntax, locals, initializer, blockBody, expressionBody, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal sealed partial class LoweredExpressionWithNullability : LoweredExpression
    {
        public LoweredExpressionWithNullability(SyntaxNode syntax, LoweredExpression expression, NullableAnnotation nullableAnnotation, TypeSymbol? type, bool hasErrors = false)
            : base(LoweredKind.ExpressionWithNullability, syntax, type, hasErrors || expression.HasErrors())
        {

            RoslynDebug.Assert(expression is object, "Field 'expression' cannot be null (make the type nullable in LoweredNodes.xml to remove this check)");

            this.Expression = expression;
            this.NullableAnnotation = nullableAnnotation;
        }


        public LoweredExpression Expression { get; }

        public new TypeSymbol? Type => base.Type!;

        public NullableAnnotation NullableAnnotation { get; }
        [DebuggerStepThrough]
        public override LoweredNode? Accept(LoweredTreeVisitor visitor) => visitor.VisitExpressionWithNullability(this);

        public LoweredExpressionWithNullability Update(LoweredExpression expression, NullableAnnotation nullableAnnotation, TypeSymbol? type)
        {
            if (expression != this.Expression || nullableAnnotation != this.NullableAnnotation || !TypeSymbol.Equals(type, this.Type, TypeCompareKind.ConsiderEverything))
            {
                var result = new LoweredExpressionWithNullability(this.Syntax, expression, nullableAnnotation, type, this.HasErrors);
                result.CopyAttributes(this);
                return result;
            }
            return this;
        }
    }

    internal abstract partial class LoweredTreeVisitor<A,R>
    {

        [MethodImpl(MethodImplOptions.NoInlining), DebuggerStepThrough]
        internal R VisitInternal(LoweredNode node, A arg)
        {
            switch (node.Kind)
            {
                case LoweredKind.FieldEqualsValue: 
                    return VisitFieldEqualsValue((LoweredFieldEqualsValue)node, arg);
                case LoweredKind.PropertyEqualsValue: 
                    return VisitPropertyEqualsValue((LoweredPropertyEqualsValue)node, arg);
                case LoweredKind.ParameterEqualsValue: 
                    return VisitParameterEqualsValue((LoweredParameterEqualsValue)node, arg);
                case LoweredKind.GlobalStatementInitializer: 
                    return VisitGlobalStatementInitializer((LoweredGlobalStatementInitializer)node, arg);
                case LoweredKind.DeconstructValuePlaceholder: 
                    return VisitDeconstructValuePlaceholder((LoweredDeconstructValuePlaceholder)node, arg);
                case LoweredKind.TupleOperandPlaceholder: 
                    return VisitTupleOperandPlaceholder((LoweredTupleOperandPlaceholder)node, arg);
                case LoweredKind.AwaitableValuePlaceholder: 
                    return VisitAwaitableValuePlaceholder((LoweredAwaitableValuePlaceholder)node, arg);
                case LoweredKind.DisposableValuePlaceholder: 
                    return VisitDisposableValuePlaceholder((LoweredDisposableValuePlaceholder)node, arg);
                case LoweredKind.ObjectOrCollectionValuePlaceholder: 
                    return VisitObjectOrCollectionValuePlaceholder((LoweredObjectOrCollectionValuePlaceholder)node, arg);
                case LoweredKind.Dup: 
                    return VisitDup((LoweredDup)node, arg);
                case LoweredKind.PassByCopy: 
                    return VisitPassByCopy((LoweredPassByCopy)node, arg);
                case LoweredKind.BadExpression: 
                    return VisitBadExpression((LoweredBadExpression)node, arg);
                case LoweredKind.BadStatement: 
                    return VisitBadStatement((LoweredBadStatement)node, arg);
                case LoweredKind.ExtractedFinallyBlock: 
                    return VisitExtractedFinallyBlock((LoweredExtractedFinallyBlock)node, arg);
                case LoweredKind.TypeExpression: 
                    return VisitTypeExpression((LoweredTypeExpression)node, arg);
                case LoweredKind.TypeOrValueExpression: 
                    return VisitTypeOrValueExpression((LoweredTypeOrValueExpression)node, arg);
                case LoweredKind.NamespaceExpression: 
                    return VisitNamespaceExpression((LoweredNamespaceExpression)node, arg);
                case LoweredKind.UnaryOperator: 
                    return VisitUnaryOperator((LoweredUnaryOperator)node, arg);
                case LoweredKind.IncrementOperator: 
                    return VisitIncrementOperator((LoweredIncrementOperator)node, arg);
                case LoweredKind.AddressOfOperator: 
                    return VisitAddressOfOperator((LoweredAddressOfOperator)node, arg);
                case LoweredKind.PointerIndirectionOperator: 
                    return VisitPointerIndirectionOperator((LoweredPointerIndirectionOperator)node, arg);
                case LoweredKind.PointerElementAccess: 
                    return VisitPointerElementAccess((LoweredPointerElementAccess)node, arg);
                case LoweredKind.RefTypeOperator: 
                    return VisitRefTypeOperator((LoweredRefTypeOperator)node, arg);
                case LoweredKind.MakeRefOperator: 
                    return VisitMakeRefOperator((LoweredMakeRefOperator)node, arg);
                case LoweredKind.RefValueOperator: 
                    return VisitRefValueOperator((LoweredRefValueOperator)node, arg);
                case LoweredKind.FromEndIndexExpression: 
                    return VisitFromEndIndexExpression((LoweredFromEndIndexExpression)node, arg);
                case LoweredKind.RangeExpression: 
                    return VisitRangeExpression((LoweredRangeExpression)node, arg);
                case LoweredKind.BinaryOperator: 
                    return VisitBinaryOperator((LoweredBinaryOperator)node, arg);
                case LoweredKind.TupleBinaryOperator: 
                    return VisitTupleBinaryOperator((LoweredTupleBinaryOperator)node, arg);
                case LoweredKind.UserDefinedConditionalLogicalOperator: 
                    return VisitUserDefinedConditionalLogicalOperator((LoweredUserDefinedConditionalLogicalOperator)node, arg);
                case LoweredKind.CompoundAssignmentOperator: 
                    return VisitCompoundAssignmentOperator((LoweredCompoundAssignmentOperator)node, arg);
                case LoweredKind.AssignmentOperator: 
                    return VisitAssignmentOperator((LoweredAssignmentOperator)node, arg);
                case LoweredKind.DeconstructionAssignmentOperator: 
                    return VisitDeconstructionAssignmentOperator((LoweredDeconstructionAssignmentOperator)node, arg);
                case LoweredKind.NullCoalescingOperator: 
                    return VisitNullCoalescingOperator((LoweredNullCoalescingOperator)node, arg);
                case LoweredKind.NullCoalescingAssignmentOperator: 
                    return VisitNullCoalescingAssignmentOperator((LoweredNullCoalescingAssignmentOperator)node, arg);
                case LoweredKind.ConditionalOperator: 
                    return VisitConditionalOperator((LoweredConditionalOperator)node, arg);
                case LoweredKind.ArrayAccess: 
                    return VisitArrayAccess((LoweredArrayAccess)node, arg);
                case LoweredKind.ArrayLength: 
                    return VisitArrayLength((LoweredArrayLength)node, arg);
                case LoweredKind.AwaitableInfo: 
                    return VisitAwaitableInfo((LoweredAwaitableInfo)node, arg);
                case LoweredKind.AwaitExpression: 
                    return VisitAwaitExpression((LoweredAwaitExpression)node, arg);
                case LoweredKind.TypeOfOperator: 
                    return VisitTypeOfOperator((LoweredTypeOfOperator)node, arg);
                case LoweredKind.MethodDefIndex: 
                    return VisitMethodDefIndex((LoweredMethodDefIndex)node, arg);
                case LoweredKind.MaximumMethodDefIndex: 
                    return VisitMaximumMethodDefIndex((LoweredMaximumMethodDefIndex)node, arg);
                case LoweredKind.InstrumentationPayloadRoot: 
                    return VisitInstrumentationPayloadRoot((LoweredInstrumentationPayloadRoot)node, arg);
                case LoweredKind.ModuleVersionId: 
                    return VisitModuleVersionId((LoweredModuleVersionId)node, arg);
                case LoweredKind.ModuleVersionIdString: 
                    return VisitModuleVersionIdString((LoweredModuleVersionIdString)node, arg);
                case LoweredKind.SourceDocumentIndex: 
                    return VisitSourceDocumentIndex((LoweredSourceDocumentIndex)node, arg);
                case LoweredKind.MethodInfo: 
                    return VisitMethodInfo((LoweredMethodInfo)node, arg);
                case LoweredKind.FieldInfo: 
                    return VisitFieldInfo((LoweredFieldInfo)node, arg);
                case LoweredKind.DefaultLiteral: 
                    return VisitDefaultLiteral((LoweredDefaultLiteral)node, arg);
                case LoweredKind.DefaultExpression: 
                    return VisitDefaultExpression((LoweredDefaultExpression)node, arg);
                case LoweredKind.IsOperator: 
                    return VisitIsOperator((LoweredIsOperator)node, arg);
                case LoweredKind.AsOperator: 
                    return VisitAsOperator((LoweredAsOperator)node, arg);
                case LoweredKind.SizeOfOperator: 
                    return VisitSizeOfOperator((LoweredSizeOfOperator)node, arg);
                case LoweredKind.Conversion: 
                    return VisitConversion((LoweredConversion)node, arg);
                case LoweredKind.ReadOnlySpanFromArray: 
                    return VisitReadOnlySpanFromArray((LoweredReadOnlySpanFromArray)node, arg);
                case LoweredKind.ArgList: 
                    return VisitArgList((LoweredArgList)node, arg);
                case LoweredKind.ArgListOperator: 
                    return VisitArgListOperator((LoweredArgListOperator)node, arg);
                case LoweredKind.FixedLocalCollectionInitializer: 
                    return VisitFixedLocalCollectionInitializer((LoweredFixedLocalCollectionInitializer)node, arg);
                case LoweredKind.SequencePoint: 
                    return VisitSequencePoint((LoweredSequencePoint)node, arg);
                case LoweredKind.SequencePointWithSpan: 
                    return VisitSequencePointWithSpan((LoweredSequencePointWithSpan)node, arg);
                case LoweredKind.Block: 
                    return VisitBlock((LoweredBlock)node, arg);
                case LoweredKind.Scope: 
                    return VisitScope((LoweredScope)node, arg);
                case LoweredKind.StateMachineScope: 
                    return VisitStateMachineScope((LoweredStateMachineScope)node, arg);
                case LoweredKind.LocalDeclaration: 
                    return VisitLocalDeclaration((LoweredLocalDeclaration)node, arg);
                case LoweredKind.MultipleLocalDeclarations: 
                    return VisitMultipleLocalDeclarations((LoweredMultipleLocalDeclarations)node, arg);
                case LoweredKind.UsingLocalDeclarations: 
                    return VisitUsingLocalDeclarations((LoweredUsingLocalDeclarations)node, arg);
                case LoweredKind.LocalFunctionStatement: 
                    return VisitLocalFunctionStatement((LoweredLocalFunctionStatement)node, arg);
                case LoweredKind.NoOpStatement: 
                    return VisitNoOpStatement((LoweredNoOpStatement)node, arg);
                case LoweredKind.ReturnStatement: 
                    return VisitReturnStatement((LoweredReturnStatement)node, arg);
                case LoweredKind.YieldReturnStatement: 
                    return VisitYieldReturnStatement((LoweredYieldReturnStatement)node, arg);
                case LoweredKind.YieldBreakStatement: 
                    return VisitYieldBreakStatement((LoweredYieldBreakStatement)node, arg);
                case LoweredKind.ThrowStatement: 
                    return VisitThrowStatement((LoweredThrowStatement)node, arg);
                case LoweredKind.ExpressionStatement: 
                    return VisitExpressionStatement((LoweredExpressionStatement)node, arg);
                case LoweredKind.BreakStatement: 
                    return VisitBreakStatement((LoweredBreakStatement)node, arg);
                case LoweredKind.ContinueStatement: 
                    return VisitContinueStatement((LoweredContinueStatement)node, arg);
                case LoweredKind.SwitchStatement: 
                    return VisitSwitchStatement((LoweredSwitchStatement)node, arg);
                case LoweredKind.SwitchDispatch: 
                    return VisitSwitchDispatch((LoweredSwitchDispatch)node, arg);
                case LoweredKind.IfStatement: 
                    return VisitIfStatement((LoweredIfStatement)node, arg);
                case LoweredKind.DoStatement: 
                    return VisitDoStatement((LoweredDoStatement)node, arg);
                case LoweredKind.WhileStatement: 
                    return VisitWhileStatement((LoweredWhileStatement)node, arg);
                case LoweredKind.ForStatement: 
                    return VisitForStatement((LoweredForStatement)node, arg);
                case LoweredKind.ForEachStatement: 
                    return VisitForEachStatement((LoweredForEachStatement)node, arg);
                case LoweredKind.ForEachDeconstructStep: 
                    return VisitForEachDeconstructStep((LoweredForEachDeconstructStep)node, arg);
                case LoweredKind.UsingStatement: 
                    return VisitUsingStatement((LoweredUsingStatement)node, arg);
                case LoweredKind.FixedStatement: 
                    return VisitFixedStatement((LoweredFixedStatement)node, arg);
                case LoweredKind.LockStatement: 
                    return VisitLockStatement((LoweredLockStatement)node, arg);
                case LoweredKind.TryStatement: 
                    return VisitTryStatement((LoweredTryStatement)node, arg);
                case LoweredKind.CatchBlock: 
                    return VisitCatchBlock((LoweredCatchBlock)node, arg);
                case LoweredKind.Literal: 
                    return VisitLiteral((LoweredLiteral)node, arg);
                case LoweredKind.ThisReference: 
                    return VisitThisReference((LoweredThisReference)node, arg);
                case LoweredKind.PreviousSubmissionReference: 
                    return VisitPreviousSubmissionReference((LoweredPreviousSubmissionReference)node, arg);
                case LoweredKind.HostObjectMemberReference: 
                    return VisitHostObjectMemberReference((LoweredHostObjectMemberReference)node, arg);
                case LoweredKind.BaseReference: 
                    return VisitBaseReference((LoweredBaseReference)node, arg);
                case LoweredKind.Local: 
                    return VisitLocal((LoweredLocal)node, arg);
                case LoweredKind.PseudoVariable: 
                    return VisitPseudoVariable((LoweredPseudoVariable)node, arg);
                case LoweredKind.RangeVariable: 
                    return VisitRangeVariable((LoweredRangeVariable)node, arg);
                case LoweredKind.Parameter: 
                    return VisitParameter((LoweredParameter)node, arg);
                case LoweredKind.LabelStatement: 
                    return VisitLabelStatement((LoweredLabelStatement)node, arg);
                case LoweredKind.GotoStatement: 
                    return VisitGotoStatement((LoweredGotoStatement)node, arg);
                case LoweredKind.LabeledStatement: 
                    return VisitLabeledStatement((LoweredLabeledStatement)node, arg);
                case LoweredKind.Label: 
                    return VisitLabel((LoweredLabel)node, arg);
                case LoweredKind.StatementList: 
                    return VisitStatementList((LoweredStatementList)node, arg);
                case LoweredKind.ConditionalGoto: 
                    return VisitConditionalGoto((LoweredConditionalGoto)node, arg);
                case LoweredKind.SwitchExpressionArm: 
                    return VisitSwitchExpressionArm((LoweredSwitchExpressionArm)node, arg);
                case LoweredKind.UnconvertedSwitchExpression: 
                    return VisitUnconvertedSwitchExpression((LoweredUnconvertedSwitchExpression)node, arg);
                case LoweredKind.ConvertedSwitchExpression: 
                    return VisitConvertedSwitchExpression((LoweredConvertedSwitchExpression)node, arg);
                case LoweredKind.DecisionDag: 
                    return VisitDecisionDag((LoweredDecisionDag)node, arg);
                case LoweredKind.EvaluationDecisionDagNode: 
                    return VisitEvaluationDecisionDagNode((LoweredEvaluationDecisionDagNode)node, arg);
                case LoweredKind.TestDecisionDagNode: 
                    return VisitTestDecisionDagNode((LoweredTestDecisionDagNode)node, arg);
                case LoweredKind.WhenDecisionDagNode: 
                    return VisitWhenDecisionDagNode((LoweredWhenDecisionDagNode)node, arg);
                case LoweredKind.LeafDecisionDagNode: 
                    return VisitLeafDecisionDagNode((LoweredLeafDecisionDagNode)node, arg);
                case LoweredKind.DagTemp: 
                    return VisitDagTemp((LoweredDagTemp)node, arg);
                case LoweredKind.DagTypeTest: 
                    return VisitDagTypeTest((LoweredDagTypeTest)node, arg);
                case LoweredKind.DagNonNullTest: 
                    return VisitDagNonNullTest((LoweredDagNonNullTest)node, arg);
                case LoweredKind.DagExplicitNullTest: 
                    return VisitDagExplicitNullTest((LoweredDagExplicitNullTest)node, arg);
                case LoweredKind.DagValueTest: 
                    return VisitDagValueTest((LoweredDagValueTest)node, arg);
                case LoweredKind.DagDeconstructEvaluation: 
                    return VisitDagDeconstructEvaluation((LoweredDagDeconstructEvaluation)node, arg);
                case LoweredKind.DagTypeEvaluation: 
                    return VisitDagTypeEvaluation((LoweredDagTypeEvaluation)node, arg);
                case LoweredKind.DagFieldEvaluation: 
                    return VisitDagFieldEvaluation((LoweredDagFieldEvaluation)node, arg);
                case LoweredKind.DagPropertyEvaluation: 
                    return VisitDagPropertyEvaluation((LoweredDagPropertyEvaluation)node, arg);
                case LoweredKind.DagIndexEvaluation: 
                    return VisitDagIndexEvaluation((LoweredDagIndexEvaluation)node, arg);
                case LoweredKind.SwitchSection: 
                    return VisitSwitchSection((LoweredSwitchSection)node, arg);
                case LoweredKind.SwitchLabel: 
                    return VisitSwitchLabel((LoweredSwitchLabel)node, arg);
                case LoweredKind.SequencePointExpression: 
                    return VisitSequencePointExpression((LoweredSequencePointExpression)node, arg);
                case LoweredKind.Sequence: 
                    return VisitSequence((LoweredSequence)node, arg);
                case LoweredKind.SpillSequence: 
                    return VisitSpillSequence((LoweredSpillSequence)node, arg);
                case LoweredKind.DynamicMemberAccess: 
                    return VisitDynamicMemberAccess((LoweredDynamicMemberAccess)node, arg);
                case LoweredKind.DynamicInvocation: 
                    return VisitDynamicInvocation((LoweredDynamicInvocation)node, arg);
                case LoweredKind.ConditionalAccess: 
                    return VisitConditionalAccess((LoweredConditionalAccess)node, arg);
                case LoweredKind.LoweredConditionalAccess: 
                    return VisitLoweredConditionalAccess((LoweredLoweredConditionalAccess)node, arg);
                case LoweredKind.ConditionalReceiver: 
                    return VisitConditionalReceiver((LoweredConditionalReceiver)node, arg);
                case LoweredKind.ComplexConditionalReceiver: 
                    return VisitComplexConditionalReceiver((LoweredComplexConditionalReceiver)node, arg);
                case LoweredKind.MethodGroup: 
                    return VisitMethodGroup((LoweredMethodGroup)node, arg);
                case LoweredKind.PropertyGroup: 
                    return VisitPropertyGroup((LoweredPropertyGroup)node, arg);
                case LoweredKind.Call: 
                    return VisitCall((LoweredCall)node, arg);
                case LoweredKind.EventAssignmentOperator: 
                    return VisitEventAssignmentOperator((LoweredEventAssignmentOperator)node, arg);
                case LoweredKind.Attribute: 
                    return VisitAttribute((LoweredAttribute)node, arg);
                case LoweredKind.ObjectCreationExpression: 
                    return VisitObjectCreationExpression((LoweredObjectCreationExpression)node, arg);
                case LoweredKind.TupleLiteral: 
                    return VisitTupleLiteral((LoweredTupleLiteral)node, arg);
                case LoweredKind.ConvertedTupleLiteral: 
                    return VisitConvertedTupleLiteral((LoweredConvertedTupleLiteral)node, arg);
                case LoweredKind.DynamicObjectCreationExpression: 
                    return VisitDynamicObjectCreationExpression((LoweredDynamicObjectCreationExpression)node, arg);
                case LoweredKind.NoPiaObjectCreationExpression: 
                    return VisitNoPiaObjectCreationExpression((LoweredNoPiaObjectCreationExpression)node, arg);
                case LoweredKind.ObjectInitializerExpression: 
                    return VisitObjectInitializerExpression((LoweredObjectInitializerExpression)node, arg);
                case LoweredKind.ObjectInitializerMember: 
                    return VisitObjectInitializerMember((LoweredObjectInitializerMember)node, arg);
                case LoweredKind.DynamicObjectInitializerMember: 
                    return VisitDynamicObjectInitializerMember((LoweredDynamicObjectInitializerMember)node, arg);
                case LoweredKind.CollectionInitializerExpression: 
                    return VisitCollectionInitializerExpression((LoweredCollectionInitializerExpression)node, arg);
                case LoweredKind.CollectionElementInitializer: 
                    return VisitCollectionElementInitializer((LoweredCollectionElementInitializer)node, arg);
                case LoweredKind.DynamicCollectionElementInitializer: 
                    return VisitDynamicCollectionElementInitializer((LoweredDynamicCollectionElementInitializer)node, arg);
                case LoweredKind.ImplicitReceiver: 
                    return VisitImplicitReceiver((LoweredImplicitReceiver)node, arg);
                case LoweredKind.AnonymousObjectCreationExpression: 
                    return VisitAnonymousObjectCreationExpression((LoweredAnonymousObjectCreationExpression)node, arg);
                case LoweredKind.AnonymousPropertyDeclaration: 
                    return VisitAnonymousPropertyDeclaration((LoweredAnonymousPropertyDeclaration)node, arg);
                case LoweredKind.NewT: 
                    return VisitNewT((LoweredNewT)node, arg);
                case LoweredKind.DelegateCreationExpression: 
                    return VisitDelegateCreationExpression((LoweredDelegateCreationExpression)node, arg);
                case LoweredKind.ArrayCreation: 
                    return VisitArrayCreation((LoweredArrayCreation)node, arg);
                case LoweredKind.ArrayInitialization: 
                    return VisitArrayInitialization((LoweredArrayInitialization)node, arg);
                case LoweredKind.StackAllocArrayCreation: 
                    return VisitStackAllocArrayCreation((LoweredStackAllocArrayCreation)node, arg);
                case LoweredKind.ConvertedStackAllocExpression: 
                    return VisitConvertedStackAllocExpression((LoweredConvertedStackAllocExpression)node, arg);
                case LoweredKind.FieldAccess: 
                    return VisitFieldAccess((LoweredFieldAccess)node, arg);
                case LoweredKind.HoistedFieldAccess: 
                    return VisitHoistedFieldAccess((LoweredHoistedFieldAccess)node, arg);
                case LoweredKind.PropertyAccess: 
                    return VisitPropertyAccess((LoweredPropertyAccess)node, arg);
                case LoweredKind.EventAccess: 
                    return VisitEventAccess((LoweredEventAccess)node, arg);
                case LoweredKind.IndexerAccess: 
                    return VisitIndexerAccess((LoweredIndexerAccess)node, arg);
                case LoweredKind.IndexOrRangePatternIndexerAccess: 
                    return VisitIndexOrRangePatternIndexerAccess((LoweredIndexOrRangePatternIndexerAccess)node, arg);
                case LoweredKind.DynamicIndexerAccess: 
                    return VisitDynamicIndexerAccess((LoweredDynamicIndexerAccess)node, arg);
                case LoweredKind.Lambda: 
                    return VisitLambda((LoweredLambda)node, arg);
                case LoweredKind.UnboundLambda: 
                    return VisitUnboundLambda((UnboundLambda)node, arg);
                case LoweredKind.QueryClause: 
                    return VisitQueryClause((LoweredQueryClause)node, arg);
                case LoweredKind.TypeOrInstanceInitializers: 
                    return VisitTypeOrInstanceInitializers((LoweredTypeOrInstanceInitializers)node, arg);
                case LoweredKind.NameOfOperator: 
                    return VisitNameOfOperator((LoweredNameOfOperator)node, arg);
                case LoweredKind.InterpolatedString: 
                    return VisitInterpolatedString((LoweredInterpolatedString)node, arg);
                case LoweredKind.StringInsert: 
                    return VisitStringInsert((LoweredStringInsert)node, arg);
                case LoweredKind.IsPatternExpression: 
                    return VisitIsPatternExpression((LoweredIsPatternExpression)node, arg);
                case LoweredKind.ConstantPattern: 
                    return VisitConstantPattern((LoweredConstantPattern)node, arg);
                case LoweredKind.DiscardPattern: 
                    return VisitDiscardPattern((LoweredDiscardPattern)node, arg);
                case LoweredKind.DeclarationPattern: 
                    return VisitDeclarationPattern((LoweredDeclarationPattern)node, arg);
                case LoweredKind.RecursivePattern: 
                    return VisitRecursivePattern((LoweredRecursivePattern)node, arg);
                case LoweredKind.ITuplePattern: 
                    return VisitITuplePattern((LoweredITuplePattern)node, arg);
                case LoweredKind.Subpattern: 
                    return VisitSubpattern((LoweredSubpattern)node, arg);
                case LoweredKind.DiscardExpression: 
                    return VisitDiscardExpression((LoweredDiscardExpression)node, arg);
                case LoweredKind.ThrowExpression: 
                    return VisitThrowExpression((LoweredThrowExpression)node, arg);
                case LoweredKind.OutVariablePendingInference: 
                    return VisitOutVariablePendingInference((OutVariablePendingInference)node, arg);
                case LoweredKind.DeconstructionVariablePendingInference: 
                    return VisitDeconstructionVariablePendingInference((DeconstructionVariablePendingInference)node, arg);
                case LoweredKind.OutDeconstructVarPendingInference: 
                    return VisitOutDeconstructVarPendingInference((OutDeconstructVarPendingInference)node, arg);
                case LoweredKind.NonConstructorMethodBody: 
                    return VisitNonConstructorMethodBody((LoweredNonConstructorMethodBody)node, arg);
                case LoweredKind.ConstructorMethodBody: 
                    return VisitConstructorMethodBody((LoweredConstructorMethodBody)node, arg);
                case LoweredKind.ExpressionWithNullability: 
                    return VisitExpressionWithNullability((LoweredExpressionWithNullability)node, arg);
            }

            return default(R)!;
        }
    }

    internal abstract partial class LoweredTreeVisitor<A,R>
    {
        public virtual R VisitFieldEqualsValue(LoweredFieldEqualsValue node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitPropertyEqualsValue(LoweredPropertyEqualsValue node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitParameterEqualsValue(LoweredParameterEqualsValue node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitGlobalStatementInitializer(LoweredGlobalStatementInitializer node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitDeconstructValuePlaceholder(LoweredDeconstructValuePlaceholder node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitTupleOperandPlaceholder(LoweredTupleOperandPlaceholder node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitAwaitableValuePlaceholder(LoweredAwaitableValuePlaceholder node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitDisposableValuePlaceholder(LoweredDisposableValuePlaceholder node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitObjectOrCollectionValuePlaceholder(LoweredObjectOrCollectionValuePlaceholder node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitDup(LoweredDup node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitPassByCopy(LoweredPassByCopy node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitBadExpression(LoweredBadExpression node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitBadStatement(LoweredBadStatement node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitExtractedFinallyBlock(LoweredExtractedFinallyBlock node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitTypeExpression(LoweredTypeExpression node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitTypeOrValueExpression(LoweredTypeOrValueExpression node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitNamespaceExpression(LoweredNamespaceExpression node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitUnaryOperator(LoweredUnaryOperator node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitIncrementOperator(LoweredIncrementOperator node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitAddressOfOperator(LoweredAddressOfOperator node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitPointerIndirectionOperator(LoweredPointerIndirectionOperator node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitPointerElementAccess(LoweredPointerElementAccess node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitRefTypeOperator(LoweredRefTypeOperator node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitMakeRefOperator(LoweredMakeRefOperator node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitRefValueOperator(LoweredRefValueOperator node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitFromEndIndexExpression(LoweredFromEndIndexExpression node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitRangeExpression(LoweredRangeExpression node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitBinaryOperator(LoweredBinaryOperator node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitTupleBinaryOperator(LoweredTupleBinaryOperator node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitUserDefinedConditionalLogicalOperator(LoweredUserDefinedConditionalLogicalOperator node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitCompoundAssignmentOperator(LoweredCompoundAssignmentOperator node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitAssignmentOperator(LoweredAssignmentOperator node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitDeconstructionAssignmentOperator(LoweredDeconstructionAssignmentOperator node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitNullCoalescingOperator(LoweredNullCoalescingOperator node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitNullCoalescingAssignmentOperator(LoweredNullCoalescingAssignmentOperator node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitConditionalOperator(LoweredConditionalOperator node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitArrayAccess(LoweredArrayAccess node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitArrayLength(LoweredArrayLength node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitAwaitableInfo(LoweredAwaitableInfo node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitAwaitExpression(LoweredAwaitExpression node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitTypeOfOperator(LoweredTypeOfOperator node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitMethodDefIndex(LoweredMethodDefIndex node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitMaximumMethodDefIndex(LoweredMaximumMethodDefIndex node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitInstrumentationPayloadRoot(LoweredInstrumentationPayloadRoot node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitModuleVersionId(LoweredModuleVersionId node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitModuleVersionIdString(LoweredModuleVersionIdString node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitSourceDocumentIndex(LoweredSourceDocumentIndex node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitMethodInfo(LoweredMethodInfo node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitFieldInfo(LoweredFieldInfo node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitDefaultLiteral(LoweredDefaultLiteral node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitDefaultExpression(LoweredDefaultExpression node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitIsOperator(LoweredIsOperator node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitAsOperator(LoweredAsOperator node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitSizeOfOperator(LoweredSizeOfOperator node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitConversion(LoweredConversion node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitReadOnlySpanFromArray(LoweredReadOnlySpanFromArray node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitArgList(LoweredArgList node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitArgListOperator(LoweredArgListOperator node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitFixedLocalCollectionInitializer(LoweredFixedLocalCollectionInitializer node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitSequencePoint(LoweredSequencePoint node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitSequencePointWithSpan(LoweredSequencePointWithSpan node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitBlock(LoweredBlock node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitScope(LoweredScope node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitStateMachineScope(LoweredStateMachineScope node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitLocalDeclaration(LoweredLocalDeclaration node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitMultipleLocalDeclarations(LoweredMultipleLocalDeclarations node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitUsingLocalDeclarations(LoweredUsingLocalDeclarations node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitLocalFunctionStatement(LoweredLocalFunctionStatement node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitNoOpStatement(LoweredNoOpStatement node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitReturnStatement(LoweredReturnStatement node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitYieldReturnStatement(LoweredYieldReturnStatement node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitYieldBreakStatement(LoweredYieldBreakStatement node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitThrowStatement(LoweredThrowStatement node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitExpressionStatement(LoweredExpressionStatement node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitBreakStatement(LoweredBreakStatement node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitContinueStatement(LoweredContinueStatement node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitSwitchStatement(LoweredSwitchStatement node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitSwitchDispatch(LoweredSwitchDispatch node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitIfStatement(LoweredIfStatement node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitDoStatement(LoweredDoStatement node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitWhileStatement(LoweredWhileStatement node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitForStatement(LoweredForStatement node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitForEachStatement(LoweredForEachStatement node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitForEachDeconstructStep(LoweredForEachDeconstructStep node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitUsingStatement(LoweredUsingStatement node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitFixedStatement(LoweredFixedStatement node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitLockStatement(LoweredLockStatement node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitTryStatement(LoweredTryStatement node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitCatchBlock(LoweredCatchBlock node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitLiteral(LoweredLiteral node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitThisReference(LoweredThisReference node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitPreviousSubmissionReference(LoweredPreviousSubmissionReference node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitHostObjectMemberReference(LoweredHostObjectMemberReference node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitBaseReference(LoweredBaseReference node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitLocal(LoweredLocal node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitPseudoVariable(LoweredPseudoVariable node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitRangeVariable(LoweredRangeVariable node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitParameter(LoweredParameter node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitLabelStatement(LoweredLabelStatement node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitGotoStatement(LoweredGotoStatement node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitLabeledStatement(LoweredLabeledStatement node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitLabel(LoweredLabel node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitStatementList(LoweredStatementList node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitConditionalGoto(LoweredConditionalGoto node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitSwitchExpressionArm(LoweredSwitchExpressionArm node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitUnconvertedSwitchExpression(LoweredUnconvertedSwitchExpression node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitConvertedSwitchExpression(LoweredConvertedSwitchExpression node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitDecisionDag(LoweredDecisionDag node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitEvaluationDecisionDagNode(LoweredEvaluationDecisionDagNode node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitTestDecisionDagNode(LoweredTestDecisionDagNode node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitWhenDecisionDagNode(LoweredWhenDecisionDagNode node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitLeafDecisionDagNode(LoweredLeafDecisionDagNode node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitDagTemp(LoweredDagTemp node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitDagTypeTest(LoweredDagTypeTest node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitDagNonNullTest(LoweredDagNonNullTest node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitDagExplicitNullTest(LoweredDagExplicitNullTest node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitDagValueTest(LoweredDagValueTest node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitDagDeconstructEvaluation(LoweredDagDeconstructEvaluation node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitDagTypeEvaluation(LoweredDagTypeEvaluation node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitDagFieldEvaluation(LoweredDagFieldEvaluation node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitDagPropertyEvaluation(LoweredDagPropertyEvaluation node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitDagIndexEvaluation(LoweredDagIndexEvaluation node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitSwitchSection(LoweredSwitchSection node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitSwitchLabel(LoweredSwitchLabel node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitSequencePointExpression(LoweredSequencePointExpression node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitSequence(LoweredSequence node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitSpillSequence(LoweredSpillSequence node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitDynamicMemberAccess(LoweredDynamicMemberAccess node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitDynamicInvocation(LoweredDynamicInvocation node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitConditionalAccess(LoweredConditionalAccess node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitLoweredConditionalAccess(LoweredLoweredConditionalAccess node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitConditionalReceiver(LoweredConditionalReceiver node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitComplexConditionalReceiver(LoweredComplexConditionalReceiver node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitMethodGroup(LoweredMethodGroup node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitPropertyGroup(LoweredPropertyGroup node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitCall(LoweredCall node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitEventAssignmentOperator(LoweredEventAssignmentOperator node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitAttribute(LoweredAttribute node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitObjectCreationExpression(LoweredObjectCreationExpression node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitTupleLiteral(LoweredTupleLiteral node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitConvertedTupleLiteral(LoweredConvertedTupleLiteral node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitDynamicObjectCreationExpression(LoweredDynamicObjectCreationExpression node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitNoPiaObjectCreationExpression(LoweredNoPiaObjectCreationExpression node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitObjectInitializerExpression(LoweredObjectInitializerExpression node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitObjectInitializerMember(LoweredObjectInitializerMember node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitDynamicObjectInitializerMember(LoweredDynamicObjectInitializerMember node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitCollectionInitializerExpression(LoweredCollectionInitializerExpression node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitCollectionElementInitializer(LoweredCollectionElementInitializer node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitDynamicCollectionElementInitializer(LoweredDynamicCollectionElementInitializer node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitImplicitReceiver(LoweredImplicitReceiver node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitAnonymousObjectCreationExpression(LoweredAnonymousObjectCreationExpression node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitAnonymousPropertyDeclaration(LoweredAnonymousPropertyDeclaration node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitNewT(LoweredNewT node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitDelegateCreationExpression(LoweredDelegateCreationExpression node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitArrayCreation(LoweredArrayCreation node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitArrayInitialization(LoweredArrayInitialization node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitStackAllocArrayCreation(LoweredStackAllocArrayCreation node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitConvertedStackAllocExpression(LoweredConvertedStackAllocExpression node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitFieldAccess(LoweredFieldAccess node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitHoistedFieldAccess(LoweredHoistedFieldAccess node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitPropertyAccess(LoweredPropertyAccess node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitEventAccess(LoweredEventAccess node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitIndexerAccess(LoweredIndexerAccess node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitIndexOrRangePatternIndexerAccess(LoweredIndexOrRangePatternIndexerAccess node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitDynamicIndexerAccess(LoweredDynamicIndexerAccess node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitLambda(LoweredLambda node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitUnboundLambda(UnboundLambda node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitQueryClause(LoweredQueryClause node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitTypeOrInstanceInitializers(LoweredTypeOrInstanceInitializers node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitNameOfOperator(LoweredNameOfOperator node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitInterpolatedString(LoweredInterpolatedString node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitStringInsert(LoweredStringInsert node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitIsPatternExpression(LoweredIsPatternExpression node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitConstantPattern(LoweredConstantPattern node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitDiscardPattern(LoweredDiscardPattern node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitDeclarationPattern(LoweredDeclarationPattern node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitRecursivePattern(LoweredRecursivePattern node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitITuplePattern(LoweredITuplePattern node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitSubpattern(LoweredSubpattern node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitDiscardExpression(LoweredDiscardExpression node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitThrowExpression(LoweredThrowExpression node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitOutVariablePendingInference(OutVariablePendingInference node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitDeconstructionVariablePendingInference(DeconstructionVariablePendingInference node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitOutDeconstructVarPendingInference(OutDeconstructVarPendingInference node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitNonConstructorMethodBody(LoweredNonConstructorMethodBody node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitConstructorMethodBody(LoweredConstructorMethodBody node, A arg) => this.DefaultVisit(node, arg);
        public virtual R VisitExpressionWithNullability(LoweredExpressionWithNullability node, A arg) => this.DefaultVisit(node, arg);
    }

    internal abstract partial class LoweredTreeVisitor
    {
        public virtual LoweredNode? VisitFieldEqualsValue(LoweredFieldEqualsValue node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitPropertyEqualsValue(LoweredPropertyEqualsValue node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitParameterEqualsValue(LoweredParameterEqualsValue node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitGlobalStatementInitializer(LoweredGlobalStatementInitializer node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitDeconstructValuePlaceholder(LoweredDeconstructValuePlaceholder node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitTupleOperandPlaceholder(LoweredTupleOperandPlaceholder node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitAwaitableValuePlaceholder(LoweredAwaitableValuePlaceholder node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitDisposableValuePlaceholder(LoweredDisposableValuePlaceholder node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitObjectOrCollectionValuePlaceholder(LoweredObjectOrCollectionValuePlaceholder node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitDup(LoweredDup node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitPassByCopy(LoweredPassByCopy node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitBadExpression(LoweredBadExpression node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitBadStatement(LoweredBadStatement node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitExtractedFinallyBlock(LoweredExtractedFinallyBlock node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitTypeExpression(LoweredTypeExpression node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitTypeOrValueExpression(LoweredTypeOrValueExpression node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitNamespaceExpression(LoweredNamespaceExpression node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitUnaryOperator(LoweredUnaryOperator node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitIncrementOperator(LoweredIncrementOperator node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitAddressOfOperator(LoweredAddressOfOperator node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitPointerIndirectionOperator(LoweredPointerIndirectionOperator node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitPointerElementAccess(LoweredPointerElementAccess node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitRefTypeOperator(LoweredRefTypeOperator node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitMakeRefOperator(LoweredMakeRefOperator node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitRefValueOperator(LoweredRefValueOperator node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitFromEndIndexExpression(LoweredFromEndIndexExpression node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitRangeExpression(LoweredRangeExpression node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitBinaryOperator(LoweredBinaryOperator node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitTupleBinaryOperator(LoweredTupleBinaryOperator node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitUserDefinedConditionalLogicalOperator(LoweredUserDefinedConditionalLogicalOperator node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitCompoundAssignmentOperator(LoweredCompoundAssignmentOperator node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitAssignmentOperator(LoweredAssignmentOperator node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitDeconstructionAssignmentOperator(LoweredDeconstructionAssignmentOperator node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitNullCoalescingOperator(LoweredNullCoalescingOperator node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitNullCoalescingAssignmentOperator(LoweredNullCoalescingAssignmentOperator node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitConditionalOperator(LoweredConditionalOperator node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitArrayAccess(LoweredArrayAccess node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitArrayLength(LoweredArrayLength node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitAwaitableInfo(LoweredAwaitableInfo node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitAwaitExpression(LoweredAwaitExpression node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitTypeOfOperator(LoweredTypeOfOperator node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitMethodDefIndex(LoweredMethodDefIndex node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitMaximumMethodDefIndex(LoweredMaximumMethodDefIndex node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitInstrumentationPayloadRoot(LoweredInstrumentationPayloadRoot node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitModuleVersionId(LoweredModuleVersionId node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitModuleVersionIdString(LoweredModuleVersionIdString node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitSourceDocumentIndex(LoweredSourceDocumentIndex node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitMethodInfo(LoweredMethodInfo node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitFieldInfo(LoweredFieldInfo node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitDefaultLiteral(LoweredDefaultLiteral node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitDefaultExpression(LoweredDefaultExpression node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitIsOperator(LoweredIsOperator node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitAsOperator(LoweredAsOperator node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitSizeOfOperator(LoweredSizeOfOperator node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitConversion(LoweredConversion node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitReadOnlySpanFromArray(LoweredReadOnlySpanFromArray node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitArgList(LoweredArgList node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitArgListOperator(LoweredArgListOperator node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitFixedLocalCollectionInitializer(LoweredFixedLocalCollectionInitializer node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitSequencePoint(LoweredSequencePoint node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitSequencePointWithSpan(LoweredSequencePointWithSpan node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitBlock(LoweredBlock node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitScope(LoweredScope node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitStateMachineScope(LoweredStateMachineScope node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitLocalDeclaration(LoweredLocalDeclaration node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitMultipleLocalDeclarations(LoweredMultipleLocalDeclarations node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitUsingLocalDeclarations(LoweredUsingLocalDeclarations node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitLocalFunctionStatement(LoweredLocalFunctionStatement node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitNoOpStatement(LoweredNoOpStatement node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitReturnStatement(LoweredReturnStatement node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitYieldReturnStatement(LoweredYieldReturnStatement node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitYieldBreakStatement(LoweredYieldBreakStatement node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitThrowStatement(LoweredThrowStatement node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitExpressionStatement(LoweredExpressionStatement node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitBreakStatement(LoweredBreakStatement node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitContinueStatement(LoweredContinueStatement node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitSwitchStatement(LoweredSwitchStatement node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitSwitchDispatch(LoweredSwitchDispatch node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitIfStatement(LoweredIfStatement node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitDoStatement(LoweredDoStatement node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitWhileStatement(LoweredWhileStatement node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitForStatement(LoweredForStatement node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitForEachStatement(LoweredForEachStatement node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitForEachDeconstructStep(LoweredForEachDeconstructStep node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitUsingStatement(LoweredUsingStatement node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitFixedStatement(LoweredFixedStatement node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitLockStatement(LoweredLockStatement node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitTryStatement(LoweredTryStatement node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitCatchBlock(LoweredCatchBlock node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitLiteral(LoweredLiteral node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitThisReference(LoweredThisReference node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitPreviousSubmissionReference(LoweredPreviousSubmissionReference node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitHostObjectMemberReference(LoweredHostObjectMemberReference node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitBaseReference(LoweredBaseReference node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitLocal(LoweredLocal node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitPseudoVariable(LoweredPseudoVariable node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitRangeVariable(LoweredRangeVariable node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitParameter(LoweredParameter node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitLabelStatement(LoweredLabelStatement node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitGotoStatement(LoweredGotoStatement node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitLabeledStatement(LoweredLabeledStatement node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitLabel(LoweredLabel node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitStatementList(LoweredStatementList node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitConditionalGoto(LoweredConditionalGoto node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitSwitchExpressionArm(LoweredSwitchExpressionArm node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitUnconvertedSwitchExpression(LoweredUnconvertedSwitchExpression node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitConvertedSwitchExpression(LoweredConvertedSwitchExpression node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitDecisionDag(LoweredDecisionDag node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitEvaluationDecisionDagNode(LoweredEvaluationDecisionDagNode node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitTestDecisionDagNode(LoweredTestDecisionDagNode node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitWhenDecisionDagNode(LoweredWhenDecisionDagNode node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitLeafDecisionDagNode(LoweredLeafDecisionDagNode node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitDagTemp(LoweredDagTemp node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitDagTypeTest(LoweredDagTypeTest node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitDagNonNullTest(LoweredDagNonNullTest node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitDagExplicitNullTest(LoweredDagExplicitNullTest node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitDagValueTest(LoweredDagValueTest node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitDagDeconstructEvaluation(LoweredDagDeconstructEvaluation node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitDagTypeEvaluation(LoweredDagTypeEvaluation node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitDagFieldEvaluation(LoweredDagFieldEvaluation node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitDagPropertyEvaluation(LoweredDagPropertyEvaluation node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitDagIndexEvaluation(LoweredDagIndexEvaluation node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitSwitchSection(LoweredSwitchSection node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitSwitchLabel(LoweredSwitchLabel node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitSequencePointExpression(LoweredSequencePointExpression node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitSequence(LoweredSequence node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitSpillSequence(LoweredSpillSequence node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitDynamicMemberAccess(LoweredDynamicMemberAccess node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitDynamicInvocation(LoweredDynamicInvocation node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitConditionalAccess(LoweredConditionalAccess node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitLoweredConditionalAccess(LoweredLoweredConditionalAccess node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitConditionalReceiver(LoweredConditionalReceiver node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitComplexConditionalReceiver(LoweredComplexConditionalReceiver node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitMethodGroup(LoweredMethodGroup node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitPropertyGroup(LoweredPropertyGroup node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitCall(LoweredCall node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitEventAssignmentOperator(LoweredEventAssignmentOperator node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitAttribute(LoweredAttribute node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitObjectCreationExpression(LoweredObjectCreationExpression node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitTupleLiteral(LoweredTupleLiteral node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitConvertedTupleLiteral(LoweredConvertedTupleLiteral node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitDynamicObjectCreationExpression(LoweredDynamicObjectCreationExpression node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitNoPiaObjectCreationExpression(LoweredNoPiaObjectCreationExpression node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitObjectInitializerExpression(LoweredObjectInitializerExpression node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitObjectInitializerMember(LoweredObjectInitializerMember node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitDynamicObjectInitializerMember(LoweredDynamicObjectInitializerMember node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitCollectionInitializerExpression(LoweredCollectionInitializerExpression node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitCollectionElementInitializer(LoweredCollectionElementInitializer node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitDynamicCollectionElementInitializer(LoweredDynamicCollectionElementInitializer node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitImplicitReceiver(LoweredImplicitReceiver node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitAnonymousObjectCreationExpression(LoweredAnonymousObjectCreationExpression node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitAnonymousPropertyDeclaration(LoweredAnonymousPropertyDeclaration node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitNewT(LoweredNewT node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitDelegateCreationExpression(LoweredDelegateCreationExpression node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitArrayCreation(LoweredArrayCreation node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitArrayInitialization(LoweredArrayInitialization node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitStackAllocArrayCreation(LoweredStackAllocArrayCreation node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitConvertedStackAllocExpression(LoweredConvertedStackAllocExpression node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitFieldAccess(LoweredFieldAccess node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitHoistedFieldAccess(LoweredHoistedFieldAccess node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitPropertyAccess(LoweredPropertyAccess node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitEventAccess(LoweredEventAccess node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitIndexerAccess(LoweredIndexerAccess node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitIndexOrRangePatternIndexerAccess(LoweredIndexOrRangePatternIndexerAccess node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitDynamicIndexerAccess(LoweredDynamicIndexerAccess node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitLambda(LoweredLambda node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitUnboundLambda(UnboundLambda node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitQueryClause(LoweredQueryClause node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitTypeOrInstanceInitializers(LoweredTypeOrInstanceInitializers node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitNameOfOperator(LoweredNameOfOperator node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitInterpolatedString(LoweredInterpolatedString node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitStringInsert(LoweredStringInsert node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitIsPatternExpression(LoweredIsPatternExpression node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitConstantPattern(LoweredConstantPattern node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitDiscardPattern(LoweredDiscardPattern node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitDeclarationPattern(LoweredDeclarationPattern node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitRecursivePattern(LoweredRecursivePattern node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitITuplePattern(LoweredITuplePattern node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitSubpattern(LoweredSubpattern node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitDiscardExpression(LoweredDiscardExpression node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitThrowExpression(LoweredThrowExpression node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitOutVariablePendingInference(OutVariablePendingInference node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitDeconstructionVariablePendingInference(DeconstructionVariablePendingInference node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitOutDeconstructVarPendingInference(OutDeconstructVarPendingInference node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitNonConstructorMethodBody(LoweredNonConstructorMethodBody node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitConstructorMethodBody(LoweredConstructorMethodBody node) => this.DefaultVisit(node);
        public virtual LoweredNode? VisitExpressionWithNullability(LoweredExpressionWithNullability node) => this.DefaultVisit(node);
    }

    internal abstract partial class LoweredTreeWalker: LoweredTreeVisitor
    {
        public override LoweredNode? VisitFieldEqualsValue(LoweredFieldEqualsValue node)
        {
            this.Visit(node.Value);
            return null;
        }
        public override LoweredNode? VisitPropertyEqualsValue(LoweredPropertyEqualsValue node)
        {
            this.Visit(node.Value);
            return null;
        }
        public override LoweredNode? VisitParameterEqualsValue(LoweredParameterEqualsValue node)
        {
            this.Visit(node.Value);
            return null;
        }
        public override LoweredNode? VisitGlobalStatementInitializer(LoweredGlobalStatementInitializer node)
        {
            this.Visit(node.Statement);
            return null;
        }
        public override LoweredNode? VisitDeconstructValuePlaceholder(LoweredDeconstructValuePlaceholder node) => null;
        public override LoweredNode? VisitTupleOperandPlaceholder(LoweredTupleOperandPlaceholder node) => null;
        public override LoweredNode? VisitAwaitableValuePlaceholder(LoweredAwaitableValuePlaceholder node) => null;
        public override LoweredNode? VisitDisposableValuePlaceholder(LoweredDisposableValuePlaceholder node) => null;
        public override LoweredNode? VisitObjectOrCollectionValuePlaceholder(LoweredObjectOrCollectionValuePlaceholder node) => null;
        public override LoweredNode? VisitDup(LoweredDup node) => null;
        public override LoweredNode? VisitPassByCopy(LoweredPassByCopy node)
        {
            this.Visit(node.Expression);
            return null;
        }
        public override LoweredNode? VisitBadExpression(LoweredBadExpression node)
        {
            this.VisitList(node.ChildLoweredNodes);
            return null;
        }
        public override LoweredNode? VisitBadStatement(LoweredBadStatement node)
        {
            this.VisitList(node.ChildLoweredNodes);
            return null;
        }
        public override LoweredNode? VisitExtractedFinallyBlock(LoweredExtractedFinallyBlock node)
        {
            this.Visit(node.FinallyBlock);
            return null;
        }
        public override LoweredNode? VisitTypeExpression(LoweredTypeExpression node)
        {
            this.Visit(node.LoweredContainingTypeOpt);
            this.VisitList(node.LoweredDimensionsOpt);
            return null;
        }
        public override LoweredNode? VisitTypeOrValueExpression(LoweredTypeOrValueExpression node) => null;
        public override LoweredNode? VisitNamespaceExpression(LoweredNamespaceExpression node) => null;
        public override LoweredNode? VisitUnaryOperator(LoweredUnaryOperator node)
        {
            this.Visit(node.Operand);
            return null;
        }
        public override LoweredNode? VisitIncrementOperator(LoweredIncrementOperator node)
        {
            this.Visit(node.Operand);
            return null;
        }
        public override LoweredNode? VisitAddressOfOperator(LoweredAddressOfOperator node)
        {
            this.Visit(node.Operand);
            return null;
        }
        public override LoweredNode? VisitPointerIndirectionOperator(LoweredPointerIndirectionOperator node)
        {
            this.Visit(node.Operand);
            return null;
        }
        public override LoweredNode? VisitPointerElementAccess(LoweredPointerElementAccess node)
        {
            this.Visit(node.Expression);
            this.Visit(node.Index);
            return null;
        }
        public override LoweredNode? VisitRefTypeOperator(LoweredRefTypeOperator node)
        {
            this.Visit(node.Operand);
            return null;
        }
        public override LoweredNode? VisitMakeRefOperator(LoweredMakeRefOperator node)
        {
            this.Visit(node.Operand);
            return null;
        }
        public override LoweredNode? VisitRefValueOperator(LoweredRefValueOperator node)
        {
            this.Visit(node.Operand);
            return null;
        }
        public override LoweredNode? VisitFromEndIndexExpression(LoweredFromEndIndexExpression node)
        {
            this.Visit(node.Operand);
            return null;
        }
        public override LoweredNode? VisitRangeExpression(LoweredRangeExpression node)
        {
            this.Visit(node.LeftOperandOpt);
            this.Visit(node.RightOperandOpt);
            return null;
        }
        public override LoweredNode? VisitBinaryOperator(LoweredBinaryOperator node)
        {
            this.Visit(node.Left);
            this.Visit(node.Right);
            return null;
        }
        public override LoweredNode? VisitTupleBinaryOperator(LoweredTupleBinaryOperator node)
        {
            this.Visit(node.Left);
            this.Visit(node.Right);
            return null;
        }
        public override LoweredNode? VisitUserDefinedConditionalLogicalOperator(LoweredUserDefinedConditionalLogicalOperator node)
        {
            this.Visit(node.Left);
            this.Visit(node.Right);
            return null;
        }
        public override LoweredNode? VisitCompoundAssignmentOperator(LoweredCompoundAssignmentOperator node)
        {
            this.Visit(node.Left);
            this.Visit(node.Right);
            return null;
        }
        public override LoweredNode? VisitAssignmentOperator(LoweredAssignmentOperator node)
        {
            this.Visit(node.Left);
            this.Visit(node.Right);
            return null;
        }
        public override LoweredNode? VisitDeconstructionAssignmentOperator(LoweredDeconstructionAssignmentOperator node)
        {
            this.Visit(node.Left);
            this.Visit(node.Right);
            return null;
        }
        public override LoweredNode? VisitNullCoalescingOperator(LoweredNullCoalescingOperator node)
        {
            this.Visit(node.LeftOperand);
            this.Visit(node.RightOperand);
            return null;
        }
        public override LoweredNode? VisitNullCoalescingAssignmentOperator(LoweredNullCoalescingAssignmentOperator node)
        {
            this.Visit(node.LeftOperand);
            this.Visit(node.RightOperand);
            return null;
        }
        public override LoweredNode? VisitConditionalOperator(LoweredConditionalOperator node)
        {
            this.Visit(node.Condition);
            this.Visit(node.Consequence);
            this.Visit(node.Alternative);
            return null;
        }
        public override LoweredNode? VisitArrayAccess(LoweredArrayAccess node)
        {
            this.Visit(node.Expression);
            this.VisitList(node.Indices);
            return null;
        }
        public override LoweredNode? VisitArrayLength(LoweredArrayLength node)
        {
            this.Visit(node.Expression);
            return null;
        }
        public override LoweredNode? VisitAwaitableInfo(LoweredAwaitableInfo node)
        {
            this.Visit(node.AwaitableInstancePlaceholder);
            this.Visit(node.GetAwaiter);
            return null;
        }
        public override LoweredNode? VisitAwaitExpression(LoweredAwaitExpression node)
        {
            this.Visit(node.Expression);
            this.Visit(node.AwaitableInfo);
            return null;
        }
        public override LoweredNode? VisitTypeOfOperator(LoweredTypeOfOperator node)
        {
            this.Visit(node.SourceType);
            return null;
        }
        public override LoweredNode? VisitMethodDefIndex(LoweredMethodDefIndex node) => null;
        public override LoweredNode? VisitMaximumMethodDefIndex(LoweredMaximumMethodDefIndex node) => null;
        public override LoweredNode? VisitInstrumentationPayloadRoot(LoweredInstrumentationPayloadRoot node) => null;
        public override LoweredNode? VisitModuleVersionId(LoweredModuleVersionId node) => null;
        public override LoweredNode? VisitModuleVersionIdString(LoweredModuleVersionIdString node) => null;
        public override LoweredNode? VisitSourceDocumentIndex(LoweredSourceDocumentIndex node) => null;
        public override LoweredNode? VisitMethodInfo(LoweredMethodInfo node) => null;
        public override LoweredNode? VisitFieldInfo(LoweredFieldInfo node) => null;
        public override LoweredNode? VisitDefaultLiteral(LoweredDefaultLiteral node) => null;
        public override LoweredNode? VisitDefaultExpression(LoweredDefaultExpression node) => null;
        public override LoweredNode? VisitIsOperator(LoweredIsOperator node)
        {
            this.Visit(node.Operand);
            this.Visit(node.TargetType);
            return null;
        }
        public override LoweredNode? VisitAsOperator(LoweredAsOperator node)
        {
            this.Visit(node.Operand);
            this.Visit(node.TargetType);
            return null;
        }
        public override LoweredNode? VisitSizeOfOperator(LoweredSizeOfOperator node)
        {
            this.Visit(node.SourceType);
            return null;
        }
        public override LoweredNode? VisitConversion(LoweredConversion node)
        {
            this.Visit(node.Operand);
            return null;
        }
        public override LoweredNode? VisitReadOnlySpanFromArray(LoweredReadOnlySpanFromArray node)
        {
            this.Visit(node.Operand);
            return null;
        }
        public override LoweredNode? VisitArgList(LoweredArgList node) => null;
        public override LoweredNode? VisitArgListOperator(LoweredArgListOperator node)
        {
            this.VisitList(node.Arguments);
            return null;
        }
        public override LoweredNode? VisitFixedLocalCollectionInitializer(LoweredFixedLocalCollectionInitializer node)
        {
            this.Visit(node.Expression);
            return null;
        }
        public override LoweredNode? VisitSequencePoint(LoweredSequencePoint node)
        {
            this.Visit(node.StatementOpt);
            return null;
        }
        public override LoweredNode? VisitSequencePointWithSpan(LoweredSequencePointWithSpan node)
        {
            this.Visit(node.StatementOpt);
            return null;
        }
        public override LoweredNode? VisitBlock(LoweredBlock node)
        {
            this.VisitList(node.Statements);
            return null;
        }
        public override LoweredNode? VisitScope(LoweredScope node)
        {
            this.VisitList(node.Statements);
            return null;
        }
        public override LoweredNode? VisitStateMachineScope(LoweredStateMachineScope node)
        {
            this.Visit(node.Statement);
            return null;
        }
        public override LoweredNode? VisitLocalDeclaration(LoweredLocalDeclaration node)
        {
            this.Visit(node.DeclaredTypeOpt);
            this.Visit(node.InitializerOpt);
            this.VisitList(node.ArgumentsOpt);
            return null;
        }
        public override LoweredNode? VisitMultipleLocalDeclarations(LoweredMultipleLocalDeclarations node)
        {
            this.VisitList(node.LocalDeclarations);
            return null;
        }
        public override LoweredNode? VisitUsingLocalDeclarations(LoweredUsingLocalDeclarations node)
        {
            this.Visit(node.AwaitOpt);
            this.VisitList(node.LocalDeclarations);
            return null;
        }
        public override LoweredNode? VisitLocalFunctionStatement(LoweredLocalFunctionStatement node)
        {
            this.Visit(node.BlockBody);
            this.Visit(node.ExpressionBody);
            return null;
        }
        public override LoweredNode? VisitNoOpStatement(LoweredNoOpStatement node) => null;
        public override LoweredNode? VisitReturnStatement(LoweredReturnStatement node)
        {
            this.Visit(node.ExpressionOpt);
            return null;
        }
        public override LoweredNode? VisitYieldReturnStatement(LoweredYieldReturnStatement node)
        {
            this.Visit(node.Expression);
            return null;
        }
        public override LoweredNode? VisitYieldBreakStatement(LoweredYieldBreakStatement node) => null;
        public override LoweredNode? VisitThrowStatement(LoweredThrowStatement node)
        {
            this.Visit(node.ExpressionOpt);
            return null;
        }
        public override LoweredNode? VisitExpressionStatement(LoweredExpressionStatement node)
        {
            this.Visit(node.Expression);
            return null;
        }
        public override LoweredNode? VisitBreakStatement(LoweredBreakStatement node) => null;
        public override LoweredNode? VisitContinueStatement(LoweredContinueStatement node) => null;
        public override LoweredNode? VisitSwitchStatement(LoweredSwitchStatement node)
        {
            this.Visit(node.Expression);
            this.VisitList(node.SwitchSections);
            this.Visit(node.DefaultLabel);
            return null;
        }
        public override LoweredNode? VisitSwitchDispatch(LoweredSwitchDispatch node)
        {
            this.Visit(node.Expression);
            return null;
        }
        public override LoweredNode? VisitIfStatement(LoweredIfStatement node)
        {
            this.Visit(node.Condition);
            this.Visit(node.Consequence);
            this.Visit(node.AlternativeOpt);
            return null;
        }
        public override LoweredNode? VisitDoStatement(LoweredDoStatement node)
        {
            this.Visit(node.Condition);
            this.Visit(node.Body);
            return null;
        }
        public override LoweredNode? VisitWhileStatement(LoweredWhileStatement node)
        {
            this.Visit(node.Condition);
            this.Visit(node.Body);
            return null;
        }
        public override LoweredNode? VisitForStatement(LoweredForStatement node)
        {
            this.Visit(node.Initializer);
            this.Visit(node.Condition);
            this.Visit(node.Increment);
            this.Visit(node.Body);
            return null;
        }
        public override LoweredNode? VisitForEachStatement(LoweredForEachStatement node)
        {
            this.Visit(node.IterationVariableType);
            this.Visit(node.IterationErrorExpressionOpt);
            this.Visit(node.Expression);
            this.Visit(node.DeconstructionOpt);
            this.Visit(node.AwaitOpt);
            this.Visit(node.Body);
            return null;
        }
        public override LoweredNode? VisitForEachDeconstructStep(LoweredForEachDeconstructStep node)
        {
            this.Visit(node.DeconstructionAssignment);
            this.Visit(node.TargetPlaceholder);
            return null;
        }
        public override LoweredNode? VisitUsingStatement(LoweredUsingStatement node)
        {
            this.Visit(node.DeclarationsOpt);
            this.Visit(node.ExpressionOpt);
            this.Visit(node.Body);
            this.Visit(node.AwaitOpt);
            return null;
        }
        public override LoweredNode? VisitFixedStatement(LoweredFixedStatement node)
        {
            this.Visit(node.Declarations);
            this.Visit(node.Body);
            return null;
        }
        public override LoweredNode? VisitLockStatement(LoweredLockStatement node)
        {
            this.Visit(node.Argument);
            this.Visit(node.Body);
            return null;
        }
        public override LoweredNode? VisitTryStatement(LoweredTryStatement node)
        {
            this.Visit(node.TryBlock);
            this.VisitList(node.CatchBlocks);
            this.Visit(node.FinallyBlockOpt);
            return null;
        }
        public override LoweredNode? VisitCatchBlock(LoweredCatchBlock node)
        {
            this.Visit(node.ExceptionSourceOpt);
            this.Visit(node.ExceptionFilterOpt);
            this.Visit(node.Body);
            return null;
        }
        public override LoweredNode? VisitLiteral(LoweredLiteral node) => null;
        public override LoweredNode? VisitThisReference(LoweredThisReference node) => null;
        public override LoweredNode? VisitPreviousSubmissionReference(LoweredPreviousSubmissionReference node) => null;
        public override LoweredNode? VisitHostObjectMemberReference(LoweredHostObjectMemberReference node) => null;
        public override LoweredNode? VisitBaseReference(LoweredBaseReference node) => null;
        public override LoweredNode? VisitLocal(LoweredLocal node) => null;
        public override LoweredNode? VisitPseudoVariable(LoweredPseudoVariable node) => null;
        public override LoweredNode? VisitRangeVariable(LoweredRangeVariable node)
        {
            this.Visit(node.Value);
            return null;
        }
        public override LoweredNode? VisitParameter(LoweredParameter node) => null;
        public override LoweredNode? VisitLabelStatement(LoweredLabelStatement node) => null;
        public override LoweredNode? VisitGotoStatement(LoweredGotoStatement node)
        {
            this.Visit(node.CaseExpressionOpt);
            this.Visit(node.LabelExpressionOpt);
            return null;
        }
        public override LoweredNode? VisitLabeledStatement(LoweredLabeledStatement node)
        {
            this.Visit(node.Body);
            return null;
        }
        public override LoweredNode? VisitLabel(LoweredLabel node) => null;
        public override LoweredNode? VisitStatementList(LoweredStatementList node)
        {
            this.VisitList(node.Statements);
            return null;
        }
        public override LoweredNode? VisitConditionalGoto(LoweredConditionalGoto node)
        {
            this.Visit(node.Condition);
            return null;
        }
        public override LoweredNode? VisitSwitchExpressionArm(LoweredSwitchExpressionArm node)
        {
            this.Visit(node.Pattern);
            this.Visit(node.WhenClause);
            this.Visit(node.Value);
            return null;
        }
        public override LoweredNode? VisitUnconvertedSwitchExpression(LoweredUnconvertedSwitchExpression node)
        {
            this.Visit(node.Expression);
            this.VisitList(node.SwitchArms);
            return null;
        }
        public override LoweredNode? VisitConvertedSwitchExpression(LoweredConvertedSwitchExpression node)
        {
            this.Visit(node.Expression);
            this.VisitList(node.SwitchArms);
            return null;
        }
        public override LoweredNode? VisitDecisionDag(LoweredDecisionDag node) => null;
        public override LoweredNode? VisitEvaluationDecisionDagNode(LoweredEvaluationDecisionDagNode node)
        {
            this.Visit(node.Evaluation);
            this.Visit(node.Next);
            return null;
        }
        public override LoweredNode? VisitTestDecisionDagNode(LoweredTestDecisionDagNode node)
        {
            this.Visit(node.Test);
            this.Visit(node.WhenTrue);
            this.Visit(node.WhenFalse);
            return null;
        }
        public override LoweredNode? VisitWhenDecisionDagNode(LoweredWhenDecisionDagNode node)
        {
            this.Visit(node.WhenExpression);
            this.Visit(node.WhenTrue);
            this.Visit(node.WhenFalse);
            return null;
        }
        public override LoweredNode? VisitLeafDecisionDagNode(LoweredLeafDecisionDagNode node) => null;
        public override LoweredNode? VisitDagTemp(LoweredDagTemp node)
        {
            this.Visit(node.Source);
            return null;
        }
        public override LoweredNode? VisitDagTypeTest(LoweredDagTypeTest node)
        {
            this.Visit(node.Input);
            return null;
        }
        public override LoweredNode? VisitDagNonNullTest(LoweredDagNonNullTest node)
        {
            this.Visit(node.Input);
            return null;
        }
        public override LoweredNode? VisitDagExplicitNullTest(LoweredDagExplicitNullTest node)
        {
            this.Visit(node.Input);
            return null;
        }
        public override LoweredNode? VisitDagValueTest(LoweredDagValueTest node)
        {
            this.Visit(node.Input);
            return null;
        }
        public override LoweredNode? VisitDagDeconstructEvaluation(LoweredDagDeconstructEvaluation node)
        {
            this.Visit(node.Input);
            return null;
        }
        public override LoweredNode? VisitDagTypeEvaluation(LoweredDagTypeEvaluation node)
        {
            this.Visit(node.Input);
            return null;
        }
        public override LoweredNode? VisitDagFieldEvaluation(LoweredDagFieldEvaluation node)
        {
            this.Visit(node.Input);
            return null;
        }
        public override LoweredNode? VisitDagPropertyEvaluation(LoweredDagPropertyEvaluation node)
        {
            this.Visit(node.Input);
            return null;
        }
        public override LoweredNode? VisitDagIndexEvaluation(LoweredDagIndexEvaluation node)
        {
            this.Visit(node.Input);
            return null;
        }
        public override LoweredNode? VisitSwitchSection(LoweredSwitchSection node)
        {
            this.VisitList(node.SwitchLabels);
            this.VisitList(node.Statements);
            return null;
        }
        public override LoweredNode? VisitSwitchLabel(LoweredSwitchLabel node)
        {
            this.Visit(node.Pattern);
            this.Visit(node.WhenClause);
            return null;
        }
        public override LoweredNode? VisitSequencePointExpression(LoweredSequencePointExpression node)
        {
            this.Visit(node.Expression);
            return null;
        }
        public override LoweredNode? VisitSequence(LoweredSequence node)
        {
            this.VisitList(node.SideEffects);
            this.Visit(node.Value);
            return null;
        }
        public override LoweredNode? VisitSpillSequence(LoweredSpillSequence node)
        {
            this.VisitList(node.SideEffects);
            this.Visit(node.Value);
            return null;
        }
        public override LoweredNode? VisitDynamicMemberAccess(LoweredDynamicMemberAccess node)
        {
            this.Visit(node.Receiver);
            return null;
        }
        public override LoweredNode? VisitDynamicInvocation(LoweredDynamicInvocation node)
        {
            this.Visit(node.Expression);
            this.VisitList(node.Arguments);
            return null;
        }
        public override LoweredNode? VisitConditionalAccess(LoweredConditionalAccess node)
        {
            this.Visit(node.Receiver);
            this.Visit(node.AccessExpression);
            return null;
        }
        public override LoweredNode? VisitLoweredConditionalAccess(LoweredLoweredConditionalAccess node)
        {
            this.Visit(node.Receiver);
            this.Visit(node.WhenNotNull);
            this.Visit(node.WhenNullOpt);
            return null;
        }
        public override LoweredNode? VisitConditionalReceiver(LoweredConditionalReceiver node) => null;
        public override LoweredNode? VisitComplexConditionalReceiver(LoweredComplexConditionalReceiver node)
        {
            this.Visit(node.ValueTypeReceiver);
            this.Visit(node.ReferenceTypeReceiver);
            return null;
        }
        public override LoweredNode? VisitMethodGroup(LoweredMethodGroup node)
        {
            this.Visit(node.ReceiverOpt);
            return null;
        }
        public override LoweredNode? VisitPropertyGroup(LoweredPropertyGroup node)
        {
            this.Visit(node.ReceiverOpt);
            return null;
        }
        public override LoweredNode? VisitCall(LoweredCall node)
        {
            this.Visit(node.ReceiverOpt);
            this.VisitList(node.Arguments);
            return null;
        }
        public override LoweredNode? VisitEventAssignmentOperator(LoweredEventAssignmentOperator node)
        {
            this.Visit(node.ReceiverOpt);
            this.Visit(node.Argument);
            return null;
        }
        public override LoweredNode? VisitAttribute(LoweredAttribute node)
        {
            this.VisitList(node.ConstructorArguments);
            this.VisitList(node.NamedArguments);
            return null;
        }
        public override LoweredNode? VisitObjectCreationExpression(LoweredObjectCreationExpression node)
        {
            this.VisitList(node.Arguments);
            this.Visit(node.InitializerExpressionOpt);
            return null;
        }
        public override LoweredNode? VisitTupleLiteral(LoweredTupleLiteral node)
        {
            this.VisitList(node.Arguments);
            return null;
        }
        public override LoweredNode? VisitConvertedTupleLiteral(LoweredConvertedTupleLiteral node)
        {
            this.VisitList(node.Arguments);
            return null;
        }
        public override LoweredNode? VisitDynamicObjectCreationExpression(LoweredDynamicObjectCreationExpression node)
        {
            this.VisitList(node.Arguments);
            this.Visit(node.InitializerExpressionOpt);
            return null;
        }
        public override LoweredNode? VisitNoPiaObjectCreationExpression(LoweredNoPiaObjectCreationExpression node)
        {
            this.Visit(node.InitializerExpressionOpt);
            return null;
        }
        public override LoweredNode? VisitObjectInitializerExpression(LoweredObjectInitializerExpression node)
        {
            this.Visit(node.Placeholder);
            this.VisitList(node.Initializers);
            return null;
        }
        public override LoweredNode? VisitObjectInitializerMember(LoweredObjectInitializerMember node)
        {
            this.VisitList(node.Arguments);
            return null;
        }
        public override LoweredNode? VisitDynamicObjectInitializerMember(LoweredDynamicObjectInitializerMember node) => null;
        public override LoweredNode? VisitCollectionInitializerExpression(LoweredCollectionInitializerExpression node)
        {
            this.Visit(node.Placeholder);
            this.VisitList(node.Initializers);
            return null;
        }
        public override LoweredNode? VisitCollectionElementInitializer(LoweredCollectionElementInitializer node)
        {
            this.VisitList(node.Arguments);
            this.Visit(node.ImplicitReceiverOpt);
            return null;
        }
        public override LoweredNode? VisitDynamicCollectionElementInitializer(LoweredDynamicCollectionElementInitializer node)
        {
            this.Visit(node.Expression);
            this.VisitList(node.Arguments);
            return null;
        }
        public override LoweredNode? VisitImplicitReceiver(LoweredImplicitReceiver node) => null;
        public override LoweredNode? VisitAnonymousObjectCreationExpression(LoweredAnonymousObjectCreationExpression node)
        {
            this.VisitList(node.Arguments);
            this.VisitList(node.Declarations);
            return null;
        }
        public override LoweredNode? VisitAnonymousPropertyDeclaration(LoweredAnonymousPropertyDeclaration node) => null;
        public override LoweredNode? VisitNewT(LoweredNewT node)
        {
            this.Visit(node.InitializerExpressionOpt);
            return null;
        }
        public override LoweredNode? VisitDelegateCreationExpression(LoweredDelegateCreationExpression node)
        {
            this.Visit(node.Argument);
            return null;
        }
        public override LoweredNode? VisitArrayCreation(LoweredArrayCreation node)
        {
            this.VisitList(node.Lowereds);
            this.Visit(node.InitializerOpt);
            return null;
        }
        public override LoweredNode? VisitArrayInitialization(LoweredArrayInitialization node)
        {
            this.VisitList(node.Initializers);
            return null;
        }
        public override LoweredNode? VisitStackAllocArrayCreation(LoweredStackAllocArrayCreation node)
        {
            this.Visit(node.Count);
            this.Visit(node.InitializerOpt);
            return null;
        }
        public override LoweredNode? VisitConvertedStackAllocExpression(LoweredConvertedStackAllocExpression node)
        {
            this.Visit(node.Count);
            this.Visit(node.InitializerOpt);
            return null;
        }
        public override LoweredNode? VisitFieldAccess(LoweredFieldAccess node)
        {
            this.Visit(node.ReceiverOpt);
            return null;
        }
        public override LoweredNode? VisitHoistedFieldAccess(LoweredHoistedFieldAccess node) => null;
        public override LoweredNode? VisitPropertyAccess(LoweredPropertyAccess node)
        {
            this.Visit(node.ReceiverOpt);
            return null;
        }
        public override LoweredNode? VisitEventAccess(LoweredEventAccess node)
        {
            this.Visit(node.ReceiverOpt);
            return null;
        }
        public override LoweredNode? VisitIndexerAccess(LoweredIndexerAccess node)
        {
            this.Visit(node.ReceiverOpt);
            this.VisitList(node.Arguments);
            return null;
        }
        public override LoweredNode? VisitIndexOrRangePatternIndexerAccess(LoweredIndexOrRangePatternIndexerAccess node)
        {
            this.Visit(node.Receiver);
            this.Visit(node.Argument);
            return null;
        }
        public override LoweredNode? VisitDynamicIndexerAccess(LoweredDynamicIndexerAccess node)
        {
            this.Visit(node.ReceiverOpt);
            this.VisitList(node.Arguments);
            return null;
        }
        public override LoweredNode? VisitLambda(LoweredLambda node)
        {
            this.Visit(node.Body);
            return null;
        }
        public override LoweredNode? VisitUnboundLambda(UnboundLambda node) => null;
        public override LoweredNode? VisitQueryClause(LoweredQueryClause node)
        {
            this.Visit(node.Value);
            return null;
        }
        public override LoweredNode? VisitTypeOrInstanceInitializers(LoweredTypeOrInstanceInitializers node)
        {
            this.VisitList(node.Statements);
            return null;
        }
        public override LoweredNode? VisitNameOfOperator(LoweredNameOfOperator node)
        {
            this.Visit(node.Argument);
            return null;
        }
        public override LoweredNode? VisitInterpolatedString(LoweredInterpolatedString node)
        {
            this.VisitList(node.Parts);
            return null;
        }
        public override LoweredNode? VisitStringInsert(LoweredStringInsert node)
        {
            this.Visit(node.Value);
            this.Visit(node.Alignment);
            this.Visit(node.Format);
            return null;
        }
        public override LoweredNode? VisitIsPatternExpression(LoweredIsPatternExpression node)
        {
            this.Visit(node.Expression);
            this.Visit(node.Pattern);
            return null;
        }
        public override LoweredNode? VisitConstantPattern(LoweredConstantPattern node)
        {
            this.Visit(node.Value);
            return null;
        }
        public override LoweredNode? VisitDiscardPattern(LoweredDiscardPattern node) => null;
        public override LoweredNode? VisitDeclarationPattern(LoweredDeclarationPattern node)
        {
            this.Visit(node.VariableAccess);
            this.Visit(node.DeclaredType);
            return null;
        }
        public override LoweredNode? VisitRecursivePattern(LoweredRecursivePattern node)
        {
            this.Visit(node.DeclaredType);
            this.VisitList(node.Deconstruction);
            this.VisitList(node.Properties);
            this.Visit(node.VariableAccess);
            return null;
        }
        public override LoweredNode? VisitITuplePattern(LoweredITuplePattern node)
        {
            this.VisitList(node.Subpatterns);
            return null;
        }
        public override LoweredNode? VisitSubpattern(LoweredSubpattern node)
        {
            this.Visit(node.Pattern);
            return null;
        }
        public override LoweredNode? VisitDiscardExpression(LoweredDiscardExpression node) => null;
        public override LoweredNode? VisitThrowExpression(LoweredThrowExpression node)
        {
            this.Visit(node.Expression);
            return null;
        }
        public override LoweredNode? VisitOutVariablePendingInference(OutVariablePendingInference node)
        {
            this.Visit(node.ReceiverOpt);
            return null;
        }
        public override LoweredNode? VisitDeconstructionVariablePendingInference(DeconstructionVariablePendingInference node)
        {
            this.Visit(node.ReceiverOpt);
            return null;
        }
        public override LoweredNode? VisitOutDeconstructVarPendingInference(OutDeconstructVarPendingInference node) => null;
        public override LoweredNode? VisitNonConstructorMethodBody(LoweredNonConstructorMethodBody node)
        {
            this.Visit(node.BlockBody);
            this.Visit(node.ExpressionBody);
            return null;
        }
        public override LoweredNode? VisitConstructorMethodBody(LoweredConstructorMethodBody node)
        {
            this.Visit(node.Initializer);
            this.Visit(node.BlockBody);
            this.Visit(node.ExpressionBody);
            return null;
        }
        public override LoweredNode? VisitExpressionWithNullability(LoweredExpressionWithNullability node)
        {
            this.Visit(node.Expression);
            return null;
        }
    }

    internal abstract partial class LoweredTreeRewriter : LoweredTreeVisitor
    {
        public override LoweredNode? VisitFieldEqualsValue(LoweredFieldEqualsValue node)
        {
            LoweredExpression value = (LoweredExpression)this.Visit(node.Value);
            return node.Update(node.Field, node.Locals, value);
        }
        public override LoweredNode? VisitPropertyEqualsValue(LoweredPropertyEqualsValue node)
        {
            LoweredExpression value = (LoweredExpression)this.Visit(node.Value);
            return node.Update(node.Property, node.Locals, value);
        }
        public override LoweredNode? VisitParameterEqualsValue(LoweredParameterEqualsValue node)
        {
            LoweredExpression value = (LoweredExpression)this.Visit(node.Value);
            return node.Update(node.Parameter, node.Locals, value);
        }
        public override LoweredNode? VisitGlobalStatementInitializer(LoweredGlobalStatementInitializer node)
        {
            LoweredStatement statement = (LoweredStatement)this.Visit(node.Statement);
            return node.Update(statement);
        }
        public override LoweredNode? VisitDeconstructValuePlaceholder(LoweredDeconstructValuePlaceholder node)
        {
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(node.ValEscape, type);
        }
        public override LoweredNode? VisitTupleOperandPlaceholder(LoweredTupleOperandPlaceholder node)
        {
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(type);
        }
        public override LoweredNode? VisitAwaitableValuePlaceholder(LoweredAwaitableValuePlaceholder node)
        {
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(node.ValEscape, type);
        }
        public override LoweredNode? VisitDisposableValuePlaceholder(LoweredDisposableValuePlaceholder node)
        {
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(type);
        }
        public override LoweredNode? VisitObjectOrCollectionValuePlaceholder(LoweredObjectOrCollectionValuePlaceholder node)
        {
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(type);
        }
        public override LoweredNode? VisitDup(LoweredDup node)
        {
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(node.RefKind, type);
        }
        public override LoweredNode? VisitPassByCopy(LoweredPassByCopy node)
        {
            LoweredExpression expression = (LoweredExpression)this.Visit(node.Expression);
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(expression, type);
        }
        public override LoweredNode? VisitBadExpression(LoweredBadExpression node)
        {
            ImmutableArray<LoweredExpression> childLoweredNodes = this.VisitList(node.ChildLoweredNodes);
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(node.ResultKind, node.Symbols, childLoweredNodes, type);
        }
        public override LoweredNode? VisitBadStatement(LoweredBadStatement node)
        {
            ImmutableArray<LoweredNode> childLoweredNodes = this.VisitList(node.ChildLoweredNodes);
            return node.Update(childLoweredNodes);
        }
        public override LoweredNode? VisitExtractedFinallyBlock(LoweredExtractedFinallyBlock node)
        {
            LoweredBlock finallyBlock = (LoweredBlock)this.Visit(node.FinallyBlock);
            return node.Update(finallyBlock);
        }
        public override LoweredNode? VisitTypeExpression(LoweredTypeExpression node)
        {
            LoweredTypeExpression? boundContainingTypeOpt = (LoweredTypeExpression?)this.Visit(node.LoweredContainingTypeOpt);
            ImmutableArray<LoweredExpression> boundDimensionsOpt = this.VisitList(node.LoweredDimensionsOpt);
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(node.AliasOpt, boundContainingTypeOpt, boundDimensionsOpt, node.TypeWithAnnotations, type);
        }
        public override LoweredNode? VisitTypeOrValueExpression(LoweredTypeOrValueExpression node)
        {
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(node.Data, type);
        }
        public override LoweredNode? VisitNamespaceExpression(LoweredNamespaceExpression node)
        {
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(node.NamespaceSymbol, node.AliasOpt);
        }
        public override LoweredNode? VisitUnaryOperator(LoweredUnaryOperator node)
        {
            LoweredExpression operand = (LoweredExpression)this.Visit(node.Operand);
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(node.OperatorKind, operand, node.ConstantValueOpt, node.MethodOpt, node.ResultKind, node.OriginalUserDefinedOperatorsOpt, type);
        }
        public override LoweredNode? VisitIncrementOperator(LoweredIncrementOperator node)
        {
            LoweredExpression operand = (LoweredExpression)this.Visit(node.Operand);
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(node.OperatorKind, operand, node.MethodOpt, node.OperandConversion, node.ResultConversion, node.ResultKind, node.OriginalUserDefinedOperatorsOpt, type);
        }
        public override LoweredNode? VisitAddressOfOperator(LoweredAddressOfOperator node)
        {
            LoweredExpression operand = (LoweredExpression)this.Visit(node.Operand);
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(operand, node.IsManaged, type);
        }
        public override LoweredNode? VisitPointerIndirectionOperator(LoweredPointerIndirectionOperator node)
        {
            LoweredExpression operand = (LoweredExpression)this.Visit(node.Operand);
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(operand, type);
        }
        public override LoweredNode? VisitPointerElementAccess(LoweredPointerElementAccess node)
        {
            LoweredExpression expression = (LoweredExpression)this.Visit(node.Expression);
            LoweredExpression index = (LoweredExpression)this.Visit(node.Index);
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(expression, index, node.Checked, type);
        }
        public override LoweredNode? VisitRefTypeOperator(LoweredRefTypeOperator node)
        {
            LoweredExpression operand = (LoweredExpression)this.Visit(node.Operand);
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(operand, node.GetTypeFromHandle, type);
        }
        public override LoweredNode? VisitMakeRefOperator(LoweredMakeRefOperator node)
        {
            LoweredExpression operand = (LoweredExpression)this.Visit(node.Operand);
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(operand, type);
        }
        public override LoweredNode? VisitRefValueOperator(LoweredRefValueOperator node)
        {
            LoweredExpression operand = (LoweredExpression)this.Visit(node.Operand);
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(node.NullableAnnotation, operand, type);
        }
        public override LoweredNode? VisitFromEndIndexExpression(LoweredFromEndIndexExpression node)
        {
            LoweredExpression operand = (LoweredExpression)this.Visit(node.Operand);
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(operand, node.MethodOpt, type);
        }
        public override LoweredNode? VisitRangeExpression(LoweredRangeExpression node)
        {
            LoweredExpression? leftOperandOpt = (LoweredExpression?)this.Visit(node.LeftOperandOpt);
            LoweredExpression? rightOperandOpt = (LoweredExpression?)this.Visit(node.RightOperandOpt);
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(leftOperandOpt, rightOperandOpt, node.MethodOpt, type);
        }
        public override LoweredNode? VisitBinaryOperator(LoweredBinaryOperator node)
        {
            LoweredExpression left = (LoweredExpression)this.Visit(node.Left);
            LoweredExpression right = (LoweredExpression)this.Visit(node.Right);
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(node.OperatorKind, node.ConstantValueOpt, node.MethodOpt, node.ResultKind, node.OriginalUserDefinedOperatorsOpt, left, right, type);
        }
        public override LoweredNode? VisitTupleBinaryOperator(LoweredTupleBinaryOperator node)
        {
            LoweredExpression left = (LoweredExpression)this.Visit(node.Left);
            LoweredExpression right = (LoweredExpression)this.Visit(node.Right);
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(left, right, node.OperatorKind, node.Operators, type);
        }
        public override LoweredNode? VisitUserDefinedConditionalLogicalOperator(LoweredUserDefinedConditionalLogicalOperator node)
        {
            LoweredExpression left = (LoweredExpression)this.Visit(node.Left);
            LoweredExpression right = (LoweredExpression)this.Visit(node.Right);
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(node.OperatorKind, node.LogicalOperator, node.TrueOperator, node.FalseOperator, node.ResultKind, node.OriginalUserDefinedOperatorsOpt, left, right, type);
        }
        public override LoweredNode? VisitCompoundAssignmentOperator(LoweredCompoundAssignmentOperator node)
        {
            LoweredExpression left = (LoweredExpression)this.Visit(node.Left);
            LoweredExpression right = (LoweredExpression)this.Visit(node.Right);
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(node.Operator, left, right, node.LeftConversion, node.FinalConversion, node.ResultKind, node.OriginalUserDefinedOperatorsOpt, type);
        }
        public override LoweredNode? VisitAssignmentOperator(LoweredAssignmentOperator node)
        {
            LoweredExpression left = (LoweredExpression)this.Visit(node.Left);
            LoweredExpression right = (LoweredExpression)this.Visit(node.Right);
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(left, right, node.IsRef, type);
        }
        public override LoweredNode? VisitDeconstructionAssignmentOperator(LoweredDeconstructionAssignmentOperator node)
        {
            LoweredTupleExpression left = (LoweredTupleExpression)this.Visit(node.Left);
            LoweredConversion right = (LoweredConversion)this.Visit(node.Right);
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(left, right, node.IsUsed, type);
        }
        public override LoweredNode? VisitNullCoalescingOperator(LoweredNullCoalescingOperator node)
        {
            LoweredExpression leftOperand = (LoweredExpression)this.Visit(node.LeftOperand);
            LoweredExpression rightOperand = (LoweredExpression)this.Visit(node.RightOperand);
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(leftOperand, rightOperand, node.LeftConversion, node.OperatorResultKind, type);
        }
        public override LoweredNode? VisitNullCoalescingAssignmentOperator(LoweredNullCoalescingAssignmentOperator node)
        {
            LoweredExpression leftOperand = (LoweredExpression)this.Visit(node.LeftOperand);
            LoweredExpression rightOperand = (LoweredExpression)this.Visit(node.RightOperand);
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(leftOperand, rightOperand, type);
        }
        public override LoweredNode? VisitConditionalOperator(LoweredConditionalOperator node)
        {
            LoweredExpression condition = (LoweredExpression)this.Visit(node.Condition);
            LoweredExpression consequence = (LoweredExpression)this.Visit(node.Consequence);
            LoweredExpression alternative = (LoweredExpression)this.Visit(node.Alternative);
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(node.IsRef, condition, consequence, alternative, node.ConstantValueOpt, type);
        }
        public override LoweredNode? VisitArrayAccess(LoweredArrayAccess node)
        {
            LoweredExpression expression = (LoweredExpression)this.Visit(node.Expression);
            ImmutableArray<LoweredExpression> indices = this.VisitList(node.Indices);
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(expression, indices, type);
        }
        public override LoweredNode? VisitArrayLength(LoweredArrayLength node)
        {
            LoweredExpression expression = (LoweredExpression)this.Visit(node.Expression);
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(expression, type);
        }
        public override LoweredNode? VisitAwaitableInfo(LoweredAwaitableInfo node)
        {
            LoweredAwaitableValuePlaceholder? awaitableInstancePlaceholder = (LoweredAwaitableValuePlaceholder?)this.Visit(node.AwaitableInstancePlaceholder);
            LoweredExpression? getAwaiter = (LoweredExpression?)this.Visit(node.GetAwaiter);
            return node.Update(awaitableInstancePlaceholder, node.IsDynamic, getAwaiter, node.IsCompleted, node.GetResult);
        }
        public override LoweredNode? VisitAwaitExpression(LoweredAwaitExpression node)
        {
            LoweredExpression expression = (LoweredExpression)this.Visit(node.Expression);
            LoweredAwaitableInfo awaitableInfo = (LoweredAwaitableInfo)this.Visit(node.AwaitableInfo);
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(expression, awaitableInfo, type);
        }
        public override LoweredNode? VisitTypeOfOperator(LoweredTypeOfOperator node)
        {
            LoweredTypeExpression sourceType = (LoweredTypeExpression)this.Visit(node.SourceType);
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(sourceType, node.GetTypeFromHandle, type);
        }
        public override LoweredNode? VisitMethodDefIndex(LoweredMethodDefIndex node)
        {
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(node.Method, type);
        }
        public override LoweredNode? VisitMaximumMethodDefIndex(LoweredMaximumMethodDefIndex node)
        {
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(type);
        }
        public override LoweredNode? VisitInstrumentationPayloadRoot(LoweredInstrumentationPayloadRoot node)
        {
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(node.AnalysisKind, type);
        }
        public override LoweredNode? VisitModuleVersionId(LoweredModuleVersionId node)
        {
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(type);
        }
        public override LoweredNode? VisitModuleVersionIdString(LoweredModuleVersionIdString node)
        {
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(type);
        }
        public override LoweredNode? VisitSourceDocumentIndex(LoweredSourceDocumentIndex node)
        {
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(node.Document, type);
        }
        public override LoweredNode? VisitMethodInfo(LoweredMethodInfo node)
        {
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(node.Method, node.GetMethodFromHandle, type);
        }
        public override LoweredNode? VisitFieldInfo(LoweredFieldInfo node)
        {
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(node.Field, node.GetFieldFromHandle, type);
        }
        public override LoweredNode? VisitDefaultLiteral(LoweredDefaultLiteral node)
        {
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update();
        }
        public override LoweredNode? VisitDefaultExpression(LoweredDefaultExpression node)
        {
            LoweredTypeExpression? targetType = node.TargetType;
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(targetType, node.ConstantValueOpt, type);
        }
        public override LoweredNode? VisitIsOperator(LoweredIsOperator node)
        {
            LoweredExpression operand = (LoweredExpression)this.Visit(node.Operand);
            LoweredTypeExpression targetType = (LoweredTypeExpression)this.Visit(node.TargetType);
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(operand, targetType, node.Conversion, type);
        }
        public override LoweredNode? VisitAsOperator(LoweredAsOperator node)
        {
            LoweredExpression operand = (LoweredExpression)this.Visit(node.Operand);
            LoweredTypeExpression targetType = (LoweredTypeExpression)this.Visit(node.TargetType);
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(operand, targetType, node.Conversion, type);
        }
        public override LoweredNode? VisitSizeOfOperator(LoweredSizeOfOperator node)
        {
            LoweredTypeExpression sourceType = (LoweredTypeExpression)this.Visit(node.SourceType);
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(sourceType, node.ConstantValueOpt, type);
        }
        public override LoweredNode? VisitConversion(LoweredConversion node)
        {
            LoweredExpression operand = (LoweredExpression)this.Visit(node.Operand);
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(operand, node.Conversion, node.IsBaseConversion, node.Checked, node.ExplicitCastInCode, node.ConstantValueOpt, node.ConversionGroupOpt, node.OriginalUserDefinedConversionsOpt, type);
        }
        public override LoweredNode? VisitReadOnlySpanFromArray(LoweredReadOnlySpanFromArray node)
        {
            LoweredExpression operand = (LoweredExpression)this.Visit(node.Operand);
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(operand, node.ConversionMethod, type);
        }
        public override LoweredNode? VisitArgList(LoweredArgList node)
        {
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(type);
        }
        public override LoweredNode? VisitArgListOperator(LoweredArgListOperator node)
        {
            ImmutableArray<LoweredExpression> arguments = this.VisitList(node.Arguments);
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(arguments, node.ArgumentRefKindsOpt, type);
        }
        public override LoweredNode? VisitFixedLocalCollectionInitializer(LoweredFixedLocalCollectionInitializer node)
        {
            LoweredExpression expression = (LoweredExpression)this.Visit(node.Expression);
            TypeSymbol elementPointerType = this.VisitType(node.ElementPointerType);
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(elementPointerType, node.ElementPointerTypeConversion, expression, node.GetPinnableOpt, type);
        }
        public override LoweredNode? VisitSequencePoint(LoweredSequencePoint node)
        {
            LoweredStatement? statementOpt = (LoweredStatement?)this.Visit(node.StatementOpt);
            return node.Update(statementOpt);
        }
        public override LoweredNode? VisitSequencePointWithSpan(LoweredSequencePointWithSpan node)
        {
            LoweredStatement? statementOpt = (LoweredStatement?)this.Visit(node.StatementOpt);
            return node.Update(statementOpt, node.Span);
        }
        public override LoweredNode? VisitBlock(LoweredBlock node)
        {
            ImmutableArray<LoweredStatement> statements = this.VisitList(node.Statements);
            return node.Update(node.Locals, node.LocalFunctions, statements);
        }
        public override LoweredNode? VisitScope(LoweredScope node)
        {
            ImmutableArray<LoweredStatement> statements = this.VisitList(node.Statements);
            return node.Update(node.Locals, statements);
        }
        public override LoweredNode? VisitStateMachineScope(LoweredStateMachineScope node)
        {
            LoweredStatement statement = (LoweredStatement)this.Visit(node.Statement);
            return node.Update(node.Fields, statement);
        }
        public override LoweredNode? VisitLocalDeclaration(LoweredLocalDeclaration node)
        {
            LoweredTypeExpression? declaredTypeOpt = (LoweredTypeExpression?)this.Visit(node.DeclaredTypeOpt);
            LoweredExpression? initializerOpt = (LoweredExpression?)this.Visit(node.InitializerOpt);
            ImmutableArray<LoweredExpression> argumentsOpt = this.VisitList(node.ArgumentsOpt);
            return node.Update(node.LocalSymbol, declaredTypeOpt, initializerOpt, argumentsOpt, node.InferredType);
        }
        public override LoweredNode? VisitMultipleLocalDeclarations(LoweredMultipleLocalDeclarations node)
        {
            ImmutableArray<LoweredLocalDeclaration> localDeclarations = this.VisitList(node.LocalDeclarations);
            return node.Update(localDeclarations);
        }
        public override LoweredNode? VisitUsingLocalDeclarations(LoweredUsingLocalDeclarations node)
        {
            LoweredAwaitableInfo? awaitOpt = (LoweredAwaitableInfo?)this.Visit(node.AwaitOpt);
            ImmutableArray<LoweredLocalDeclaration> localDeclarations = this.VisitList(node.LocalDeclarations);
            return node.Update(node.DisposeMethodOpt, node.IDisposableConversion, awaitOpt, localDeclarations);
        }
        public override LoweredNode? VisitLocalFunctionStatement(LoweredLocalFunctionStatement node)
        {
            LoweredBlock? blockBody = (LoweredBlock?)this.Visit(node.BlockBody);
            LoweredBlock? expressionBody = (LoweredBlock?)this.Visit(node.ExpressionBody);
            return node.Update(node.Symbol, blockBody, expressionBody);
        }
        public override LoweredNode? VisitNoOpStatement(LoweredNoOpStatement node) => node;
        public override LoweredNode? VisitReturnStatement(LoweredReturnStatement node)
        {
            LoweredExpression? expressionOpt = (LoweredExpression?)this.Visit(node.ExpressionOpt);
            return node.Update(node.RefKind, expressionOpt);
        }
        public override LoweredNode? VisitYieldReturnStatement(LoweredYieldReturnStatement node)
        {
            LoweredExpression expression = (LoweredExpression)this.Visit(node.Expression);
            return node.Update(expression);
        }
        public override LoweredNode? VisitYieldBreakStatement(LoweredYieldBreakStatement node) => node;
        public override LoweredNode? VisitThrowStatement(LoweredThrowStatement node)
        {
            LoweredExpression? expressionOpt = (LoweredExpression?)this.Visit(node.ExpressionOpt);
            return node.Update(expressionOpt);
        }
        public override LoweredNode? VisitExpressionStatement(LoweredExpressionStatement node)
        {
            LoweredExpression expression = (LoweredExpression)this.Visit(node.Expression);
            return node.Update(expression);
        }
        public override LoweredNode? VisitBreakStatement(LoweredBreakStatement node) => node;
        public override LoweredNode? VisitContinueStatement(LoweredContinueStatement node) => node;
        public override LoweredNode? VisitSwitchStatement(LoweredSwitchStatement node)
        {
            LoweredExpression expression = (LoweredExpression)this.Visit(node.Expression);
            ImmutableArray<LoweredSwitchSection> switchSections = this.VisitList(node.SwitchSections);
            LoweredDecisionDag decisionDag = node.DecisionDag;
            LoweredSwitchLabel? defaultLabel = (LoweredSwitchLabel?)this.Visit(node.DefaultLabel);
            return node.Update(expression, node.InnerLocals, node.InnerLocalFunctions, switchSections, decisionDag, defaultLabel, node.BreakLabel);
        }
        public override LoweredNode? VisitSwitchDispatch(LoweredSwitchDispatch node)
        {
            LoweredExpression expression = (LoweredExpression)this.Visit(node.Expression);
            return node.Update(expression, node.Cases, node.DefaultLabel, node.EqualityMethod);
        }
        public override LoweredNode? VisitIfStatement(LoweredIfStatement node)
        {
            LoweredExpression condition = (LoweredExpression)this.Visit(node.Condition);
            LoweredStatement consequence = (LoweredStatement)this.Visit(node.Consequence);
            LoweredStatement? alternativeOpt = (LoweredStatement?)this.Visit(node.AlternativeOpt);
            return node.Update(condition, consequence, alternativeOpt);
        }
        public override LoweredNode? VisitDoStatement(LoweredDoStatement node)
        {
            LoweredExpression condition = (LoweredExpression)this.Visit(node.Condition);
            LoweredStatement body = (LoweredStatement)this.Visit(node.Body);
            return node.Update(node.Locals, condition, body, node.BreakLabel, node.ContinueLabel);
        }
        public override LoweredNode? VisitWhileStatement(LoweredWhileStatement node)
        {
            LoweredExpression condition = (LoweredExpression)this.Visit(node.Condition);
            LoweredStatement body = (LoweredStatement)this.Visit(node.Body);
            return node.Update(node.Locals, condition, body, node.BreakLabel, node.ContinueLabel);
        }
        public override LoweredNode? VisitForStatement(LoweredForStatement node)
        {
            LoweredStatement? initializer = (LoweredStatement?)this.Visit(node.Initializer);
            LoweredExpression? condition = (LoweredExpression?)this.Visit(node.Condition);
            LoweredStatement? increment = (LoweredStatement?)this.Visit(node.Increment);
            LoweredStatement body = (LoweredStatement)this.Visit(node.Body);
            return node.Update(node.OuterLocals, initializer, node.InnerLocals, condition, increment, body, node.BreakLabel, node.ContinueLabel);
        }
        public override LoweredNode? VisitForEachStatement(LoweredForEachStatement node)
        {
            LoweredTypeExpression iterationVariableType = (LoweredTypeExpression)this.Visit(node.IterationVariableType);
            LoweredExpression? iterationErrorExpressionOpt = (LoweredExpression?)this.Visit(node.IterationErrorExpressionOpt);
            LoweredExpression expression = (LoweredExpression)this.Visit(node.Expression);
            LoweredForEachDeconstructStep? deconstructionOpt = (LoweredForEachDeconstructStep?)this.Visit(node.DeconstructionOpt);
            LoweredAwaitableInfo? awaitOpt = (LoweredAwaitableInfo?)this.Visit(node.AwaitOpt);
            LoweredStatement body = (LoweredStatement)this.Visit(node.Body);
            return node.Update(node.EnumeratorInfoOpt, node.ElementConversion, iterationVariableType, node.IterationVariables, iterationErrorExpressionOpt, expression, deconstructionOpt, awaitOpt, body, node.Checked, node.BreakLabel, node.ContinueLabel);
        }
        public override LoweredNode? VisitForEachDeconstructStep(LoweredForEachDeconstructStep node)
        {
            LoweredDeconstructionAssignmentOperator deconstructionAssignment = (LoweredDeconstructionAssignmentOperator)this.Visit(node.DeconstructionAssignment);
            LoweredDeconstructValuePlaceholder targetPlaceholder = (LoweredDeconstructValuePlaceholder)this.Visit(node.TargetPlaceholder);
            return node.Update(deconstructionAssignment, targetPlaceholder);
        }
        public override LoweredNode? VisitUsingStatement(LoweredUsingStatement node)
        {
            LoweredMultipleLocalDeclarations? declarationsOpt = (LoweredMultipleLocalDeclarations?)this.Visit(node.DeclarationsOpt);
            LoweredExpression? expressionOpt = (LoweredExpression?)this.Visit(node.ExpressionOpt);
            LoweredStatement body = (LoweredStatement)this.Visit(node.Body);
            LoweredAwaitableInfo? awaitOpt = (LoweredAwaitableInfo?)this.Visit(node.AwaitOpt);
            return node.Update(node.Locals, declarationsOpt, expressionOpt, node.IDisposableConversion, body, awaitOpt, node.DisposeMethodOpt);
        }
        public override LoweredNode? VisitFixedStatement(LoweredFixedStatement node)
        {
            LoweredMultipleLocalDeclarations declarations = (LoweredMultipleLocalDeclarations)this.Visit(node.Declarations);
            LoweredStatement body = (LoweredStatement)this.Visit(node.Body);
            return node.Update(node.Locals, declarations, body);
        }
        public override LoweredNode? VisitLockStatement(LoweredLockStatement node)
        {
            LoweredExpression argument = (LoweredExpression)this.Visit(node.Argument);
            LoweredStatement body = (LoweredStatement)this.Visit(node.Body);
            return node.Update(argument, body);
        }
        public override LoweredNode? VisitTryStatement(LoweredTryStatement node)
        {
            LoweredBlock tryBlock = (LoweredBlock)this.Visit(node.TryBlock);
            ImmutableArray<LoweredCatchBlock> catchBlocks = this.VisitList(node.CatchBlocks);
            LoweredBlock? finallyBlockOpt = (LoweredBlock?)this.Visit(node.FinallyBlockOpt);
            return node.Update(tryBlock, catchBlocks, finallyBlockOpt, node.FinallyLabelOpt, node.PreferFaultHandler);
        }
        public override LoweredNode? VisitCatchBlock(LoweredCatchBlock node)
        {
            LoweredExpression? exceptionSourceOpt = (LoweredExpression?)this.Visit(node.ExceptionSourceOpt);
            LoweredExpression? exceptionFilterOpt = (LoweredExpression?)this.Visit(node.ExceptionFilterOpt);
            LoweredBlock body = (LoweredBlock)this.Visit(node.Body);
            TypeSymbol exceptionTypeOpt = this.VisitType(node.ExceptionTypeOpt);
            return node.Update(node.Locals, exceptionSourceOpt, exceptionTypeOpt, exceptionFilterOpt, body, node.IsSynthesizedAsyncCatchAll);
        }
        public override LoweredNode? VisitLiteral(LoweredLiteral node)
        {
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(node.ConstantValueOpt, type);
        }
        public override LoweredNode? VisitThisReference(LoweredThisReference node)
        {
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(type);
        }
        public override LoweredNode? VisitPreviousSubmissionReference(LoweredPreviousSubmissionReference node)
        {
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(type);
        }
        public override LoweredNode? VisitHostObjectMemberReference(LoweredHostObjectMemberReference node)
        {
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(type);
        }
        public override LoweredNode? VisitBaseReference(LoweredBaseReference node)
        {
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(type);
        }
        public override LoweredNode? VisitLocal(LoweredLocal node)
        {
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(node.LocalSymbol, node.DeclarationKind, node.ConstantValueOpt, node.IsNullableUnknown, type);
        }
        public override LoweredNode? VisitPseudoVariable(LoweredPseudoVariable node)
        {
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(node.LocalSymbol, node.EmitExpressions, type);
        }
        public override LoweredNode? VisitRangeVariable(LoweredRangeVariable node)
        {
            LoweredExpression value = (LoweredExpression)this.Visit(node.Value);
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(node.RangeVariableSymbol, value, type);
        }
        public override LoweredNode? VisitParameter(LoweredParameter node)
        {
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(node.ParameterSymbol, type);
        }
        public override LoweredNode? VisitLabelStatement(LoweredLabelStatement node) => node;
        public override LoweredNode? VisitGotoStatement(LoweredGotoStatement node)
        {
            LoweredExpression? caseExpressionOpt = (LoweredExpression?)this.Visit(node.CaseExpressionOpt);
            LoweredLabel? labelExpressionOpt = (LoweredLabel?)this.Visit(node.LabelExpressionOpt);
            return node.Update(node.Label, caseExpressionOpt, labelExpressionOpt);
        }
        public override LoweredNode? VisitLabeledStatement(LoweredLabeledStatement node)
        {
            LoweredStatement body = (LoweredStatement)this.Visit(node.Body);
            return node.Update(node.Label, body);
        }
        public override LoweredNode? VisitLabel(LoweredLabel node)
        {
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(node.Label, type);
        }
        public override LoweredNode? VisitStatementList(LoweredStatementList node)
        {
            ImmutableArray<LoweredStatement> statements = this.VisitList(node.Statements);
            return node.Update(statements);
        }
        public override LoweredNode? VisitConditionalGoto(LoweredConditionalGoto node)
        {
            LoweredExpression condition = (LoweredExpression)this.Visit(node.Condition);
            return node.Update(condition, node.JumpIfTrue, node.Label);
        }
        public override LoweredNode? VisitSwitchExpressionArm(LoweredSwitchExpressionArm node)
        {
            LoweredPattern pattern = (LoweredPattern)this.Visit(node.Pattern);
            LoweredExpression? whenClause = (LoweredExpression?)this.Visit(node.WhenClause);
            LoweredExpression value = (LoweredExpression)this.Visit(node.Value);
            return node.Update(node.Locals, pattern, whenClause, value, node.Label);
        }
        public override LoweredNode? VisitUnconvertedSwitchExpression(LoweredUnconvertedSwitchExpression node)
        {
            LoweredExpression expression = (LoweredExpression)this.Visit(node.Expression);
            ImmutableArray<LoweredSwitchExpressionArm> switchArms = this.VisitList(node.SwitchArms);
            LoweredDecisionDag decisionDag = node.DecisionDag;
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(expression, switchArms, decisionDag, node.DefaultLabel, node.ReportedNotExhaustive, type);
        }
        public override LoweredNode? VisitConvertedSwitchExpression(LoweredConvertedSwitchExpression node)
        {
            LoweredExpression expression = (LoweredExpression)this.Visit(node.Expression);
            ImmutableArray<LoweredSwitchExpressionArm> switchArms = this.VisitList(node.SwitchArms);
            LoweredDecisionDag decisionDag = node.DecisionDag;
            TypeSymbol naturalTypeOpt = this.VisitType(node.NaturalTypeOpt);
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(naturalTypeOpt, node.WasTargetTyped, expression, switchArms, decisionDag, node.DefaultLabel, node.ReportedNotExhaustive, type);
        }
        public override LoweredNode? VisitDecisionDag(LoweredDecisionDag node) => node;
        public override LoweredNode? VisitEvaluationDecisionDagNode(LoweredEvaluationDecisionDagNode node)
        {
            LoweredDagEvaluation evaluation = (LoweredDagEvaluation)this.Visit(node.Evaluation);
            LoweredDecisionDagNode  next = (LoweredDecisionDagNode )this.Visit(node.Next);
            return node.Update(evaluation, next);
        }
        public override LoweredNode? VisitTestDecisionDagNode(LoweredTestDecisionDagNode node)
        {
            LoweredDagTest test = (LoweredDagTest)this.Visit(node.Test);
            LoweredDecisionDagNode  whenTrue = (LoweredDecisionDagNode )this.Visit(node.WhenTrue);
            LoweredDecisionDagNode  whenFalse = (LoweredDecisionDagNode )this.Visit(node.WhenFalse);
            return node.Update(test, whenTrue, whenFalse);
        }
        public override LoweredNode? VisitWhenDecisionDagNode(LoweredWhenDecisionDagNode node)
        {
            LoweredExpression? whenExpression = (LoweredExpression?)this.Visit(node.WhenExpression);
            LoweredDecisionDagNode  whenTrue = (LoweredDecisionDagNode )this.Visit(node.WhenTrue);
            LoweredDecisionDagNode ? whenFalse = (LoweredDecisionDagNode ?)this.Visit(node.WhenFalse);
            return node.Update(node.Bindings, whenExpression, whenTrue, whenFalse);
        }
        public override LoweredNode? VisitLeafDecisionDagNode(LoweredLeafDecisionDagNode node) => node;
        public override LoweredNode? VisitDagTemp(LoweredDagTemp node)
        {
            LoweredDagEvaluation? source = (LoweredDagEvaluation?)this.Visit(node.Source);
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(type, source, node.Index);
        }
        public override LoweredNode? VisitDagTypeTest(LoweredDagTypeTest node)
        {
            LoweredDagTemp input = (LoweredDagTemp)this.Visit(node.Input);
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(type, input);
        }
        public override LoweredNode? VisitDagNonNullTest(LoweredDagNonNullTest node)
        {
            LoweredDagTemp input = (LoweredDagTemp)this.Visit(node.Input);
            return node.Update(node.IsExplicitTest, input);
        }
        public override LoweredNode? VisitDagExplicitNullTest(LoweredDagExplicitNullTest node)
        {
            LoweredDagTemp input = (LoweredDagTemp)this.Visit(node.Input);
            return node.Update(input);
        }
        public override LoweredNode? VisitDagValueTest(LoweredDagValueTest node)
        {
            LoweredDagTemp input = (LoweredDagTemp)this.Visit(node.Input);
            return node.Update(node.Value, input);
        }
        public override LoweredNode? VisitDagDeconstructEvaluation(LoweredDagDeconstructEvaluation node)
        {
            LoweredDagTemp input = (LoweredDagTemp)this.Visit(node.Input);
            return node.Update(node.DeconstructMethod, input);
        }
        public override LoweredNode? VisitDagTypeEvaluation(LoweredDagTypeEvaluation node)
        {
            LoweredDagTemp input = (LoweredDagTemp)this.Visit(node.Input);
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(type, input);
        }
        public override LoweredNode? VisitDagFieldEvaluation(LoweredDagFieldEvaluation node)
        {
            LoweredDagTemp input = (LoweredDagTemp)this.Visit(node.Input);
            return node.Update(node.Field, input);
        }
        public override LoweredNode? VisitDagPropertyEvaluation(LoweredDagPropertyEvaluation node)
        {
            LoweredDagTemp input = (LoweredDagTemp)this.Visit(node.Input);
            return node.Update(node.Property, input);
        }
        public override LoweredNode? VisitDagIndexEvaluation(LoweredDagIndexEvaluation node)
        {
            LoweredDagTemp input = (LoweredDagTemp)this.Visit(node.Input);
            return node.Update(node.Property, node.Index, input);
        }
        public override LoweredNode? VisitSwitchSection(LoweredSwitchSection node)
        {
            ImmutableArray<LoweredSwitchLabel> switchLabels = this.VisitList(node.SwitchLabels);
            ImmutableArray<LoweredStatement> statements = this.VisitList(node.Statements);
            return node.Update(node.Locals, switchLabels, statements);
        }
        public override LoweredNode? VisitSwitchLabel(LoweredSwitchLabel node)
        {
            LoweredPattern pattern = (LoweredPattern)this.Visit(node.Pattern);
            LoweredExpression? whenClause = (LoweredExpression?)this.Visit(node.WhenClause);
            return node.Update(node.Label, pattern, whenClause);
        }
        public override LoweredNode? VisitSequencePointExpression(LoweredSequencePointExpression node)
        {
            LoweredExpression expression = (LoweredExpression)this.Visit(node.Expression);
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(expression, type);
        }
        public override LoweredNode? VisitSequence(LoweredSequence node)
        {
            ImmutableArray<LoweredExpression> sideEffects = this.VisitList(node.SideEffects);
            LoweredExpression value = (LoweredExpression)this.Visit(node.Value);
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(node.Locals, sideEffects, value, type);
        }
        public override LoweredNode? VisitSpillSequence(LoweredSpillSequence node)
        {
            ImmutableArray<LoweredStatement> sideEffects = this.VisitList(node.SideEffects);
            LoweredExpression value = (LoweredExpression)this.Visit(node.Value);
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(node.Locals, sideEffects, value, type);
        }
        public override LoweredNode? VisitDynamicMemberAccess(LoweredDynamicMemberAccess node)
        {
            LoweredExpression receiver = (LoweredExpression)this.Visit(node.Receiver);
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(receiver, node.TypeArgumentsOpt, node.Name, node.Invoked, node.Indexed, type);
        }
        public override LoweredNode? VisitDynamicInvocation(LoweredDynamicInvocation node)
        {
            LoweredExpression expression = (LoweredExpression)this.Visit(node.Expression);
            ImmutableArray<LoweredExpression> arguments = this.VisitList(node.Arguments);
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(node.ArgumentNamesOpt, node.ArgumentRefKindsOpt, node.ApplicableMethods, expression, arguments, type);
        }
        public override LoweredNode? VisitConditionalAccess(LoweredConditionalAccess node)
        {
            LoweredExpression receiver = (LoweredExpression)this.Visit(node.Receiver);
            LoweredExpression accessExpression = (LoweredExpression)this.Visit(node.AccessExpression);
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(receiver, accessExpression, type);
        }
        public override LoweredNode? VisitLoweredConditionalAccess(LoweredLoweredConditionalAccess node)
        {
            LoweredExpression receiver = (LoweredExpression)this.Visit(node.Receiver);
            LoweredExpression whenNotNull = (LoweredExpression)this.Visit(node.WhenNotNull);
            LoweredExpression? whenNullOpt = (LoweredExpression?)this.Visit(node.WhenNullOpt);
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(receiver, node.HasValueMethodOpt, whenNotNull, whenNullOpt, node.Id, type);
        }
        public override LoweredNode? VisitConditionalReceiver(LoweredConditionalReceiver node)
        {
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(node.Id, type);
        }
        public override LoweredNode? VisitComplexConditionalReceiver(LoweredComplexConditionalReceiver node)
        {
            LoweredExpression valueTypeReceiver = (LoweredExpression)this.Visit(node.ValueTypeReceiver);
            LoweredExpression referenceTypeReceiver = (LoweredExpression)this.Visit(node.ReferenceTypeReceiver);
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(valueTypeReceiver, referenceTypeReceiver, type);
        }
        public override LoweredNode? VisitMethodGroup(LoweredMethodGroup node)
        {
            LoweredExpression? receiverOpt = (LoweredExpression?)this.Visit(node.ReceiverOpt);
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(node.TypeArgumentsOpt, node.Name, node.Methods, node.LookupSymbolOpt, node.LookupError, node.Flags, receiverOpt, node.ResultKind);
        }
        public override LoweredNode? VisitPropertyGroup(LoweredPropertyGroup node)
        {
            LoweredExpression? receiverOpt = (LoweredExpression?)this.Visit(node.ReceiverOpt);
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(node.Properties, receiverOpt, node.ResultKind);
        }
        public override LoweredNode? VisitCall(LoweredCall node)
        {
            LoweredExpression? receiverOpt = (LoweredExpression?)this.Visit(node.ReceiverOpt);
            ImmutableArray<LoweredExpression> arguments = this.VisitList(node.Arguments);
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(receiverOpt, node.Method, arguments, node.ArgumentNamesOpt, node.ArgumentRefKindsOpt, node.IsDelegateCall, node.Expanded, node.InvokedAsExtensionMethod, node.ArgsToParamsOpt, node.ResultKind, node.OriginalMethodsOpt, node.BinderOpt, type);
        }
        public override LoweredNode? VisitEventAssignmentOperator(LoweredEventAssignmentOperator node)
        {
            LoweredExpression? receiverOpt = (LoweredExpression?)this.Visit(node.ReceiverOpt);
            LoweredExpression argument = (LoweredExpression)this.Visit(node.Argument);
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(node.Event, node.IsAddition, node.IsDynamic, receiverOpt, argument, type);
        }
        public override LoweredNode? VisitAttribute(LoweredAttribute node)
        {
            ImmutableArray<LoweredExpression> constructorArguments = this.VisitList(node.ConstructorArguments);
            ImmutableArray<LoweredExpression> namedArguments = this.VisitList(node.NamedArguments);
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(node.Constructor, constructorArguments, node.ConstructorArgumentNamesOpt, node.ConstructorArgumentsToParamsOpt, node.ConstructorExpanded, namedArguments, node.ResultKind, type);
        }
        public override LoweredNode? VisitObjectCreationExpression(LoweredObjectCreationExpression node)
        {
            ImmutableArray<LoweredExpression> arguments = this.VisitList(node.Arguments);
            LoweredObjectInitializerExpressionBase? initializerExpressionOpt = (LoweredObjectInitializerExpressionBase?)this.Visit(node.InitializerExpressionOpt);
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(node.Constructor, node.ConstructorsGroup, arguments, node.ArgumentNamesOpt, node.ArgumentRefKindsOpt, node.Expanded, node.ArgsToParamsOpt, node.ConstantValueOpt, initializerExpressionOpt, node.BinderOpt, type);
        }
        public override LoweredNode? VisitTupleLiteral(LoweredTupleLiteral node)
        {
            ImmutableArray<LoweredExpression> arguments = this.VisitList(node.Arguments);
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(arguments, node.ArgumentNamesOpt, node.InferredNamesOpt, type);
        }
        public override LoweredNode? VisitConvertedTupleLiteral(LoweredConvertedTupleLiteral node)
        {
            LoweredTupleLiteral? sourceTuple = node.SourceTuple;
            ImmutableArray<LoweredExpression> arguments = this.VisitList(node.Arguments);
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(sourceTuple, node.WasTargetTyped, arguments, node.ArgumentNamesOpt, node.InferredNamesOpt, type);
        }
        public override LoweredNode? VisitDynamicObjectCreationExpression(LoweredDynamicObjectCreationExpression node)
        {
            ImmutableArray<LoweredExpression> arguments = this.VisitList(node.Arguments);
            LoweredObjectInitializerExpressionBase? initializerExpressionOpt = (LoweredObjectInitializerExpressionBase?)this.Visit(node.InitializerExpressionOpt);
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(node.Name, arguments, node.ArgumentNamesOpt, node.ArgumentRefKindsOpt, initializerExpressionOpt, node.ApplicableMethods, type);
        }
        public override LoweredNode? VisitNoPiaObjectCreationExpression(LoweredNoPiaObjectCreationExpression node)
        {
            LoweredObjectInitializerExpressionBase? initializerExpressionOpt = (LoweredObjectInitializerExpressionBase?)this.Visit(node.InitializerExpressionOpt);
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(node.GuidString, initializerExpressionOpt, type);
        }
        public override LoweredNode? VisitObjectInitializerExpression(LoweredObjectInitializerExpression node)
        {
            LoweredObjectOrCollectionValuePlaceholder placeholder = (LoweredObjectOrCollectionValuePlaceholder)this.Visit(node.Placeholder);
            ImmutableArray<LoweredExpression> initializers = this.VisitList(node.Initializers);
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(placeholder, initializers, type);
        }
        public override LoweredNode? VisitObjectInitializerMember(LoweredObjectInitializerMember node)
        {
            ImmutableArray<LoweredExpression> arguments = this.VisitList(node.Arguments);
            TypeSymbol receiverType = this.VisitType(node.ReceiverType);
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(node.MemberSymbol, arguments, node.ArgumentNamesOpt, node.ArgumentRefKindsOpt, node.Expanded, node.ArgsToParamsOpt, node.ResultKind, receiverType, node.BinderOpt, type);
        }
        public override LoweredNode? VisitDynamicObjectInitializerMember(LoweredDynamicObjectInitializerMember node)
        {
            TypeSymbol receiverType = this.VisitType(node.ReceiverType);
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(node.MemberName, receiverType, type);
        }
        public override LoweredNode? VisitCollectionInitializerExpression(LoweredCollectionInitializerExpression node)
        {
            LoweredObjectOrCollectionValuePlaceholder placeholder = (LoweredObjectOrCollectionValuePlaceholder)this.Visit(node.Placeholder);
            ImmutableArray<LoweredExpression> initializers = this.VisitList(node.Initializers);
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(placeholder, initializers, type);
        }
        public override LoweredNode? VisitCollectionElementInitializer(LoweredCollectionElementInitializer node)
        {
            ImmutableArray<LoweredExpression> arguments = this.VisitList(node.Arguments);
            LoweredExpression? implicitReceiverOpt = (LoweredExpression?)this.Visit(node.ImplicitReceiverOpt);
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(node.AddMethod, arguments, implicitReceiverOpt, node.Expanded, node.ArgsToParamsOpt, node.InvokedAsExtensionMethod, node.ResultKind, node.BinderOpt, type);
        }
        public override LoweredNode? VisitDynamicCollectionElementInitializer(LoweredDynamicCollectionElementInitializer node)
        {
            LoweredExpression expression = (LoweredExpression)this.Visit(node.Expression);
            ImmutableArray<LoweredExpression> arguments = this.VisitList(node.Arguments);
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(node.ApplicableMethods, expression, arguments, type);
        }
        public override LoweredNode? VisitImplicitReceiver(LoweredImplicitReceiver node)
        {
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(type);
        }
        public override LoweredNode? VisitAnonymousObjectCreationExpression(LoweredAnonymousObjectCreationExpression node)
        {
            ImmutableArray<LoweredExpression> arguments = this.VisitList(node.Arguments);
            ImmutableArray<LoweredAnonymousPropertyDeclaration> declarations = this.VisitList(node.Declarations);
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(node.Constructor, arguments, declarations, type);
        }
        public override LoweredNode? VisitAnonymousPropertyDeclaration(LoweredAnonymousPropertyDeclaration node)
        {
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(node.Property, type);
        }
        public override LoweredNode? VisitNewT(LoweredNewT node)
        {
            LoweredObjectInitializerExpressionBase? initializerExpressionOpt = (LoweredObjectInitializerExpressionBase?)this.Visit(node.InitializerExpressionOpt);
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(initializerExpressionOpt, type);
        }
        public override LoweredNode? VisitDelegateCreationExpression(LoweredDelegateCreationExpression node)
        {
            LoweredExpression argument = (LoweredExpression)this.Visit(node.Argument);
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(argument, node.MethodOpt, node.IsExtensionMethod, type);
        }
        public override LoweredNode? VisitArrayCreation(LoweredArrayCreation node)
        {
            ImmutableArray<LoweredExpression> bounds = this.VisitList(node.Lowereds);
            LoweredArrayInitialization? initializerOpt = (LoweredArrayInitialization?)this.Visit(node.InitializerOpt);
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(bounds, initializerOpt, type);
        }
        public override LoweredNode? VisitArrayInitialization(LoweredArrayInitialization node)
        {
            ImmutableArray<LoweredExpression> initializers = this.VisitList(node.Initializers);
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(initializers);
        }
        public override LoweredNode? VisitStackAllocArrayCreation(LoweredStackAllocArrayCreation node)
        {
            LoweredExpression count = (LoweredExpression)this.Visit(node.Count);
            LoweredArrayInitialization? initializerOpt = (LoweredArrayInitialization?)this.Visit(node.InitializerOpt);
            TypeSymbol elementType = this.VisitType(node.ElementType);
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(elementType, count, initializerOpt, type);
        }
        public override LoweredNode? VisitConvertedStackAllocExpression(LoweredConvertedStackAllocExpression node)
        {
            LoweredExpression count = (LoweredExpression)this.Visit(node.Count);
            LoweredArrayInitialization? initializerOpt = (LoweredArrayInitialization?)this.Visit(node.InitializerOpt);
            TypeSymbol elementType = this.VisitType(node.ElementType);
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(elementType, count, initializerOpt, type);
        }
        public override LoweredNode? VisitFieldAccess(LoweredFieldAccess node)
        {
            LoweredExpression? receiverOpt = (LoweredExpression?)this.Visit(node.ReceiverOpt);
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(receiverOpt, node.FieldSymbol, node.ConstantValueOpt, node.ResultKind, node.IsByValue, node.IsDeclaration, type);
        }
        public override LoweredNode? VisitHoistedFieldAccess(LoweredHoistedFieldAccess node)
        {
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(node.FieldSymbol, type);
        }
        public override LoweredNode? VisitPropertyAccess(LoweredPropertyAccess node)
        {
            LoweredExpression? receiverOpt = (LoweredExpression?)this.Visit(node.ReceiverOpt);
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(receiverOpt, node.PropertySymbol, node.ResultKind, type);
        }
        public override LoweredNode? VisitEventAccess(LoweredEventAccess node)
        {
            LoweredExpression? receiverOpt = (LoweredExpression?)this.Visit(node.ReceiverOpt);
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(receiverOpt, node.EventSymbol, node.IsUsableAsField, node.ResultKind, type);
        }
        public override LoweredNode? VisitIndexerAccess(LoweredIndexerAccess node)
        {
            LoweredExpression? receiverOpt = (LoweredExpression?)this.Visit(node.ReceiverOpt);
            ImmutableArray<LoweredExpression> arguments = this.VisitList(node.Arguments);
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(receiverOpt, node.Indexer, arguments, node.ArgumentNamesOpt, node.ArgumentRefKindsOpt, node.Expanded, node.ArgsToParamsOpt, node.BinderOpt, node.UseSetterForDefaultArgumentGeneration, node.OriginalIndexersOpt, type);
        }
        public override LoweredNode? VisitIndexOrRangePatternIndexerAccess(LoweredIndexOrRangePatternIndexerAccess node)
        {
            LoweredExpression receiver = (LoweredExpression)this.Visit(node.Receiver);
            LoweredExpression argument = (LoweredExpression)this.Visit(node.Argument);
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(receiver, node.LengthOrCountProperty, node.PatternSymbol, argument, type);
        }
        public override LoweredNode? VisitDynamicIndexerAccess(LoweredDynamicIndexerAccess node)
        {
            LoweredExpression? receiverOpt = (LoweredExpression?)this.Visit(node.ReceiverOpt);
            ImmutableArray<LoweredExpression> arguments = this.VisitList(node.Arguments);
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(receiverOpt, arguments, node.ArgumentNamesOpt, node.ArgumentRefKindsOpt, node.ApplicableIndexers, type);
        }
        public override LoweredNode? VisitLambda(LoweredLambda node)
        {
            UnboundLambda unboundLambda = node.UnboundLambda;
            LoweredBlock body = (LoweredBlock)this.Visit(node.Body);
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(unboundLambda, node.Symbol, body, node.Diagnostics, node.Binder, type);
        }
        public override LoweredNode? VisitUnboundLambda(UnboundLambda node)
        {
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(node.Data);
        }
        public override LoweredNode? VisitQueryClause(LoweredQueryClause node)
        {
            LoweredExpression value = (LoweredExpression)this.Visit(node.Value);
            LoweredExpression? operation = node.Operation;
            LoweredExpression? cast = node.Cast;
            LoweredExpression? unoptimizedForm = node.UnoptimizedForm;
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(value, node.DefinedSymbol, operation, cast, node.Binder, unoptimizedForm, type);
        }
        public override LoweredNode? VisitTypeOrInstanceInitializers(LoweredTypeOrInstanceInitializers node)
        {
            ImmutableArray<LoweredStatement> statements = this.VisitList(node.Statements);
            return node.Update(statements);
        }
        public override LoweredNode? VisitNameOfOperator(LoweredNameOfOperator node)
        {
            LoweredExpression argument = (LoweredExpression)this.Visit(node.Argument);
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(argument, node.ConstantValueOpt, type);
        }
        public override LoweredNode? VisitInterpolatedString(LoweredInterpolatedString node)
        {
            ImmutableArray<LoweredExpression> parts = this.VisitList(node.Parts);
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(parts, type);
        }
        public override LoweredNode? VisitStringInsert(LoweredStringInsert node)
        {
            LoweredExpression value = (LoweredExpression)this.Visit(node.Value);
            LoweredExpression? alignment = (LoweredExpression?)this.Visit(node.Alignment);
            LoweredLiteral? format = (LoweredLiteral?)this.Visit(node.Format);
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(value, alignment, format, type);
        }
        public override LoweredNode? VisitIsPatternExpression(LoweredIsPatternExpression node)
        {
            LoweredExpression expression = (LoweredExpression)this.Visit(node.Expression);
            LoweredPattern pattern = (LoweredPattern)this.Visit(node.Pattern);
            LoweredDecisionDag decisionDag = node.DecisionDag;
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(expression, pattern, decisionDag, node.WhenTrueLabel, node.WhenFalseLabel, type);
        }
        public override LoweredNode? VisitConstantPattern(LoweredConstantPattern node)
        {
            LoweredExpression value = (LoweredExpression)this.Visit(node.Value);
            TypeSymbol inputType = this.VisitType(node.InputType);
            return node.Update(value, node.ConstantValue, inputType);
        }
        public override LoweredNode? VisitDiscardPattern(LoweredDiscardPattern node)
        {
            TypeSymbol inputType = this.VisitType(node.InputType);
            return node.Update(inputType);
        }
        public override LoweredNode? VisitDeclarationPattern(LoweredDeclarationPattern node)
        {
            LoweredExpression? variableAccess = (LoweredExpression?)this.Visit(node.VariableAccess);
            LoweredTypeExpression? declaredType = (LoweredTypeExpression?)this.Visit(node.DeclaredType);
            TypeSymbol inputType = this.VisitType(node.InputType);
            return node.Update(node.Variable, variableAccess, declaredType, node.IsVar, inputType);
        }
        public override LoweredNode? VisitRecursivePattern(LoweredRecursivePattern node)
        {
            LoweredTypeExpression? declaredType = (LoweredTypeExpression?)this.Visit(node.DeclaredType);
            ImmutableArray<LoweredSubpattern> deconstruction = this.VisitList(node.Deconstruction);
            ImmutableArray<LoweredSubpattern> properties = this.VisitList(node.Properties);
            LoweredExpression? variableAccess = (LoweredExpression?)this.Visit(node.VariableAccess);
            TypeSymbol inputType = this.VisitType(node.InputType);
            return node.Update(declaredType, node.DeconstructMethod, deconstruction, properties, node.Variable, variableAccess, node.IsExplicitNotNullTest, inputType);
        }
        public override LoweredNode? VisitITuplePattern(LoweredITuplePattern node)
        {
            ImmutableArray<LoweredSubpattern> subpatterns = this.VisitList(node.Subpatterns);
            TypeSymbol inputType = this.VisitType(node.InputType);
            return node.Update(node.GetLengthMethod, node.GetItemMethod, subpatterns, inputType);
        }
        public override LoweredNode? VisitSubpattern(LoweredSubpattern node)
        {
            LoweredPattern pattern = (LoweredPattern)this.Visit(node.Pattern);
            return node.Update(node.Symbol, pattern);
        }
        public override LoweredNode? VisitDiscardExpression(LoweredDiscardExpression node)
        {
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(type);
        }
        public override LoweredNode? VisitThrowExpression(LoweredThrowExpression node)
        {
            LoweredExpression expression = (LoweredExpression)this.Visit(node.Expression);
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(expression, type);
        }
        public override LoweredNode? VisitOutVariablePendingInference(OutVariablePendingInference node)
        {
            LoweredExpression? receiverOpt = (LoweredExpression?)this.Visit(node.ReceiverOpt);
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(node.VariableSymbol, receiverOpt);
        }
        public override LoweredNode? VisitDeconstructionVariablePendingInference(DeconstructionVariablePendingInference node)
        {
            LoweredExpression? receiverOpt = (LoweredExpression?)this.Visit(node.ReceiverOpt);
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(node.VariableSymbol, receiverOpt);
        }
        public override LoweredNode? VisitOutDeconstructVarPendingInference(OutDeconstructVarPendingInference node)
        {
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update();
        }
        public override LoweredNode? VisitNonConstructorMethodBody(LoweredNonConstructorMethodBody node)
        {
            LoweredBlock? blockBody = (LoweredBlock?)this.Visit(node.BlockBody);
            LoweredBlock? expressionBody = (LoweredBlock?)this.Visit(node.ExpressionBody);
            return node.Update(blockBody, expressionBody);
        }
        public override LoweredNode? VisitConstructorMethodBody(LoweredConstructorMethodBody node)
        {
            LoweredExpressionStatement? initializer = (LoweredExpressionStatement?)this.Visit(node.Initializer);
            LoweredBlock? blockBody = (LoweredBlock?)this.Visit(node.BlockBody);
            LoweredBlock? expressionBody = (LoweredBlock?)this.Visit(node.ExpressionBody);
            return node.Update(node.Locals, initializer, blockBody, expressionBody);
        }
        public override LoweredNode? VisitExpressionWithNullability(LoweredExpressionWithNullability node)
        {
            LoweredExpression expression = (LoweredExpression)this.Visit(node.Expression);
            TypeSymbol type = this.VisitType(node.Type);
            return node.Update(expression, node.NullableAnnotation, type);
        }
    }

    internal sealed partial class NullabilityRewriter : LoweredTreeRewriter
    {
        private readonly ImmutableDictionary<LoweredExpression, (NullabilityInfo Info, TypeSymbol Type)> _updatedNullabilities;
        private readonly NullableWalker.SnapshotManager? _snapshotManager;
        private readonly ImmutableDictionary<Symbol, Symbol>.Builder _remappedSymbols;

        public NullabilityRewriter(ImmutableDictionary<LoweredExpression, (NullabilityInfo Info, TypeSymbol Type)> updatedNullabilities, NullableWalker.SnapshotManager? snapshotManager, ImmutableDictionary<Symbol, Symbol>.Builder remappedSymbols)
        {
            _updatedNullabilities = updatedNullabilities;
            _snapshotManager = snapshotManager;
            _remappedSymbols = remappedSymbols;
        }

        public override LoweredNode? VisitFieldEqualsValue(LoweredFieldEqualsValue node)
        {
            FieldSymbol field = GetUpdatedSymbol(node, node.Field);
            ImmutableArray<LocalSymbol> locals = GetUpdatedArray(node, node.Locals);
            LoweredExpression value = (LoweredExpression)this.Visit(node.Value);
            return node.Update(field, locals, value);
        }

        public override LoweredNode? VisitPropertyEqualsValue(LoweredPropertyEqualsValue node)
        {
            PropertySymbol property = GetUpdatedSymbol(node, node.Property);
            ImmutableArray<LocalSymbol> locals = GetUpdatedArray(node, node.Locals);
            LoweredExpression value = (LoweredExpression)this.Visit(node.Value);
            return node.Update(property, locals, value);
        }

        public override LoweredNode? VisitParameterEqualsValue(LoweredParameterEqualsValue node)
        {
            ParameterSymbol parameter = GetUpdatedSymbol(node, node.Parameter);
            ImmutableArray<LocalSymbol> locals = GetUpdatedArray(node, node.Locals);
            LoweredExpression value = (LoweredExpression)this.Visit(node.Value);
            return node.Update(parameter, locals, value);
        }

        public override LoweredNode? VisitDeconstructValuePlaceholder(LoweredDeconstructValuePlaceholder node)
        {
            if (!_updatedNullabilities.TryGetValue(node, out (NullabilityInfo Info, TypeSymbol Type) infoAndType))
            {
                return node;
            }

            LoweredDeconstructValuePlaceholder updatedNode = node.Update(node.ValEscape, infoAndType.Type);
            updatedNode.TopLevelNullability = infoAndType.Info;
            return updatedNode;
        }

        public override LoweredNode? VisitTupleOperandPlaceholder(LoweredTupleOperandPlaceholder node)
        {
            if (!_updatedNullabilities.TryGetValue(node, out (NullabilityInfo Info, TypeSymbol Type) infoAndType))
            {
                return node;
            }

            LoweredTupleOperandPlaceholder updatedNode = node.Update(infoAndType.Type);
            updatedNode.TopLevelNullability = infoAndType.Info;
            return updatedNode;
        }

        public override LoweredNode? VisitAwaitableValuePlaceholder(LoweredAwaitableValuePlaceholder node)
        {
            if (!_updatedNullabilities.TryGetValue(node, out (NullabilityInfo Info, TypeSymbol Type) infoAndType))
            {
                return node;
            }

            LoweredAwaitableValuePlaceholder updatedNode = node.Update(node.ValEscape, infoAndType.Type);
            updatedNode.TopLevelNullability = infoAndType.Info;
            return updatedNode;
        }

        public override LoweredNode? VisitDisposableValuePlaceholder(LoweredDisposableValuePlaceholder node)
        {
            if (!_updatedNullabilities.TryGetValue(node, out (NullabilityInfo Info, TypeSymbol Type) infoAndType))
            {
                return node;
            }

            LoweredDisposableValuePlaceholder updatedNode = node.Update(infoAndType.Type);
            updatedNode.TopLevelNullability = infoAndType.Info;
            return updatedNode;
        }

        public override LoweredNode? VisitObjectOrCollectionValuePlaceholder(LoweredObjectOrCollectionValuePlaceholder node)
        {
            if (!_updatedNullabilities.TryGetValue(node, out (NullabilityInfo Info, TypeSymbol Type) infoAndType))
            {
                return node;
            }

            LoweredObjectOrCollectionValuePlaceholder updatedNode = node.Update(infoAndType.Type);
            updatedNode.TopLevelNullability = infoAndType.Info;
            return updatedNode;
        }

        public override LoweredNode? VisitDup(LoweredDup node)
        {
            if (!_updatedNullabilities.TryGetValue(node, out (NullabilityInfo Info, TypeSymbol Type) infoAndType))
            {
                return node;
            }

            LoweredDup updatedNode = node.Update(node.RefKind, infoAndType.Type);
            updatedNode.TopLevelNullability = infoAndType.Info;
            return updatedNode;
        }

        public override LoweredNode? VisitPassByCopy(LoweredPassByCopy node)
        {
            LoweredExpression expression = (LoweredExpression)this.Visit(node.Expression);
            LoweredPassByCopy updatedNode;

            if (_updatedNullabilities.TryGetValue(node, out (NullabilityInfo Info, TypeSymbol Type) infoAndType))
            {
                updatedNode = node.Update(expression, infoAndType.Type);
                updatedNode.TopLevelNullability = infoAndType.Info;
            }
            else
            {
                updatedNode = node.Update(expression, node.Type);
            }
            return updatedNode;
        }

        public override LoweredNode? VisitBadExpression(LoweredBadExpression node)
        {
            ImmutableArray<Symbol?> symbols = GetUpdatedArray(node, node.Symbols);
            ImmutableArray<LoweredExpression> childLoweredNodes = this.VisitList(node.ChildLoweredNodes);
            LoweredBadExpression updatedNode;

            if (_updatedNullabilities.TryGetValue(node, out (NullabilityInfo Info, TypeSymbol Type) infoAndType))
            {
                updatedNode = node.Update(node.ResultKind, node.Symbols, childLoweredNodes, infoAndType.Type);
                updatedNode.TopLevelNullability = infoAndType.Info;
            }
            else
            {
                updatedNode = node.Update(node.ResultKind, node.Symbols, childLoweredNodes, node.Type);
            }
            return updatedNode;
        }

        public override LoweredNode? VisitTypeExpression(LoweredTypeExpression node)
        {
            LoweredTypeExpression? boundContainingTypeOpt = (LoweredTypeExpression?)this.Visit(node.LoweredContainingTypeOpt);
            ImmutableArray<LoweredExpression> boundDimensionsOpt = this.VisitList(node.LoweredDimensionsOpt);
            LoweredTypeExpression updatedNode;

            if (_updatedNullabilities.TryGetValue(node, out (NullabilityInfo Info, TypeSymbol Type) infoAndType))
            {
                updatedNode = node.Update(node.AliasOpt, boundContainingTypeOpt, boundDimensionsOpt, node.TypeWithAnnotations, infoAndType.Type);
                updatedNode.TopLevelNullability = infoAndType.Info;
            }
            else
            {
                updatedNode = node.Update(node.AliasOpt, boundContainingTypeOpt, boundDimensionsOpt, node.TypeWithAnnotations, node.Type);
            }
            return updatedNode;
        }

        public override LoweredNode? VisitTypeOrValueExpression(LoweredTypeOrValueExpression node)
        {
            if (!_updatedNullabilities.TryGetValue(node, out (NullabilityInfo Info, TypeSymbol Type) infoAndType))
            {
                return node;
            }

            LoweredTypeOrValueExpression updatedNode = node.Update(node.Data, infoAndType.Type);
            updatedNode.TopLevelNullability = infoAndType.Info;
            return updatedNode;
        }

        public override LoweredNode? VisitNamespaceExpression(LoweredNamespaceExpression node)
        {
            if (!_updatedNullabilities.TryGetValue(node, out (NullabilityInfo Info, TypeSymbol Type) infoAndType))
            {
                return node;
            }

            LoweredNamespaceExpression updatedNode = node.Update(node.NamespaceSymbol, node.AliasOpt);
            updatedNode.TopLevelNullability = infoAndType.Info;
            return updatedNode;
        }

        public override LoweredNode? VisitUnaryOperator(LoweredUnaryOperator node)
        {
            MethodSymbol? methodOpt = GetUpdatedSymbol(node, node.MethodOpt);
            ImmutableArray<MethodSymbol> originalUserDefinedOperatorsOpt = GetUpdatedArray(node, node.OriginalUserDefinedOperatorsOpt);
            LoweredExpression operand = (LoweredExpression)this.Visit(node.Operand);
            LoweredUnaryOperator updatedNode;

            if (_updatedNullabilities.TryGetValue(node, out (NullabilityInfo Info, TypeSymbol Type) infoAndType))
            {
                updatedNode = node.Update(node.OperatorKind, operand, node.ConstantValueOpt, methodOpt, node.ResultKind, node.OriginalUserDefinedOperatorsOpt, infoAndType.Type);
                updatedNode.TopLevelNullability = infoAndType.Info;
            }
            else
            {
                updatedNode = node.Update(node.OperatorKind, operand, node.ConstantValueOpt, methodOpt, node.ResultKind, node.OriginalUserDefinedOperatorsOpt, node.Type);
            }
            return updatedNode;
        }

        public override LoweredNode? VisitIncrementOperator(LoweredIncrementOperator node)
        {
            MethodSymbol? methodOpt = GetUpdatedSymbol(node, node.MethodOpt);
            ImmutableArray<MethodSymbol> originalUserDefinedOperatorsOpt = GetUpdatedArray(node, node.OriginalUserDefinedOperatorsOpt);
            LoweredExpression operand = (LoweredExpression)this.Visit(node.Operand);
            LoweredIncrementOperator updatedNode;

            if (_updatedNullabilities.TryGetValue(node, out (NullabilityInfo Info, TypeSymbol Type) infoAndType))
            {
                updatedNode = node.Update(node.OperatorKind, operand, methodOpt, node.OperandConversion, node.ResultConversion, node.ResultKind, node.OriginalUserDefinedOperatorsOpt, infoAndType.Type);
                updatedNode.TopLevelNullability = infoAndType.Info;
            }
            else
            {
                updatedNode = node.Update(node.OperatorKind, operand, methodOpt, node.OperandConversion, node.ResultConversion, node.ResultKind, node.OriginalUserDefinedOperatorsOpt, node.Type);
            }
            return updatedNode;
        }

        public override LoweredNode? VisitAddressOfOperator(LoweredAddressOfOperator node)
        {
            LoweredExpression operand = (LoweredExpression)this.Visit(node.Operand);
            LoweredAddressOfOperator updatedNode;

            if (_updatedNullabilities.TryGetValue(node, out (NullabilityInfo Info, TypeSymbol Type) infoAndType))
            {
                updatedNode = node.Update(operand, node.IsManaged, infoAndType.Type);
                updatedNode.TopLevelNullability = infoAndType.Info;
            }
            else
            {
                updatedNode = node.Update(operand, node.IsManaged, node.Type);
            }
            return updatedNode;
        }

        public override LoweredNode? VisitPointerIndirectionOperator(LoweredPointerIndirectionOperator node)
        {
            LoweredExpression operand = (LoweredExpression)this.Visit(node.Operand);
            LoweredPointerIndirectionOperator updatedNode;

            if (_updatedNullabilities.TryGetValue(node, out (NullabilityInfo Info, TypeSymbol Type) infoAndType))
            {
                updatedNode = node.Update(operand, infoAndType.Type);
                updatedNode.TopLevelNullability = infoAndType.Info;
            }
            else
            {
                updatedNode = node.Update(operand, node.Type);
            }
            return updatedNode;
        }

        public override LoweredNode? VisitPointerElementAccess(LoweredPointerElementAccess node)
        {
            LoweredExpression expression = (LoweredExpression)this.Visit(node.Expression);
            LoweredExpression index = (LoweredExpression)this.Visit(node.Index);
            LoweredPointerElementAccess updatedNode;

            if (_updatedNullabilities.TryGetValue(node, out (NullabilityInfo Info, TypeSymbol Type) infoAndType))
            {
                updatedNode = node.Update(expression, index, node.Checked, infoAndType.Type);
                updatedNode.TopLevelNullability = infoAndType.Info;
            }
            else
            {
                updatedNode = node.Update(expression, index, node.Checked, node.Type);
            }
            return updatedNode;
        }

        public override LoweredNode? VisitRefTypeOperator(LoweredRefTypeOperator node)
        {
            MethodSymbol? getTypeFromHandle = GetUpdatedSymbol(node, node.GetTypeFromHandle);
            LoweredExpression operand = (LoweredExpression)this.Visit(node.Operand);
            LoweredRefTypeOperator updatedNode;

            if (_updatedNullabilities.TryGetValue(node, out (NullabilityInfo Info, TypeSymbol Type) infoAndType))
            {
                updatedNode = node.Update(operand, getTypeFromHandle, infoAndType.Type);
                updatedNode.TopLevelNullability = infoAndType.Info;
            }
            else
            {
                updatedNode = node.Update(operand, getTypeFromHandle, node.Type);
            }
            return updatedNode;
        }

        public override LoweredNode? VisitMakeRefOperator(LoweredMakeRefOperator node)
        {
            LoweredExpression operand = (LoweredExpression)this.Visit(node.Operand);
            LoweredMakeRefOperator updatedNode;

            if (_updatedNullabilities.TryGetValue(node, out (NullabilityInfo Info, TypeSymbol Type) infoAndType))
            {
                updatedNode = node.Update(operand, infoAndType.Type);
                updatedNode.TopLevelNullability = infoAndType.Info;
            }
            else
            {
                updatedNode = node.Update(operand, node.Type);
            }
            return updatedNode;
        }

        public override LoweredNode? VisitRefValueOperator(LoweredRefValueOperator node)
        {
            LoweredExpression operand = (LoweredExpression)this.Visit(node.Operand);
            LoweredRefValueOperator updatedNode;

            if (_updatedNullabilities.TryGetValue(node, out (NullabilityInfo Info, TypeSymbol Type) infoAndType))
            {
                updatedNode = node.Update(node.NullableAnnotation, operand, infoAndType.Type);
                updatedNode.TopLevelNullability = infoAndType.Info;
            }
            else
            {
                updatedNode = node.Update(node.NullableAnnotation, operand, node.Type);
            }
            return updatedNode;
        }

        public override LoweredNode? VisitFromEndIndexExpression(LoweredFromEndIndexExpression node)
        {
            MethodSymbol? methodOpt = GetUpdatedSymbol(node, node.MethodOpt);
            LoweredExpression operand = (LoweredExpression)this.Visit(node.Operand);
            LoweredFromEndIndexExpression updatedNode;

            if (_updatedNullabilities.TryGetValue(node, out (NullabilityInfo Info, TypeSymbol Type) infoAndType))
            {
                updatedNode = node.Update(operand, methodOpt, infoAndType.Type);
                updatedNode.TopLevelNullability = infoAndType.Info;
            }
            else
            {
                updatedNode = node.Update(operand, methodOpt, node.Type);
            }
            return updatedNode;
        }

        public override LoweredNode? VisitRangeExpression(LoweredRangeExpression node)
        {
            MethodSymbol? methodOpt = GetUpdatedSymbol(node, node.MethodOpt);
            LoweredExpression? leftOperandOpt = (LoweredExpression?)this.Visit(node.LeftOperandOpt);
            LoweredExpression? rightOperandOpt = (LoweredExpression?)this.Visit(node.RightOperandOpt);
            LoweredRangeExpression updatedNode;

            if (_updatedNullabilities.TryGetValue(node, out (NullabilityInfo Info, TypeSymbol Type) infoAndType))
            {
                updatedNode = node.Update(leftOperandOpt, rightOperandOpt, methodOpt, infoAndType.Type);
                updatedNode.TopLevelNullability = infoAndType.Info;
            }
            else
            {
                updatedNode = node.Update(leftOperandOpt, rightOperandOpt, methodOpt, node.Type);
            }
            return updatedNode;
        }

        public override LoweredNode? VisitTupleBinaryOperator(LoweredTupleBinaryOperator node)
        {
            LoweredExpression left = (LoweredExpression)this.Visit(node.Left);
            LoweredExpression right = (LoweredExpression)this.Visit(node.Right);
            LoweredTupleBinaryOperator updatedNode;

            if (_updatedNullabilities.TryGetValue(node, out (NullabilityInfo Info, TypeSymbol Type) infoAndType))
            {
                updatedNode = node.Update(left, right, node.OperatorKind, node.Operators, infoAndType.Type);
                updatedNode.TopLevelNullability = infoAndType.Info;
            }
            else
            {
                updatedNode = node.Update(left, right, node.OperatorKind, node.Operators, node.Type);
            }
            return updatedNode;
        }

        public override LoweredNode? VisitCompoundAssignmentOperator(LoweredCompoundAssignmentOperator node)
        {
            ImmutableArray<MethodSymbol> originalUserDefinedOperatorsOpt = GetUpdatedArray(node, node.OriginalUserDefinedOperatorsOpt);
            LoweredExpression left = (LoweredExpression)this.Visit(node.Left);
            LoweredExpression right = (LoweredExpression)this.Visit(node.Right);
            LoweredCompoundAssignmentOperator updatedNode;

            if (_updatedNullabilities.TryGetValue(node, out (NullabilityInfo Info, TypeSymbol Type) infoAndType))
            {
                updatedNode = node.Update(node.Operator, left, right, node.LeftConversion, node.FinalConversion, node.ResultKind, node.OriginalUserDefinedOperatorsOpt, infoAndType.Type);
                updatedNode.TopLevelNullability = infoAndType.Info;
            }
            else
            {
                updatedNode = node.Update(node.Operator, left, right, node.LeftConversion, node.FinalConversion, node.ResultKind, node.OriginalUserDefinedOperatorsOpt, node.Type);
            }
            return updatedNode;
        }

        public override LoweredNode? VisitAssignmentOperator(LoweredAssignmentOperator node)
        {
            LoweredExpression left = (LoweredExpression)this.Visit(node.Left);
            LoweredExpression right = (LoweredExpression)this.Visit(node.Right);
            LoweredAssignmentOperator updatedNode;

            if (_updatedNullabilities.TryGetValue(node, out (NullabilityInfo Info, TypeSymbol Type) infoAndType))
            {
                updatedNode = node.Update(left, right, node.IsRef, infoAndType.Type);
                updatedNode.TopLevelNullability = infoAndType.Info;
            }
            else
            {
                updatedNode = node.Update(left, right, node.IsRef, node.Type);
            }
            return updatedNode;
        }

        public override LoweredNode? VisitDeconstructionAssignmentOperator(LoweredDeconstructionAssignmentOperator node)
        {
            LoweredTupleExpression left = (LoweredTupleExpression)this.Visit(node.Left);
            LoweredConversion right = (LoweredConversion)this.Visit(node.Right);
            LoweredDeconstructionAssignmentOperator updatedNode;

            if (_updatedNullabilities.TryGetValue(node, out (NullabilityInfo Info, TypeSymbol Type) infoAndType))
            {
                updatedNode = node.Update(left, right, node.IsUsed, infoAndType.Type);
                updatedNode.TopLevelNullability = infoAndType.Info;
            }
            else
            {
                updatedNode = node.Update(left, right, node.IsUsed, node.Type);
            }
            return updatedNode;
        }

        public override LoweredNode? VisitNullCoalescingOperator(LoweredNullCoalescingOperator node)
        {
            LoweredExpression leftOperand = (LoweredExpression)this.Visit(node.LeftOperand);
            LoweredExpression rightOperand = (LoweredExpression)this.Visit(node.RightOperand);
            LoweredNullCoalescingOperator updatedNode;

            if (_updatedNullabilities.TryGetValue(node, out (NullabilityInfo Info, TypeSymbol Type) infoAndType))
            {
                updatedNode = node.Update(leftOperand, rightOperand, node.LeftConversion, node.OperatorResultKind, infoAndType.Type);
                updatedNode.TopLevelNullability = infoAndType.Info;
            }
            else
            {
                updatedNode = node.Update(leftOperand, rightOperand, node.LeftConversion, node.OperatorResultKind, node.Type);
            }
            return updatedNode;
        }

        public override LoweredNode? VisitNullCoalescingAssignmentOperator(LoweredNullCoalescingAssignmentOperator node)
        {
            LoweredExpression leftOperand = (LoweredExpression)this.Visit(node.LeftOperand);
            LoweredExpression rightOperand = (LoweredExpression)this.Visit(node.RightOperand);
            LoweredNullCoalescingAssignmentOperator updatedNode;

            if (_updatedNullabilities.TryGetValue(node, out (NullabilityInfo Info, TypeSymbol Type) infoAndType))
            {
                updatedNode = node.Update(leftOperand, rightOperand, infoAndType.Type);
                updatedNode.TopLevelNullability = infoAndType.Info;
            }
            else
            {
                updatedNode = node.Update(leftOperand, rightOperand, node.Type);
            }
            return updatedNode;
        }

        public override LoweredNode? VisitConditionalOperator(LoweredConditionalOperator node)
        {
            LoweredExpression condition = (LoweredExpression)this.Visit(node.Condition);
            LoweredExpression consequence = (LoweredExpression)this.Visit(node.Consequence);
            LoweredExpression alternative = (LoweredExpression)this.Visit(node.Alternative);
            LoweredConditionalOperator updatedNode;

            if (_updatedNullabilities.TryGetValue(node, out (NullabilityInfo Info, TypeSymbol Type) infoAndType))
            {
                updatedNode = node.Update(node.IsRef, condition, consequence, alternative, node.ConstantValueOpt, infoAndType.Type);
                updatedNode.TopLevelNullability = infoAndType.Info;
            }
            else
            {
                updatedNode = node.Update(node.IsRef, condition, consequence, alternative, node.ConstantValueOpt, node.Type);
            }
            return updatedNode;
        }

        public override LoweredNode? VisitArrayAccess(LoweredArrayAccess node)
        {
            LoweredExpression expression = (LoweredExpression)this.Visit(node.Expression);
            ImmutableArray<LoweredExpression> indices = this.VisitList(node.Indices);
            LoweredArrayAccess updatedNode;

            if (_updatedNullabilities.TryGetValue(node, out (NullabilityInfo Info, TypeSymbol Type) infoAndType))
            {
                updatedNode = node.Update(expression, indices, infoAndType.Type);
                updatedNode.TopLevelNullability = infoAndType.Info;
            }
            else
            {
                updatedNode = node.Update(expression, indices, node.Type);
            }
            return updatedNode;
        }

        public override LoweredNode? VisitArrayLength(LoweredArrayLength node)
        {
            LoweredExpression expression = (LoweredExpression)this.Visit(node.Expression);
            LoweredArrayLength updatedNode;

            if (_updatedNullabilities.TryGetValue(node, out (NullabilityInfo Info, TypeSymbol Type) infoAndType))
            {
                updatedNode = node.Update(expression, infoAndType.Type);
                updatedNode.TopLevelNullability = infoAndType.Info;
            }
            else
            {
                updatedNode = node.Update(expression, node.Type);
            }
            return updatedNode;
        }

        public override LoweredNode? VisitAwaitableInfo(LoweredAwaitableInfo node)
        {
            PropertySymbol? isCompleted = GetUpdatedSymbol(node, node.IsCompleted);
            MethodSymbol? getResult = GetUpdatedSymbol(node, node.GetResult);
            LoweredAwaitableValuePlaceholder? awaitableInstancePlaceholder = (LoweredAwaitableValuePlaceholder?)this.Visit(node.AwaitableInstancePlaceholder);
            LoweredExpression? getAwaiter = (LoweredExpression?)this.Visit(node.GetAwaiter);
            return node.Update(awaitableInstancePlaceholder, node.IsDynamic, getAwaiter, isCompleted, getResult);
        }

        public override LoweredNode? VisitAwaitExpression(LoweredAwaitExpression node)
        {
            LoweredExpression expression = (LoweredExpression)this.Visit(node.Expression);
            LoweredAwaitableInfo awaitableInfo = (LoweredAwaitableInfo)this.Visit(node.AwaitableInfo);
            LoweredAwaitExpression updatedNode;

            if (_updatedNullabilities.TryGetValue(node, out (NullabilityInfo Info, TypeSymbol Type) infoAndType))
            {
                updatedNode = node.Update(expression, awaitableInfo, infoAndType.Type);
                updatedNode.TopLevelNullability = infoAndType.Info;
            }
            else
            {
                updatedNode = node.Update(expression, awaitableInfo, node.Type);
            }
            return updatedNode;
        }

        public override LoweredNode? VisitTypeOfOperator(LoweredTypeOfOperator node)
        {
            MethodSymbol? getTypeFromHandle = GetUpdatedSymbol(node, node.GetTypeFromHandle);
            LoweredTypeExpression sourceType = (LoweredTypeExpression)this.Visit(node.SourceType);
            LoweredTypeOfOperator updatedNode;

            if (_updatedNullabilities.TryGetValue(node, out (NullabilityInfo Info, TypeSymbol Type) infoAndType))
            {
                updatedNode = node.Update(sourceType, getTypeFromHandle, infoAndType.Type);
                updatedNode.TopLevelNullability = infoAndType.Info;
            }
            else
            {
                updatedNode = node.Update(sourceType, getTypeFromHandle, node.Type);
            }
            return updatedNode;
        }

        public override LoweredNode? VisitMethodDefIndex(LoweredMethodDefIndex node)
        {
            MethodSymbol method = GetUpdatedSymbol(node, node.Method);
            LoweredMethodDefIndex updatedNode;

            if (_updatedNullabilities.TryGetValue(node, out (NullabilityInfo Info, TypeSymbol Type) infoAndType))
            {
                updatedNode = node.Update(method, infoAndType.Type);
                updatedNode.TopLevelNullability = infoAndType.Info;
            }
            else
            {
                updatedNode = node.Update(method, node.Type);
            }
            return updatedNode;
        }

        public override LoweredNode? VisitMaximumMethodDefIndex(LoweredMaximumMethodDefIndex node)
        {
            if (!_updatedNullabilities.TryGetValue(node, out (NullabilityInfo Info, TypeSymbol Type) infoAndType))
            {
                return node;
            }

            LoweredMaximumMethodDefIndex updatedNode = node.Update(infoAndType.Type);
            updatedNode.TopLevelNullability = infoAndType.Info;
            return updatedNode;
        }

        public override LoweredNode? VisitInstrumentationPayloadRoot(LoweredInstrumentationPayloadRoot node)
        {
            if (!_updatedNullabilities.TryGetValue(node, out (NullabilityInfo Info, TypeSymbol Type) infoAndType))
            {
                return node;
            }

            LoweredInstrumentationPayloadRoot updatedNode = node.Update(node.AnalysisKind, infoAndType.Type);
            updatedNode.TopLevelNullability = infoAndType.Info;
            return updatedNode;
        }

        public override LoweredNode? VisitModuleVersionId(LoweredModuleVersionId node)
        {
            if (!_updatedNullabilities.TryGetValue(node, out (NullabilityInfo Info, TypeSymbol Type) infoAndType))
            {
                return node;
            }

            LoweredModuleVersionId updatedNode = node.Update(infoAndType.Type);
            updatedNode.TopLevelNullability = infoAndType.Info;
            return updatedNode;
        }

        public override LoweredNode? VisitModuleVersionIdString(LoweredModuleVersionIdString node)
        {
            if (!_updatedNullabilities.TryGetValue(node, out (NullabilityInfo Info, TypeSymbol Type) infoAndType))
            {
                return node;
            }

            LoweredModuleVersionIdString updatedNode = node.Update(infoAndType.Type);
            updatedNode.TopLevelNullability = infoAndType.Info;
            return updatedNode;
        }

        public override LoweredNode? VisitSourceDocumentIndex(LoweredSourceDocumentIndex node)
        {
            if (!_updatedNullabilities.TryGetValue(node, out (NullabilityInfo Info, TypeSymbol Type) infoAndType))
            {
                return node;
            }

            LoweredSourceDocumentIndex updatedNode = node.Update(node.Document, infoAndType.Type);
            updatedNode.TopLevelNullability = infoAndType.Info;
            return updatedNode;
        }

        public override LoweredNode? VisitMethodInfo(LoweredMethodInfo node)
        {
            MethodSymbol method = GetUpdatedSymbol(node, node.Method);
            MethodSymbol? getMethodFromHandle = GetUpdatedSymbol(node, node.GetMethodFromHandle);
            LoweredMethodInfo updatedNode;

            if (_updatedNullabilities.TryGetValue(node, out (NullabilityInfo Info, TypeSymbol Type) infoAndType))
            {
                updatedNode = node.Update(method, getMethodFromHandle, infoAndType.Type);
                updatedNode.TopLevelNullability = infoAndType.Info;
            }
            else
            {
                updatedNode = node.Update(method, getMethodFromHandle, node.Type);
            }
            return updatedNode;
        }

        public override LoweredNode? VisitFieldInfo(LoweredFieldInfo node)
        {
            FieldSymbol field = GetUpdatedSymbol(node, node.Field);
            MethodSymbol? getFieldFromHandle = GetUpdatedSymbol(node, node.GetFieldFromHandle);
            LoweredFieldInfo updatedNode;

            if (_updatedNullabilities.TryGetValue(node, out (NullabilityInfo Info, TypeSymbol Type) infoAndType))
            {
                updatedNode = node.Update(field, getFieldFromHandle, infoAndType.Type);
                updatedNode.TopLevelNullability = infoAndType.Info;
            }
            else
            {
                updatedNode = node.Update(field, getFieldFromHandle, node.Type);
            }
            return updatedNode;
        }

        public override LoweredNode? VisitDefaultLiteral(LoweredDefaultLiteral node)
        {
            if (!_updatedNullabilities.TryGetValue(node, out (NullabilityInfo Info, TypeSymbol Type) infoAndType))
            {
                return node;
            }

            LoweredDefaultLiteral updatedNode = node.Update();
            updatedNode.TopLevelNullability = infoAndType.Info;
            return updatedNode;
        }

        public override LoweredNode? VisitDefaultExpression(LoweredDefaultExpression node)
        {
            LoweredTypeExpression? targetType = node.TargetType;
            LoweredDefaultExpression updatedNode;

            if (_updatedNullabilities.TryGetValue(node, out (NullabilityInfo Info, TypeSymbol Type) infoAndType))
            {
                updatedNode = node.Update(targetType, node.ConstantValueOpt, infoAndType.Type);
                updatedNode.TopLevelNullability = infoAndType.Info;
            }
            else
            {
                updatedNode = node.Update(targetType, node.ConstantValueOpt, node.Type);
            }
            return updatedNode;
        }

        public override LoweredNode? VisitIsOperator(LoweredIsOperator node)
        {
            LoweredExpression operand = (LoweredExpression)this.Visit(node.Operand);
            LoweredTypeExpression targetType = (LoweredTypeExpression)this.Visit(node.TargetType);
            LoweredIsOperator updatedNode;

            if (_updatedNullabilities.TryGetValue(node, out (NullabilityInfo Info, TypeSymbol Type) infoAndType))
            {
                updatedNode = node.Update(operand, targetType, node.Conversion, infoAndType.Type);
                updatedNode.TopLevelNullability = infoAndType.Info;
            }
            else
            {
                updatedNode = node.Update(operand, targetType, node.Conversion, node.Type);
            }
            return updatedNode;
        }

        public override LoweredNode? VisitAsOperator(LoweredAsOperator node)
        {
            LoweredExpression operand = (LoweredExpression)this.Visit(node.Operand);
            LoweredTypeExpression targetType = (LoweredTypeExpression)this.Visit(node.TargetType);
            LoweredAsOperator updatedNode;

            if (_updatedNullabilities.TryGetValue(node, out (NullabilityInfo Info, TypeSymbol Type) infoAndType))
            {
                updatedNode = node.Update(operand, targetType, node.Conversion, infoAndType.Type);
                updatedNode.TopLevelNullability = infoAndType.Info;
            }
            else
            {
                updatedNode = node.Update(operand, targetType, node.Conversion, node.Type);
            }
            return updatedNode;
        }

        public override LoweredNode? VisitSizeOfOperator(LoweredSizeOfOperator node)
        {
            LoweredTypeExpression sourceType = (LoweredTypeExpression)this.Visit(node.SourceType);
            LoweredSizeOfOperator updatedNode;

            if (_updatedNullabilities.TryGetValue(node, out (NullabilityInfo Info, TypeSymbol Type) infoAndType))
            {
                updatedNode = node.Update(sourceType, node.ConstantValueOpt, infoAndType.Type);
                updatedNode.TopLevelNullability = infoAndType.Info;
            }
            else
            {
                updatedNode = node.Update(sourceType, node.ConstantValueOpt, node.Type);
            }
            return updatedNode;
        }

        public override LoweredNode? VisitConversion(LoweredConversion node)
        {
            ImmutableArray<MethodSymbol> originalUserDefinedConversionsOpt = GetUpdatedArray(node, node.OriginalUserDefinedConversionsOpt);
            LoweredExpression operand = (LoweredExpression)this.Visit(node.Operand);
            LoweredConversion updatedNode;

            if (_updatedNullabilities.TryGetValue(node, out (NullabilityInfo Info, TypeSymbol Type) infoAndType))
            {
                updatedNode = node.Update(operand, node.Conversion, node.IsBaseConversion, node.Checked, node.ExplicitCastInCode, node.ConstantValueOpt, node.ConversionGroupOpt, node.OriginalUserDefinedConversionsOpt, infoAndType.Type);
                updatedNode.TopLevelNullability = infoAndType.Info;
            }
            else
            {
                updatedNode = node.Update(operand, node.Conversion, node.IsBaseConversion, node.Checked, node.ExplicitCastInCode, node.ConstantValueOpt, node.ConversionGroupOpt, node.OriginalUserDefinedConversionsOpt, node.Type);
            }
            return updatedNode;
        }

        public override LoweredNode? VisitReadOnlySpanFromArray(LoweredReadOnlySpanFromArray node)
        {
            MethodSymbol conversionMethod = GetUpdatedSymbol(node, node.ConversionMethod);
            LoweredExpression operand = (LoweredExpression)this.Visit(node.Operand);
            LoweredReadOnlySpanFromArray updatedNode;

            if (_updatedNullabilities.TryGetValue(node, out (NullabilityInfo Info, TypeSymbol Type) infoAndType))
            {
                updatedNode = node.Update(operand, conversionMethod, infoAndType.Type);
                updatedNode.TopLevelNullability = infoAndType.Info;
            }
            else
            {
                updatedNode = node.Update(operand, conversionMethod, node.Type);
            }
            return updatedNode;
        }

        public override LoweredNode? VisitArgList(LoweredArgList node)
        {
            if (!_updatedNullabilities.TryGetValue(node, out (NullabilityInfo Info, TypeSymbol Type) infoAndType))
            {
                return node;
            }

            LoweredArgList updatedNode = node.Update(infoAndType.Type);
            updatedNode.TopLevelNullability = infoAndType.Info;
            return updatedNode;
        }

        public override LoweredNode? VisitArgListOperator(LoweredArgListOperator node)
        {
            ImmutableArray<LoweredExpression> arguments = this.VisitList(node.Arguments);
            LoweredArgListOperator updatedNode;

            if (_updatedNullabilities.TryGetValue(node, out (NullabilityInfo Info, TypeSymbol Type) infoAndType))
            {
                updatedNode = node.Update(arguments, node.ArgumentRefKindsOpt, infoAndType.Type);
                updatedNode.TopLevelNullability = infoAndType.Info;
            }
            else
            {
                updatedNode = node.Update(arguments, node.ArgumentRefKindsOpt, node.Type);
            }
            return updatedNode;
        }

        public override LoweredNode? VisitFixedLocalCollectionInitializer(LoweredFixedLocalCollectionInitializer node)
        {
            TypeSymbol elementPointerType = GetUpdatedSymbol(node, node.ElementPointerType);
            MethodSymbol? getPinnableOpt = GetUpdatedSymbol(node, node.GetPinnableOpt);
            LoweredExpression expression = (LoweredExpression)this.Visit(node.Expression);
            LoweredFixedLocalCollectionInitializer updatedNode;

            if (_updatedNullabilities.TryGetValue(node, out (NullabilityInfo Info, TypeSymbol Type) infoAndType))
            {
                updatedNode = node.Update(elementPointerType, node.ElementPointerTypeConversion, expression, getPinnableOpt, infoAndType.Type);
                updatedNode.TopLevelNullability = infoAndType.Info;
            }
            else
            {
                updatedNode = node.Update(elementPointerType, node.ElementPointerTypeConversion, expression, getPinnableOpt, node.Type);
            }
            return updatedNode;
        }

        public override LoweredNode? VisitBlock(LoweredBlock node)
        {
            ImmutableArray<LocalSymbol> locals = GetUpdatedArray(node, node.Locals);
            ImmutableArray<LocalFunctionSymbol> localFunctions = GetUpdatedArray(node, node.LocalFunctions);
            ImmutableArray<LoweredStatement> statements = this.VisitList(node.Statements);
            return node.Update(locals, localFunctions, statements);
        }

        public override LoweredNode? VisitScope(LoweredScope node)
        {
            ImmutableArray<LocalSymbol> locals = GetUpdatedArray(node, node.Locals);
            ImmutableArray<LoweredStatement> statements = this.VisitList(node.Statements);
            return node.Update(locals, statements);
        }

        public override LoweredNode? VisitStateMachineScope(LoweredStateMachineScope node)
        {
            ImmutableArray<StateMachineFieldSymbol> fields = GetUpdatedArray(node, node.Fields);
            LoweredStatement statement = (LoweredStatement)this.Visit(node.Statement);
            return node.Update(fields, statement);
        }

        public override LoweredNode? VisitLocalDeclaration(LoweredLocalDeclaration node)
        {
            LocalSymbol localSymbol = GetUpdatedSymbol(node, node.LocalSymbol);
            LoweredTypeExpression? declaredTypeOpt = (LoweredTypeExpression?)this.Visit(node.DeclaredTypeOpt);
            LoweredExpression? initializerOpt = (LoweredExpression?)this.Visit(node.InitializerOpt);
            ImmutableArray<LoweredExpression> argumentsOpt = this.VisitList(node.ArgumentsOpt);
            return node.Update(localSymbol, declaredTypeOpt, initializerOpt, argumentsOpt, node.InferredType);
        }

        public override LoweredNode? VisitUsingLocalDeclarations(LoweredUsingLocalDeclarations node)
        {
            MethodSymbol? disposeMethodOpt = GetUpdatedSymbol(node, node.DisposeMethodOpt);
            LoweredAwaitableInfo? awaitOpt = (LoweredAwaitableInfo?)this.Visit(node.AwaitOpt);
            ImmutableArray<LoweredLocalDeclaration> localDeclarations = this.VisitList(node.LocalDeclarations);
            return node.Update(disposeMethodOpt, node.IDisposableConversion, awaitOpt, localDeclarations);
        }

        public override LoweredNode? VisitLocalFunctionStatement(LoweredLocalFunctionStatement node)
        {
            LocalFunctionSymbol symbol = GetUpdatedSymbol(node, node.Symbol);
            LoweredBlock? blockBody = (LoweredBlock?)this.Visit(node.BlockBody);
            LoweredBlock? expressionBody = (LoweredBlock?)this.Visit(node.ExpressionBody);
            return node.Update(symbol, blockBody, expressionBody);
        }

        public override LoweredNode? VisitSwitchStatement(LoweredSwitchStatement node)
        {
            ImmutableArray<LocalSymbol> innerLocals = GetUpdatedArray(node, node.InnerLocals);
            ImmutableArray<LocalFunctionSymbol> innerLocalFunctions = GetUpdatedArray(node, node.InnerLocalFunctions);
            LoweredExpression expression = (LoweredExpression)this.Visit(node.Expression);
            ImmutableArray<LoweredSwitchSection> switchSections = this.VisitList(node.SwitchSections);
            LoweredDecisionDag decisionDag = node.DecisionDag;
            LoweredSwitchLabel? defaultLabel = (LoweredSwitchLabel?)this.Visit(node.DefaultLabel);
            return node.Update(expression, innerLocals, innerLocalFunctions, switchSections, decisionDag, defaultLabel, node.BreakLabel);
        }

        public override LoweredNode? VisitSwitchDispatch(LoweredSwitchDispatch node)
        {
            MethodSymbol? equalityMethod = GetUpdatedSymbol(node, node.EqualityMethod);
            LoweredExpression expression = (LoweredExpression)this.Visit(node.Expression);
            return node.Update(expression, node.Cases, node.DefaultLabel, equalityMethod);
        }

        public override LoweredNode? VisitDoStatement(LoweredDoStatement node)
        {
            ImmutableArray<LocalSymbol> locals = GetUpdatedArray(node, node.Locals);
            LoweredExpression condition = (LoweredExpression)this.Visit(node.Condition);
            LoweredStatement body = (LoweredStatement)this.Visit(node.Body);
            return node.Update(locals, condition, body, node.BreakLabel, node.ContinueLabel);
        }

        public override LoweredNode? VisitWhileStatement(LoweredWhileStatement node)
        {
            ImmutableArray<LocalSymbol> locals = GetUpdatedArray(node, node.Locals);
            LoweredExpression condition = (LoweredExpression)this.Visit(node.Condition);
            LoweredStatement body = (LoweredStatement)this.Visit(node.Body);
            return node.Update(locals, condition, body, node.BreakLabel, node.ContinueLabel);
        }

        public override LoweredNode? VisitForStatement(LoweredForStatement node)
        {
            ImmutableArray<LocalSymbol> outerLocals = GetUpdatedArray(node, node.OuterLocals);
            ImmutableArray<LocalSymbol> innerLocals = GetUpdatedArray(node, node.InnerLocals);
            LoweredStatement? initializer = (LoweredStatement?)this.Visit(node.Initializer);
            LoweredExpression? condition = (LoweredExpression?)this.Visit(node.Condition);
            LoweredStatement? increment = (LoweredStatement?)this.Visit(node.Increment);
            LoweredStatement body = (LoweredStatement)this.Visit(node.Body);
            return node.Update(outerLocals, initializer, innerLocals, condition, increment, body, node.BreakLabel, node.ContinueLabel);
        }

        public override LoweredNode? VisitForEachStatement(LoweredForEachStatement node)
        {
            ImmutableArray<LocalSymbol> iterationVariables = GetUpdatedArray(node, node.IterationVariables);
            LoweredTypeExpression iterationVariableType = (LoweredTypeExpression)this.Visit(node.IterationVariableType);
            LoweredExpression? iterationErrorExpressionOpt = (LoweredExpression?)this.Visit(node.IterationErrorExpressionOpt);
            LoweredExpression expression = (LoweredExpression)this.Visit(node.Expression);
            LoweredForEachDeconstructStep? deconstructionOpt = (LoweredForEachDeconstructStep?)this.Visit(node.DeconstructionOpt);
            LoweredAwaitableInfo? awaitOpt = (LoweredAwaitableInfo?)this.Visit(node.AwaitOpt);
            LoweredStatement body = (LoweredStatement)this.Visit(node.Body);
            return node.Update(node.EnumeratorInfoOpt, node.ElementConversion, iterationVariableType, iterationVariables, iterationErrorExpressionOpt, expression, deconstructionOpt, awaitOpt, body, node.Checked, node.BreakLabel, node.ContinueLabel);
        }

        public override LoweredNode? VisitUsingStatement(LoweredUsingStatement node)
        {
            ImmutableArray<LocalSymbol> locals = GetUpdatedArray(node, node.Locals);
            MethodSymbol? disposeMethodOpt = GetUpdatedSymbol(node, node.DisposeMethodOpt);
            LoweredMultipleLocalDeclarations? declarationsOpt = (LoweredMultipleLocalDeclarations?)this.Visit(node.DeclarationsOpt);
            LoweredExpression? expressionOpt = (LoweredExpression?)this.Visit(node.ExpressionOpt);
            LoweredStatement body = (LoweredStatement)this.Visit(node.Body);
            LoweredAwaitableInfo? awaitOpt = (LoweredAwaitableInfo?)this.Visit(node.AwaitOpt);
            return node.Update(locals, declarationsOpt, expressionOpt, node.IDisposableConversion, body, awaitOpt, disposeMethodOpt);
        }

        public override LoweredNode? VisitFixedStatement(LoweredFixedStatement node)
        {
            ImmutableArray<LocalSymbol> locals = GetUpdatedArray(node, node.Locals);
            LoweredMultipleLocalDeclarations declarations = (LoweredMultipleLocalDeclarations)this.Visit(node.Declarations);
            LoweredStatement body = (LoweredStatement)this.Visit(node.Body);
            return node.Update(locals, declarations, body);
        }

        public override LoweredNode? VisitCatchBlock(LoweredCatchBlock node)
        {
            ImmutableArray<LocalSymbol> locals = GetUpdatedArray(node, node.Locals);
            TypeSymbol? exceptionTypeOpt = GetUpdatedSymbol(node, node.ExceptionTypeOpt);
            LoweredExpression? exceptionSourceOpt = (LoweredExpression?)this.Visit(node.ExceptionSourceOpt);
            LoweredExpression? exceptionFilterOpt = (LoweredExpression?)this.Visit(node.ExceptionFilterOpt);
            LoweredBlock body = (LoweredBlock)this.Visit(node.Body);
            return node.Update(locals, exceptionSourceOpt, exceptionTypeOpt, exceptionFilterOpt, body, node.IsSynthesizedAsyncCatchAll);
        }

        public override LoweredNode? VisitLiteral(LoweredLiteral node)
        {
            if (!_updatedNullabilities.TryGetValue(node, out (NullabilityInfo Info, TypeSymbol Type) infoAndType))
            {
                return node;
            }

            LoweredLiteral updatedNode = node.Update(node.ConstantValueOpt, infoAndType.Type);
            updatedNode.TopLevelNullability = infoAndType.Info;
            return updatedNode;
        }

        public override LoweredNode? VisitThisReference(LoweredThisReference node)
        {
            if (!_updatedNullabilities.TryGetValue(node, out (NullabilityInfo Info, TypeSymbol Type) infoAndType))
            {
                return node;
            }

            LoweredThisReference updatedNode = node.Update(infoAndType.Type);
            updatedNode.TopLevelNullability = infoAndType.Info;
            return updatedNode;
        }

        public override LoweredNode? VisitPreviousSubmissionReference(LoweredPreviousSubmissionReference node)
        {
            if (!_updatedNullabilities.TryGetValue(node, out (NullabilityInfo Info, TypeSymbol Type) infoAndType))
            {
                return node;
            }

            LoweredPreviousSubmissionReference updatedNode = node.Update(infoAndType.Type);
            updatedNode.TopLevelNullability = infoAndType.Info;
            return updatedNode;
        }

        public override LoweredNode? VisitHostObjectMemberReference(LoweredHostObjectMemberReference node)
        {
            if (!_updatedNullabilities.TryGetValue(node, out (NullabilityInfo Info, TypeSymbol Type) infoAndType))
            {
                return node;
            }

            LoweredHostObjectMemberReference updatedNode = node.Update(infoAndType.Type);
            updatedNode.TopLevelNullability = infoAndType.Info;
            return updatedNode;
        }

        public override LoweredNode? VisitBaseReference(LoweredBaseReference node)
        {
            if (!_updatedNullabilities.TryGetValue(node, out (NullabilityInfo Info, TypeSymbol Type) infoAndType))
            {
                return node;
            }

            LoweredBaseReference updatedNode = node.Update(infoAndType.Type);
            updatedNode.TopLevelNullability = infoAndType.Info;
            return updatedNode;
        }

        public override LoweredNode? VisitLocal(LoweredLocal node)
        {
            LocalSymbol localSymbol = GetUpdatedSymbol(node, node.LocalSymbol);
            LoweredLocal updatedNode;

            if (_updatedNullabilities.TryGetValue(node, out (NullabilityInfo Info, TypeSymbol Type) infoAndType))
            {
                updatedNode = node.Update(localSymbol, node.DeclarationKind, node.ConstantValueOpt, node.IsNullableUnknown, infoAndType.Type);
                updatedNode.TopLevelNullability = infoAndType.Info;
            }
            else
            {
                updatedNode = node.Update(localSymbol, node.DeclarationKind, node.ConstantValueOpt, node.IsNullableUnknown, node.Type);
            }
            return updatedNode;
        }

        public override LoweredNode? VisitPseudoVariable(LoweredPseudoVariable node)
        {
            LocalSymbol localSymbol = GetUpdatedSymbol(node, node.LocalSymbol);
            LoweredPseudoVariable updatedNode;

            if (_updatedNullabilities.TryGetValue(node, out (NullabilityInfo Info, TypeSymbol Type) infoAndType))
            {
                updatedNode = node.Update(localSymbol, node.EmitExpressions, infoAndType.Type);
                updatedNode.TopLevelNullability = infoAndType.Info;
            }
            else
            {
                updatedNode = node.Update(localSymbol, node.EmitExpressions, node.Type);
            }
            return updatedNode;
        }

        public override LoweredNode? VisitRangeVariable(LoweredRangeVariable node)
        {
            RangeVariableSymbol rangeVariableSymbol = GetUpdatedSymbol(node, node.RangeVariableSymbol);
            LoweredExpression value = (LoweredExpression)this.Visit(node.Value);
            LoweredRangeVariable updatedNode;

            if (_updatedNullabilities.TryGetValue(node, out (NullabilityInfo Info, TypeSymbol Type) infoAndType))
            {
                updatedNode = node.Update(rangeVariableSymbol, value, infoAndType.Type);
                updatedNode.TopLevelNullability = infoAndType.Info;
            }
            else
            {
                updatedNode = node.Update(rangeVariableSymbol, value, node.Type);
            }
            return updatedNode;
        }

        public override LoweredNode? VisitParameter(LoweredParameter node)
        {
            ParameterSymbol parameterSymbol = GetUpdatedSymbol(node, node.ParameterSymbol);
            LoweredParameter updatedNode;

            if (_updatedNullabilities.TryGetValue(node, out (NullabilityInfo Info, TypeSymbol Type) infoAndType))
            {
                updatedNode = node.Update(parameterSymbol, infoAndType.Type);
                updatedNode.TopLevelNullability = infoAndType.Info;
            }
            else
            {
                updatedNode = node.Update(parameterSymbol, node.Type);
            }
            return updatedNode;
        }

        public override LoweredNode? VisitLabel(LoweredLabel node)
        {
            if (!_updatedNullabilities.TryGetValue(node, out (NullabilityInfo Info, TypeSymbol Type) infoAndType))
            {
                return node;
            }

            LoweredLabel updatedNode = node.Update(node.Label, infoAndType.Type);
            updatedNode.TopLevelNullability = infoAndType.Info;
            return updatedNode;
        }

        public override LoweredNode? VisitSwitchExpressionArm(LoweredSwitchExpressionArm node)
        {
            ImmutableArray<LocalSymbol> locals = GetUpdatedArray(node, node.Locals);
            LoweredPattern pattern = (LoweredPattern)this.Visit(node.Pattern);
            LoweredExpression? whenClause = (LoweredExpression?)this.Visit(node.WhenClause);
            LoweredExpression value = (LoweredExpression)this.Visit(node.Value);
            return node.Update(locals, pattern, whenClause, value, node.Label);
        }

        public override LoweredNode? VisitUnconvertedSwitchExpression(LoweredUnconvertedSwitchExpression node)
        {
            LoweredExpression expression = (LoweredExpression)this.Visit(node.Expression);
            ImmutableArray<LoweredSwitchExpressionArm> switchArms = this.VisitList(node.SwitchArms);
            LoweredDecisionDag decisionDag = node.DecisionDag;
            LoweredUnconvertedSwitchExpression updatedNode;

            if (_updatedNullabilities.TryGetValue(node, out (NullabilityInfo Info, TypeSymbol Type) infoAndType))
            {
                updatedNode = node.Update(expression, switchArms, decisionDag, node.DefaultLabel, node.ReportedNotExhaustive, infoAndType.Type);
                updatedNode.TopLevelNullability = infoAndType.Info;
            }
            else
            {
                updatedNode = node.Update(expression, switchArms, decisionDag, node.DefaultLabel, node.ReportedNotExhaustive, node.Type);
            }
            return updatedNode;
        }

        public override LoweredNode? VisitConvertedSwitchExpression(LoweredConvertedSwitchExpression node)
        {
            TypeSymbol? naturalTypeOpt = GetUpdatedSymbol(node, node.NaturalTypeOpt);
            LoweredExpression expression = (LoweredExpression)this.Visit(node.Expression);
            ImmutableArray<LoweredSwitchExpressionArm> switchArms = this.VisitList(node.SwitchArms);
            LoweredDecisionDag decisionDag = node.DecisionDag;
            LoweredConvertedSwitchExpression updatedNode;

            if (_updatedNullabilities.TryGetValue(node, out (NullabilityInfo Info, TypeSymbol Type) infoAndType))
            {
                updatedNode = node.Update(naturalTypeOpt, node.WasTargetTyped, expression, switchArms, decisionDag, node.DefaultLabel, node.ReportedNotExhaustive, infoAndType.Type);
                updatedNode.TopLevelNullability = infoAndType.Info;
            }
            else
            {
                updatedNode = node.Update(naturalTypeOpt, node.WasTargetTyped, expression, switchArms, decisionDag, node.DefaultLabel, node.ReportedNotExhaustive, node.Type);
            }
            return updatedNode;
        }

        public override LoweredNode? VisitDagDeconstructEvaluation(LoweredDagDeconstructEvaluation node)
        {
            MethodSymbol deconstructMethod = GetUpdatedSymbol(node, node.DeconstructMethod);
            LoweredDagTemp input = (LoweredDagTemp)this.Visit(node.Input);
            return node.Update(deconstructMethod, input);
        }

        public override LoweredNode? VisitDagFieldEvaluation(LoweredDagFieldEvaluation node)
        {
            FieldSymbol field = GetUpdatedSymbol(node, node.Field);
            LoweredDagTemp input = (LoweredDagTemp)this.Visit(node.Input);
            return node.Update(field, input);
        }

        public override LoweredNode? VisitDagPropertyEvaluation(LoweredDagPropertyEvaluation node)
        {
            PropertySymbol property = GetUpdatedSymbol(node, node.Property);
            LoweredDagTemp input = (LoweredDagTemp)this.Visit(node.Input);
            return node.Update(property, input);
        }

        public override LoweredNode? VisitDagIndexEvaluation(LoweredDagIndexEvaluation node)
        {
            PropertySymbol property = GetUpdatedSymbol(node, node.Property);
            LoweredDagTemp input = (LoweredDagTemp)this.Visit(node.Input);
            return node.Update(property, node.Index, input);
        }

        public override LoweredNode? VisitSwitchSection(LoweredSwitchSection node)
        {
            ImmutableArray<LocalSymbol> locals = GetUpdatedArray(node, node.Locals);
            ImmutableArray<LoweredSwitchLabel> switchLabels = this.VisitList(node.SwitchLabels);
            ImmutableArray<LoweredStatement> statements = this.VisitList(node.Statements);
            return node.Update(locals, switchLabels, statements);
        }

        public override LoweredNode? VisitSequencePointExpression(LoweredSequencePointExpression node)
        {
            LoweredExpression expression = (LoweredExpression)this.Visit(node.Expression);
            LoweredSequencePointExpression updatedNode;

            if (_updatedNullabilities.TryGetValue(node, out (NullabilityInfo Info, TypeSymbol Type) infoAndType))
            {
                updatedNode = node.Update(expression, infoAndType.Type);
                updatedNode.TopLevelNullability = infoAndType.Info;
            }
            else
            {
                updatedNode = node.Update(expression, node.Type);
            }
            return updatedNode;
        }

        public override LoweredNode? VisitSequence(LoweredSequence node)
        {
            ImmutableArray<LocalSymbol> locals = GetUpdatedArray(node, node.Locals);
            ImmutableArray<LoweredExpression> sideEffects = this.VisitList(node.SideEffects);
            LoweredExpression value = (LoweredExpression)this.Visit(node.Value);
            LoweredSequence updatedNode;

            if (_updatedNullabilities.TryGetValue(node, out (NullabilityInfo Info, TypeSymbol Type) infoAndType))
            {
                updatedNode = node.Update(locals, sideEffects, value, infoAndType.Type);
                updatedNode.TopLevelNullability = infoAndType.Info;
            }
            else
            {
                updatedNode = node.Update(locals, sideEffects, value, node.Type);
            }
            return updatedNode;
        }

        public override LoweredNode? VisitSpillSequence(LoweredSpillSequence node)
        {
            ImmutableArray<LocalSymbol> locals = GetUpdatedArray(node, node.Locals);
            ImmutableArray<LoweredStatement> sideEffects = this.VisitList(node.SideEffects);
            LoweredExpression value = (LoweredExpression)this.Visit(node.Value);
            LoweredSpillSequence updatedNode;

            if (_updatedNullabilities.TryGetValue(node, out (NullabilityInfo Info, TypeSymbol Type) infoAndType))
            {
                updatedNode = node.Update(locals, sideEffects, value, infoAndType.Type);
                updatedNode.TopLevelNullability = infoAndType.Info;
            }
            else
            {
                updatedNode = node.Update(locals, sideEffects, value, node.Type);
            }
            return updatedNode;
        }

        public override LoweredNode? VisitDynamicMemberAccess(LoweredDynamicMemberAccess node)
        {
            LoweredExpression receiver = (LoweredExpression)this.Visit(node.Receiver);
            LoweredDynamicMemberAccess updatedNode;

            if (_updatedNullabilities.TryGetValue(node, out (NullabilityInfo Info, TypeSymbol Type) infoAndType))
            {
                updatedNode = node.Update(receiver, node.TypeArgumentsOpt, node.Name, node.Invoked, node.Indexed, infoAndType.Type);
                updatedNode.TopLevelNullability = infoAndType.Info;
            }
            else
            {
                updatedNode = node.Update(receiver, node.TypeArgumentsOpt, node.Name, node.Invoked, node.Indexed, node.Type);
            }
            return updatedNode;
        }

        public override LoweredNode? VisitDynamicInvocation(LoweredDynamicInvocation node)
        {
            ImmutableArray<MethodSymbol> applicableMethods = GetUpdatedArray(node, node.ApplicableMethods);
            LoweredExpression expression = (LoweredExpression)this.Visit(node.Expression);
            ImmutableArray<LoweredExpression> arguments = this.VisitList(node.Arguments);
            LoweredDynamicInvocation updatedNode;

            if (_updatedNullabilities.TryGetValue(node, out (NullabilityInfo Info, TypeSymbol Type) infoAndType))
            {
                updatedNode = node.Update(node.ArgumentNamesOpt, node.ArgumentRefKindsOpt, applicableMethods, expression, arguments, infoAndType.Type);
                updatedNode.TopLevelNullability = infoAndType.Info;
            }
            else
            {
                updatedNode = node.Update(node.ArgumentNamesOpt, node.ArgumentRefKindsOpt, applicableMethods, expression, arguments, node.Type);
            }
            return updatedNode;
        }

        public override LoweredNode? VisitConditionalAccess(LoweredConditionalAccess node)
        {
            LoweredExpression receiver = (LoweredExpression)this.Visit(node.Receiver);
            LoweredExpression accessExpression = (LoweredExpression)this.Visit(node.AccessExpression);
            LoweredConditionalAccess updatedNode;

            if (_updatedNullabilities.TryGetValue(node, out (NullabilityInfo Info, TypeSymbol Type) infoAndType))
            {
                updatedNode = node.Update(receiver, accessExpression, infoAndType.Type);
                updatedNode.TopLevelNullability = infoAndType.Info;
            }
            else
            {
                updatedNode = node.Update(receiver, accessExpression, node.Type);
            }
            return updatedNode;
        }

        public override LoweredNode? VisitLoweredConditionalAccess(LoweredLoweredConditionalAccess node)
        {
            MethodSymbol? hasValueMethodOpt = GetUpdatedSymbol(node, node.HasValueMethodOpt);
            LoweredExpression receiver = (LoweredExpression)this.Visit(node.Receiver);
            LoweredExpression whenNotNull = (LoweredExpression)this.Visit(node.WhenNotNull);
            LoweredExpression? whenNullOpt = (LoweredExpression?)this.Visit(node.WhenNullOpt);
            LoweredLoweredConditionalAccess updatedNode;

            if (_updatedNullabilities.TryGetValue(node, out (NullabilityInfo Info, TypeSymbol Type) infoAndType))
            {
                updatedNode = node.Update(receiver, hasValueMethodOpt, whenNotNull, whenNullOpt, node.Id, infoAndType.Type);
                updatedNode.TopLevelNullability = infoAndType.Info;
            }
            else
            {
                updatedNode = node.Update(receiver, hasValueMethodOpt, whenNotNull, whenNullOpt, node.Id, node.Type);
            }
            return updatedNode;
        }

        public override LoweredNode? VisitConditionalReceiver(LoweredConditionalReceiver node)
        {
            if (!_updatedNullabilities.TryGetValue(node, out (NullabilityInfo Info, TypeSymbol Type) infoAndType))
            {
                return node;
            }

            LoweredConditionalReceiver updatedNode = node.Update(node.Id, infoAndType.Type);
            updatedNode.TopLevelNullability = infoAndType.Info;
            return updatedNode;
        }

        public override LoweredNode? VisitComplexConditionalReceiver(LoweredComplexConditionalReceiver node)
        {
            LoweredExpression valueTypeReceiver = (LoweredExpression)this.Visit(node.ValueTypeReceiver);
            LoweredExpression referenceTypeReceiver = (LoweredExpression)this.Visit(node.ReferenceTypeReceiver);
            LoweredComplexConditionalReceiver updatedNode;

            if (_updatedNullabilities.TryGetValue(node, out (NullabilityInfo Info, TypeSymbol Type) infoAndType))
            {
                updatedNode = node.Update(valueTypeReceiver, referenceTypeReceiver, infoAndType.Type);
                updatedNode.TopLevelNullability = infoAndType.Info;
            }
            else
            {
                updatedNode = node.Update(valueTypeReceiver, referenceTypeReceiver, node.Type);
            }
            return updatedNode;
        }

        public override LoweredNode? VisitMethodGroup(LoweredMethodGroup node)
        {
            ImmutableArray<MethodSymbol> methods = GetUpdatedArray(node, node.Methods);
            Symbol? lookupSymbolOpt = GetUpdatedSymbol(node, node.LookupSymbolOpt);
            LoweredExpression? receiverOpt = (LoweredExpression?)this.Visit(node.ReceiverOpt);
            LoweredMethodGroup updatedNode;

            if (_updatedNullabilities.TryGetValue(node, out (NullabilityInfo Info, TypeSymbol Type) infoAndType))
            {
                updatedNode = node.Update(node.TypeArgumentsOpt, node.Name, methods, lookupSymbolOpt, node.LookupError, node.Flags, receiverOpt, node.ResultKind);
                updatedNode.TopLevelNullability = infoAndType.Info;
            }
            else
            {
                updatedNode = node.Update(node.TypeArgumentsOpt, node.Name, methods, lookupSymbolOpt, node.LookupError, node.Flags, receiverOpt, node.ResultKind);
            }
            return updatedNode;
        }

        public override LoweredNode? VisitPropertyGroup(LoweredPropertyGroup node)
        {
            ImmutableArray<PropertySymbol> properties = GetUpdatedArray(node, node.Properties);
            LoweredExpression? receiverOpt = (LoweredExpression?)this.Visit(node.ReceiverOpt);
            LoweredPropertyGroup updatedNode;

            if (_updatedNullabilities.TryGetValue(node, out (NullabilityInfo Info, TypeSymbol Type) infoAndType))
            {
                updatedNode = node.Update(properties, receiverOpt, node.ResultKind);
                updatedNode.TopLevelNullability = infoAndType.Info;
            }
            else
            {
                updatedNode = node.Update(properties, receiverOpt, node.ResultKind);
            }
            return updatedNode;
        }

        public override LoweredNode? VisitCall(LoweredCall node)
        {
            MethodSymbol method = GetUpdatedSymbol(node, node.Method);
            ImmutableArray<MethodSymbol> originalMethodsOpt = GetUpdatedArray(node, node.OriginalMethodsOpt);
            LoweredExpression? receiverOpt = (LoweredExpression?)this.Visit(node.ReceiverOpt);
            ImmutableArray<LoweredExpression> arguments = this.VisitList(node.Arguments);
            LoweredCall updatedNode;

            if (_updatedNullabilities.TryGetValue(node, out (NullabilityInfo Info, TypeSymbol Type) infoAndType))
            {
                updatedNode = node.Update(receiverOpt, method, arguments, node.ArgumentNamesOpt, node.ArgumentRefKindsOpt, node.IsDelegateCall, node.Expanded, node.InvokedAsExtensionMethod, node.ArgsToParamsOpt, node.ResultKind, node.OriginalMethodsOpt, node.BinderOpt, infoAndType.Type);
                updatedNode.TopLevelNullability = infoAndType.Info;
            }
            else
            {
                updatedNode = node.Update(receiverOpt, method, arguments, node.ArgumentNamesOpt, node.ArgumentRefKindsOpt, node.IsDelegateCall, node.Expanded, node.InvokedAsExtensionMethod, node.ArgsToParamsOpt, node.ResultKind, node.OriginalMethodsOpt, node.BinderOpt, node.Type);
            }
            return updatedNode;
        }

        public override LoweredNode? VisitEventAssignmentOperator(LoweredEventAssignmentOperator node)
        {
            EventSymbol @event = GetUpdatedSymbol(node, node.Event);
            LoweredExpression? receiverOpt = (LoweredExpression?)this.Visit(node.ReceiverOpt);
            LoweredExpression argument = (LoweredExpression)this.Visit(node.Argument);
            LoweredEventAssignmentOperator updatedNode;

            if (_updatedNullabilities.TryGetValue(node, out (NullabilityInfo Info, TypeSymbol Type) infoAndType))
            {
                updatedNode = node.Update(@event, node.IsAddition, node.IsDynamic, receiverOpt, argument, infoAndType.Type);
                updatedNode.TopLevelNullability = infoAndType.Info;
            }
            else
            {
                updatedNode = node.Update(@event, node.IsAddition, node.IsDynamic, receiverOpt, argument, node.Type);
            }
            return updatedNode;
        }

        public override LoweredNode? VisitAttribute(LoweredAttribute node)
        {
            MethodSymbol? constructor = GetUpdatedSymbol(node, node.Constructor);
            ImmutableArray<LoweredExpression> constructorArguments = this.VisitList(node.ConstructorArguments);
            ImmutableArray<LoweredExpression> namedArguments = this.VisitList(node.NamedArguments);
            LoweredAttribute updatedNode;

            if (_updatedNullabilities.TryGetValue(node, out (NullabilityInfo Info, TypeSymbol Type) infoAndType))
            {
                updatedNode = node.Update(constructor, constructorArguments, node.ConstructorArgumentNamesOpt, node.ConstructorArgumentsToParamsOpt, node.ConstructorExpanded, namedArguments, node.ResultKind, infoAndType.Type);
                updatedNode.TopLevelNullability = infoAndType.Info;
            }
            else
            {
                updatedNode = node.Update(constructor, constructorArguments, node.ConstructorArgumentNamesOpt, node.ConstructorArgumentsToParamsOpt, node.ConstructorExpanded, namedArguments, node.ResultKind, node.Type);
            }
            return updatedNode;
        }

        public override LoweredNode? VisitObjectCreationExpression(LoweredObjectCreationExpression node)
        {
            MethodSymbol constructor = GetUpdatedSymbol(node, node.Constructor);
            ImmutableArray<MethodSymbol> constructorsGroup = GetUpdatedArray(node, node.ConstructorsGroup);
            ImmutableArray<LoweredExpression> arguments = this.VisitList(node.Arguments);
            LoweredObjectInitializerExpressionBase? initializerExpressionOpt = (LoweredObjectInitializerExpressionBase?)this.Visit(node.InitializerExpressionOpt);
            LoweredObjectCreationExpression updatedNode;

            if (_updatedNullabilities.TryGetValue(node, out (NullabilityInfo Info, TypeSymbol Type) infoAndType))
            {
                updatedNode = node.Update(constructor, constructorsGroup, arguments, node.ArgumentNamesOpt, node.ArgumentRefKindsOpt, node.Expanded, node.ArgsToParamsOpt, node.ConstantValueOpt, initializerExpressionOpt, node.BinderOpt, infoAndType.Type);
                updatedNode.TopLevelNullability = infoAndType.Info;
            }
            else
            {
                updatedNode = node.Update(constructor, constructorsGroup, arguments, node.ArgumentNamesOpt, node.ArgumentRefKindsOpt, node.Expanded, node.ArgsToParamsOpt, node.ConstantValueOpt, initializerExpressionOpt, node.BinderOpt, node.Type);
            }
            return updatedNode;
        }

        public override LoweredNode? VisitTupleLiteral(LoweredTupleLiteral node)
        {
            ImmutableArray<LoweredExpression> arguments = this.VisitList(node.Arguments);
            LoweredTupleLiteral updatedNode;

            if (_updatedNullabilities.TryGetValue(node, out (NullabilityInfo Info, TypeSymbol Type) infoAndType))
            {
                updatedNode = node.Update(arguments, node.ArgumentNamesOpt, node.InferredNamesOpt, infoAndType.Type);
                updatedNode.TopLevelNullability = infoAndType.Info;
            }
            else
            {
                updatedNode = node.Update(arguments, node.ArgumentNamesOpt, node.InferredNamesOpt, node.Type);
            }
            return updatedNode;
        }

        public override LoweredNode? VisitConvertedTupleLiteral(LoweredConvertedTupleLiteral node)
        {
            LoweredTupleLiteral? sourceTuple = (LoweredTupleLiteral?)this.Visit(node.SourceTuple);
            ImmutableArray<LoweredExpression> arguments = this.VisitList(node.Arguments);
            LoweredConvertedTupleLiteral updatedNode;

            if (_updatedNullabilities.TryGetValue(node, out (NullabilityInfo Info, TypeSymbol Type) infoAndType))
            {
                updatedNode = node.Update(sourceTuple, node.WasTargetTyped, arguments, node.ArgumentNamesOpt, node.InferredNamesOpt, infoAndType.Type);
                updatedNode.TopLevelNullability = infoAndType.Info;
            }
            else
            {
                updatedNode = node.Update(sourceTuple, node.WasTargetTyped, arguments, node.ArgumentNamesOpt, node.InferredNamesOpt, node.Type);
            }
            return updatedNode;
        }

        public override LoweredNode? VisitDynamicObjectCreationExpression(LoweredDynamicObjectCreationExpression node)
        {
            ImmutableArray<MethodSymbol> applicableMethods = GetUpdatedArray(node, node.ApplicableMethods);
            ImmutableArray<LoweredExpression> arguments = this.VisitList(node.Arguments);
            LoweredObjectInitializerExpressionBase? initializerExpressionOpt = (LoweredObjectInitializerExpressionBase?)this.Visit(node.InitializerExpressionOpt);
            LoweredDynamicObjectCreationExpression updatedNode;

            if (_updatedNullabilities.TryGetValue(node, out (NullabilityInfo Info, TypeSymbol Type) infoAndType))
            {
                updatedNode = node.Update(node.Name, arguments, node.ArgumentNamesOpt, node.ArgumentRefKindsOpt, initializerExpressionOpt, applicableMethods, infoAndType.Type);
                updatedNode.TopLevelNullability = infoAndType.Info;
            }
            else
            {
                updatedNode = node.Update(node.Name, arguments, node.ArgumentNamesOpt, node.ArgumentRefKindsOpt, initializerExpressionOpt, applicableMethods, node.Type);
            }
            return updatedNode;
        }

        public override LoweredNode? VisitNoPiaObjectCreationExpression(LoweredNoPiaObjectCreationExpression node)
        {
            LoweredObjectInitializerExpressionBase? initializerExpressionOpt = (LoweredObjectInitializerExpressionBase?)this.Visit(node.InitializerExpressionOpt);
            LoweredNoPiaObjectCreationExpression updatedNode;

            if (_updatedNullabilities.TryGetValue(node, out (NullabilityInfo Info, TypeSymbol Type) infoAndType))
            {
                updatedNode = node.Update(node.GuidString, initializerExpressionOpt, infoAndType.Type);
                updatedNode.TopLevelNullability = infoAndType.Info;
            }
            else
            {
                updatedNode = node.Update(node.GuidString, initializerExpressionOpt, node.Type);
            }
            return updatedNode;
        }

        public override LoweredNode? VisitObjectInitializerExpression(LoweredObjectInitializerExpression node)
        {
            LoweredObjectOrCollectionValuePlaceholder placeholder = (LoweredObjectOrCollectionValuePlaceholder)this.Visit(node.Placeholder);
            ImmutableArray<LoweredExpression> initializers = this.VisitList(node.Initializers);
            LoweredObjectInitializerExpression updatedNode;

            if (_updatedNullabilities.TryGetValue(node, out (NullabilityInfo Info, TypeSymbol Type) infoAndType))
            {
                updatedNode = node.Update(placeholder, initializers, infoAndType.Type);
                updatedNode.TopLevelNullability = infoAndType.Info;
            }
            else
            {
                updatedNode = node.Update(placeholder, initializers, node.Type);
            }
            return updatedNode;
        }

        public override LoweredNode? VisitObjectInitializerMember(LoweredObjectInitializerMember node)
        {
            Symbol? memberSymbol = GetUpdatedSymbol(node, node.MemberSymbol);
            TypeSymbol receiverType = GetUpdatedSymbol(node, node.ReceiverType);
            ImmutableArray<LoweredExpression> arguments = this.VisitList(node.Arguments);
            LoweredObjectInitializerMember updatedNode;

            if (_updatedNullabilities.TryGetValue(node, out (NullabilityInfo Info, TypeSymbol Type) infoAndType))
            {
                updatedNode = node.Update(memberSymbol, arguments, node.ArgumentNamesOpt, node.ArgumentRefKindsOpt, node.Expanded, node.ArgsToParamsOpt, node.ResultKind, receiverType, node.BinderOpt, infoAndType.Type);
                updatedNode.TopLevelNullability = infoAndType.Info;
            }
            else
            {
                updatedNode = node.Update(memberSymbol, arguments, node.ArgumentNamesOpt, node.ArgumentRefKindsOpt, node.Expanded, node.ArgsToParamsOpt, node.ResultKind, receiverType, node.BinderOpt, node.Type);
            }
            return updatedNode;
        }

        public override LoweredNode? VisitDynamicObjectInitializerMember(LoweredDynamicObjectInitializerMember node)
        {
            TypeSymbol receiverType = GetUpdatedSymbol(node, node.ReceiverType);
            LoweredDynamicObjectInitializerMember updatedNode;

            if (_updatedNullabilities.TryGetValue(node, out (NullabilityInfo Info, TypeSymbol Type) infoAndType))
            {
                updatedNode = node.Update(node.MemberName, receiverType, infoAndType.Type);
                updatedNode.TopLevelNullability = infoAndType.Info;
            }
            else
            {
                updatedNode = node.Update(node.MemberName, receiverType, node.Type);
            }
            return updatedNode;
        }

        public override LoweredNode? VisitCollectionInitializerExpression(LoweredCollectionInitializerExpression node)
        {
            LoweredObjectOrCollectionValuePlaceholder placeholder = (LoweredObjectOrCollectionValuePlaceholder)this.Visit(node.Placeholder);
            ImmutableArray<LoweredExpression> initializers = this.VisitList(node.Initializers);
            LoweredCollectionInitializerExpression updatedNode;

            if (_updatedNullabilities.TryGetValue(node, out (NullabilityInfo Info, TypeSymbol Type) infoAndType))
            {
                updatedNode = node.Update(placeholder, initializers, infoAndType.Type);
                updatedNode.TopLevelNullability = infoAndType.Info;
            }
            else
            {
                updatedNode = node.Update(placeholder, initializers, node.Type);
            }
            return updatedNode;
        }

        public override LoweredNode? VisitCollectionElementInitializer(LoweredCollectionElementInitializer node)
        {
            MethodSymbol addMethod = GetUpdatedSymbol(node, node.AddMethod);
            ImmutableArray<LoweredExpression> arguments = this.VisitList(node.Arguments);
            LoweredExpression? implicitReceiverOpt = (LoweredExpression?)this.Visit(node.ImplicitReceiverOpt);
            LoweredCollectionElementInitializer updatedNode;

            if (_updatedNullabilities.TryGetValue(node, out (NullabilityInfo Info, TypeSymbol Type) infoAndType))
            {
                updatedNode = node.Update(addMethod, arguments, implicitReceiverOpt, node.Expanded, node.ArgsToParamsOpt, node.InvokedAsExtensionMethod, node.ResultKind, node.BinderOpt, infoAndType.Type);
                updatedNode.TopLevelNullability = infoAndType.Info;
            }
            else
            {
                updatedNode = node.Update(addMethod, arguments, implicitReceiverOpt, node.Expanded, node.ArgsToParamsOpt, node.InvokedAsExtensionMethod, node.ResultKind, node.BinderOpt, node.Type);
            }
            return updatedNode;
        }

        public override LoweredNode? VisitDynamicCollectionElementInitializer(LoweredDynamicCollectionElementInitializer node)
        {
            ImmutableArray<MethodSymbol> applicableMethods = GetUpdatedArray(node, node.ApplicableMethods);
            LoweredExpression expression = (LoweredExpression)this.Visit(node.Expression);
            ImmutableArray<LoweredExpression> arguments = this.VisitList(node.Arguments);
            LoweredDynamicCollectionElementInitializer updatedNode;

            if (_updatedNullabilities.TryGetValue(node, out (NullabilityInfo Info, TypeSymbol Type) infoAndType))
            {
                updatedNode = node.Update(applicableMethods, expression, arguments, infoAndType.Type);
                updatedNode.TopLevelNullability = infoAndType.Info;
            }
            else
            {
                updatedNode = node.Update(applicableMethods, expression, arguments, node.Type);
            }
            return updatedNode;
        }

        public override LoweredNode? VisitImplicitReceiver(LoweredImplicitReceiver node)
        {
            if (!_updatedNullabilities.TryGetValue(node, out (NullabilityInfo Info, TypeSymbol Type) infoAndType))
            {
                return node;
            }

            LoweredImplicitReceiver updatedNode = node.Update(infoAndType.Type);
            updatedNode.TopLevelNullability = infoAndType.Info;
            return updatedNode;
        }

        public override LoweredNode? VisitAnonymousObjectCreationExpression(LoweredAnonymousObjectCreationExpression node)
        {
            MethodSymbol constructor = GetUpdatedSymbol(node, node.Constructor);
            ImmutableArray<LoweredExpression> arguments = this.VisitList(node.Arguments);
            ImmutableArray<LoweredAnonymousPropertyDeclaration> declarations = this.VisitList(node.Declarations);
            LoweredAnonymousObjectCreationExpression updatedNode;

            if (_updatedNullabilities.TryGetValue(node, out (NullabilityInfo Info, TypeSymbol Type) infoAndType))
            {
                updatedNode = node.Update(constructor, arguments, declarations, infoAndType.Type);
                updatedNode.TopLevelNullability = infoAndType.Info;
            }
            else
            {
                updatedNode = node.Update(constructor, arguments, declarations, node.Type);
            }
            return updatedNode;
        }

        public override LoweredNode? VisitAnonymousPropertyDeclaration(LoweredAnonymousPropertyDeclaration node)
        {
            PropertySymbol property = GetUpdatedSymbol(node, node.Property);
            LoweredAnonymousPropertyDeclaration updatedNode;

            if (_updatedNullabilities.TryGetValue(node, out (NullabilityInfo Info, TypeSymbol Type) infoAndType))
            {
                updatedNode = node.Update(property, infoAndType.Type);
                updatedNode.TopLevelNullability = infoAndType.Info;
            }
            else
            {
                updatedNode = node.Update(property, node.Type);
            }
            return updatedNode;
        }

        public override LoweredNode? VisitNewT(LoweredNewT node)
        {
            LoweredObjectInitializerExpressionBase? initializerExpressionOpt = (LoweredObjectInitializerExpressionBase?)this.Visit(node.InitializerExpressionOpt);
            LoweredNewT updatedNode;

            if (_updatedNullabilities.TryGetValue(node, out (NullabilityInfo Info, TypeSymbol Type) infoAndType))
            {
                updatedNode = node.Update(initializerExpressionOpt, infoAndType.Type);
                updatedNode.TopLevelNullability = infoAndType.Info;
            }
            else
            {
                updatedNode = node.Update(initializerExpressionOpt, node.Type);
            }
            return updatedNode;
        }

        public override LoweredNode? VisitDelegateCreationExpression(LoweredDelegateCreationExpression node)
        {
            MethodSymbol? methodOpt = GetUpdatedSymbol(node, node.MethodOpt);
            LoweredExpression argument = (LoweredExpression)this.Visit(node.Argument);
            LoweredDelegateCreationExpression updatedNode;

            if (_updatedNullabilities.TryGetValue(node, out (NullabilityInfo Info, TypeSymbol Type) infoAndType))
            {
                updatedNode = node.Update(argument, methodOpt, node.IsExtensionMethod, infoAndType.Type);
                updatedNode.TopLevelNullability = infoAndType.Info;
            }
            else
            {
                updatedNode = node.Update(argument, methodOpt, node.IsExtensionMethod, node.Type);
            }
            return updatedNode;
        }

        public override LoweredNode? VisitArrayCreation(LoweredArrayCreation node)
        {
            ImmutableArray<LoweredExpression> bounds = this.VisitList(node.Lowereds);
            LoweredArrayInitialization? initializerOpt = (LoweredArrayInitialization?)this.Visit(node.InitializerOpt);
            LoweredArrayCreation updatedNode;

            if (_updatedNullabilities.TryGetValue(node, out (NullabilityInfo Info, TypeSymbol Type) infoAndType))
            {
                updatedNode = node.Update(bounds, initializerOpt, infoAndType.Type);
                updatedNode.TopLevelNullability = infoAndType.Info;
            }
            else
            {
                updatedNode = node.Update(bounds, initializerOpt, node.Type);
            }
            return updatedNode;
        }

        public override LoweredNode? VisitArrayInitialization(LoweredArrayInitialization node)
        {
            ImmutableArray<LoweredExpression> initializers = this.VisitList(node.Initializers);
            LoweredArrayInitialization updatedNode;

            if (_updatedNullabilities.TryGetValue(node, out (NullabilityInfo Info, TypeSymbol Type) infoAndType))
            {
                updatedNode = node.Update(initializers);
                updatedNode.TopLevelNullability = infoAndType.Info;
            }
            else
            {
                updatedNode = node.Update(initializers);
            }
            return updatedNode;
        }

        public override LoweredNode? VisitStackAllocArrayCreation(LoweredStackAllocArrayCreation node)
        {
            TypeSymbol elementType = GetUpdatedSymbol(node, node.ElementType);
            LoweredExpression count = (LoweredExpression)this.Visit(node.Count);
            LoweredArrayInitialization? initializerOpt = (LoweredArrayInitialization?)this.Visit(node.InitializerOpt);
            LoweredStackAllocArrayCreation updatedNode;

            if (_updatedNullabilities.TryGetValue(node, out (NullabilityInfo Info, TypeSymbol Type) infoAndType))
            {
                updatedNode = node.Update(elementType, count, initializerOpt, infoAndType.Type);
                updatedNode.TopLevelNullability = infoAndType.Info;
            }
            else
            {
                updatedNode = node.Update(elementType, count, initializerOpt, node.Type);
            }
            return updatedNode;
        }

        public override LoweredNode? VisitConvertedStackAllocExpression(LoweredConvertedStackAllocExpression node)
        {
            TypeSymbol elementType = GetUpdatedSymbol(node, node.ElementType);
            LoweredExpression count = (LoweredExpression)this.Visit(node.Count);
            LoweredArrayInitialization? initializerOpt = (LoweredArrayInitialization?)this.Visit(node.InitializerOpt);
            LoweredConvertedStackAllocExpression updatedNode;

            if (_updatedNullabilities.TryGetValue(node, out (NullabilityInfo Info, TypeSymbol Type) infoAndType))
            {
                updatedNode = node.Update(elementType, count, initializerOpt, infoAndType.Type);
                updatedNode.TopLevelNullability = infoAndType.Info;
            }
            else
            {
                updatedNode = node.Update(elementType, count, initializerOpt, node.Type);
            }
            return updatedNode;
        }

        public override LoweredNode? VisitFieldAccess(LoweredFieldAccess node)
        {
            FieldSymbol fieldSymbol = GetUpdatedSymbol(node, node.FieldSymbol);
            LoweredExpression? receiverOpt = (LoweredExpression?)this.Visit(node.ReceiverOpt);
            LoweredFieldAccess updatedNode;

            if (_updatedNullabilities.TryGetValue(node, out (NullabilityInfo Info, TypeSymbol Type) infoAndType))
            {
                updatedNode = node.Update(receiverOpt, fieldSymbol, node.ConstantValueOpt, node.ResultKind, node.IsByValue, node.IsDeclaration, infoAndType.Type);
                updatedNode.TopLevelNullability = infoAndType.Info;
            }
            else
            {
                updatedNode = node.Update(receiverOpt, fieldSymbol, node.ConstantValueOpt, node.ResultKind, node.IsByValue, node.IsDeclaration, node.Type);
            }
            return updatedNode;
        }

        public override LoweredNode? VisitHoistedFieldAccess(LoweredHoistedFieldAccess node)
        {
            FieldSymbol fieldSymbol = GetUpdatedSymbol(node, node.FieldSymbol);
            LoweredHoistedFieldAccess updatedNode;

            if (_updatedNullabilities.TryGetValue(node, out (NullabilityInfo Info, TypeSymbol Type) infoAndType))
            {
                updatedNode = node.Update(fieldSymbol, infoAndType.Type);
                updatedNode.TopLevelNullability = infoAndType.Info;
            }
            else
            {
                updatedNode = node.Update(fieldSymbol, node.Type);
            }
            return updatedNode;
        }

        public override LoweredNode? VisitPropertyAccess(LoweredPropertyAccess node)
        {
            PropertySymbol propertySymbol = GetUpdatedSymbol(node, node.PropertySymbol);
            LoweredExpression? receiverOpt = (LoweredExpression?)this.Visit(node.ReceiverOpt);
            LoweredPropertyAccess updatedNode;

            if (_updatedNullabilities.TryGetValue(node, out (NullabilityInfo Info, TypeSymbol Type) infoAndType))
            {
                updatedNode = node.Update(receiverOpt, propertySymbol, node.ResultKind, infoAndType.Type);
                updatedNode.TopLevelNullability = infoAndType.Info;
            }
            else
            {
                updatedNode = node.Update(receiverOpt, propertySymbol, node.ResultKind, node.Type);
            }
            return updatedNode;
        }

        public override LoweredNode? VisitEventAccess(LoweredEventAccess node)
        {
            EventSymbol eventSymbol = GetUpdatedSymbol(node, node.EventSymbol);
            LoweredExpression? receiverOpt = (LoweredExpression?)this.Visit(node.ReceiverOpt);
            LoweredEventAccess updatedNode;

            if (_updatedNullabilities.TryGetValue(node, out (NullabilityInfo Info, TypeSymbol Type) infoAndType))
            {
                updatedNode = node.Update(receiverOpt, eventSymbol, node.IsUsableAsField, node.ResultKind, infoAndType.Type);
                updatedNode.TopLevelNullability = infoAndType.Info;
            }
            else
            {
                updatedNode = node.Update(receiverOpt, eventSymbol, node.IsUsableAsField, node.ResultKind, node.Type);
            }
            return updatedNode;
        }

        public override LoweredNode? VisitIndexerAccess(LoweredIndexerAccess node)
        {
            PropertySymbol indexer = GetUpdatedSymbol(node, node.Indexer);
            ImmutableArray<PropertySymbol> originalIndexersOpt = GetUpdatedArray(node, node.OriginalIndexersOpt);
            LoweredExpression? receiverOpt = (LoweredExpression?)this.Visit(node.ReceiverOpt);
            ImmutableArray<LoweredExpression> arguments = this.VisitList(node.Arguments);
            LoweredIndexerAccess updatedNode;

            if (_updatedNullabilities.TryGetValue(node, out (NullabilityInfo Info, TypeSymbol Type) infoAndType))
            {
                updatedNode = node.Update(receiverOpt, indexer, arguments, node.ArgumentNamesOpt, node.ArgumentRefKindsOpt, node.Expanded, node.ArgsToParamsOpt, node.BinderOpt, node.UseSetterForDefaultArgumentGeneration, node.OriginalIndexersOpt, infoAndType.Type);
                updatedNode.TopLevelNullability = infoAndType.Info;
            }
            else
            {
                updatedNode = node.Update(receiverOpt, indexer, arguments, node.ArgumentNamesOpt, node.ArgumentRefKindsOpt, node.Expanded, node.ArgsToParamsOpt, node.BinderOpt, node.UseSetterForDefaultArgumentGeneration, node.OriginalIndexersOpt, node.Type);
            }
            return updatedNode;
        }

        public override LoweredNode? VisitIndexOrRangePatternIndexerAccess(LoweredIndexOrRangePatternIndexerAccess node)
        {
            PropertySymbol lengthOrCountProperty = GetUpdatedSymbol(node, node.LengthOrCountProperty);
            Symbol patternSymbol = GetUpdatedSymbol(node, node.PatternSymbol);
            LoweredExpression receiver = (LoweredExpression)this.Visit(node.Receiver);
            LoweredExpression argument = (LoweredExpression)this.Visit(node.Argument);
            LoweredIndexOrRangePatternIndexerAccess updatedNode;

            if (_updatedNullabilities.TryGetValue(node, out (NullabilityInfo Info, TypeSymbol Type) infoAndType))
            {
                updatedNode = node.Update(receiver, lengthOrCountProperty, patternSymbol, argument, infoAndType.Type);
                updatedNode.TopLevelNullability = infoAndType.Info;
            }
            else
            {
                updatedNode = node.Update(receiver, lengthOrCountProperty, patternSymbol, argument, node.Type);
            }
            return updatedNode;
        }

        public override LoweredNode? VisitDynamicIndexerAccess(LoweredDynamicIndexerAccess node)
        {
            ImmutableArray<PropertySymbol> applicableIndexers = GetUpdatedArray(node, node.ApplicableIndexers);
            LoweredExpression? receiverOpt = (LoweredExpression?)this.Visit(node.ReceiverOpt);
            ImmutableArray<LoweredExpression> arguments = this.VisitList(node.Arguments);
            LoweredDynamicIndexerAccess updatedNode;

            if (_updatedNullabilities.TryGetValue(node, out (NullabilityInfo Info, TypeSymbol Type) infoAndType))
            {
                updatedNode = node.Update(receiverOpt, arguments, node.ArgumentNamesOpt, node.ArgumentRefKindsOpt, applicableIndexers, infoAndType.Type);
                updatedNode.TopLevelNullability = infoAndType.Info;
            }
            else
            {
                updatedNode = node.Update(receiverOpt, arguments, node.ArgumentNamesOpt, node.ArgumentRefKindsOpt, applicableIndexers, node.Type);
            }
            return updatedNode;
        }

        public override LoweredNode? VisitLambda(LoweredLambda node)
        {
            LambdaSymbol symbol = GetUpdatedSymbol(node, node.Symbol);
            UnboundLambda unboundLambda = node.UnboundLambda;
            LoweredBlock body = (LoweredBlock)this.Visit(node.Body);
            LoweredLambda updatedNode;

            if (_updatedNullabilities.TryGetValue(node, out (NullabilityInfo Info, TypeSymbol Type) infoAndType))
            {
                updatedNode = node.Update(unboundLambda, symbol, body, node.Diagnostics, node.Binder, infoAndType.Type);
                updatedNode.TopLevelNullability = infoAndType.Info;
            }
            else
            {
                updatedNode = node.Update(unboundLambda, symbol, body, node.Diagnostics, node.Binder, node.Type);
            }
            return updatedNode;
        }

        public override LoweredNode? VisitUnboundLambda(UnboundLambda node)
        {
            if (!_updatedNullabilities.TryGetValue(node, out (NullabilityInfo Info, TypeSymbol Type) infoAndType))
            {
                return node;
            }

            UnboundLambda updatedNode = node.Update(node.Data);
            updatedNode.TopLevelNullability = infoAndType.Info;
            return updatedNode;
        }

        public override LoweredNode? VisitQueryClause(LoweredQueryClause node)
        {
            RangeVariableSymbol? definedSymbol = GetUpdatedSymbol(node, node.DefinedSymbol);
            LoweredExpression value = (LoweredExpression)this.Visit(node.Value);
            LoweredExpression? operation = node.Operation;
            LoweredExpression? cast = node.Cast;
            LoweredExpression? unoptimizedForm = node.UnoptimizedForm;
            LoweredQueryClause updatedNode;

            if (_updatedNullabilities.TryGetValue(node, out (NullabilityInfo Info, TypeSymbol Type) infoAndType))
            {
                updatedNode = node.Update(value, definedSymbol, operation, cast, node.Binder, unoptimizedForm, infoAndType.Type);
                updatedNode.TopLevelNullability = infoAndType.Info;
            }
            else
            {
                updatedNode = node.Update(value, definedSymbol, operation, cast, node.Binder, unoptimizedForm, node.Type);
            }
            return updatedNode;
        }

        public override LoweredNode? VisitNameOfOperator(LoweredNameOfOperator node)
        {
            LoweredExpression argument = (LoweredExpression)this.Visit(node.Argument);
            LoweredNameOfOperator updatedNode;

            if (_updatedNullabilities.TryGetValue(node, out (NullabilityInfo Info, TypeSymbol Type) infoAndType))
            {
                updatedNode = node.Update(argument, node.ConstantValueOpt, infoAndType.Type);
                updatedNode.TopLevelNullability = infoAndType.Info;
            }
            else
            {
                updatedNode = node.Update(argument, node.ConstantValueOpt, node.Type);
            }
            return updatedNode;
        }

        public override LoweredNode? VisitInterpolatedString(LoweredInterpolatedString node)
        {
            ImmutableArray<LoweredExpression> parts = this.VisitList(node.Parts);
            LoweredInterpolatedString updatedNode;

            if (_updatedNullabilities.TryGetValue(node, out (NullabilityInfo Info, TypeSymbol Type) infoAndType))
            {
                updatedNode = node.Update(parts, infoAndType.Type);
                updatedNode.TopLevelNullability = infoAndType.Info;
            }
            else
            {
                updatedNode = node.Update(parts, node.Type);
            }
            return updatedNode;
        }

        public override LoweredNode? VisitStringInsert(LoweredStringInsert node)
        {
            LoweredExpression value = (LoweredExpression)this.Visit(node.Value);
            LoweredExpression? alignment = (LoweredExpression?)this.Visit(node.Alignment);
            LoweredLiteral? format = (LoweredLiteral?)this.Visit(node.Format);
            LoweredStringInsert updatedNode;

            if (_updatedNullabilities.TryGetValue(node, out (NullabilityInfo Info, TypeSymbol Type) infoAndType))
            {
                updatedNode = node.Update(value, alignment, format, infoAndType.Type);
                updatedNode.TopLevelNullability = infoAndType.Info;
            }
            else
            {
                updatedNode = node.Update(value, alignment, format, node.Type);
            }
            return updatedNode;
        }

        public override LoweredNode? VisitIsPatternExpression(LoweredIsPatternExpression node)
        {
            LoweredExpression expression = (LoweredExpression)this.Visit(node.Expression);
            LoweredPattern pattern = (LoweredPattern)this.Visit(node.Pattern);
            LoweredDecisionDag decisionDag = node.DecisionDag;
            LoweredIsPatternExpression updatedNode;

            if (_updatedNullabilities.TryGetValue(node, out (NullabilityInfo Info, TypeSymbol Type) infoAndType))
            {
                updatedNode = node.Update(expression, pattern, decisionDag, node.WhenTrueLabel, node.WhenFalseLabel, infoAndType.Type);
                updatedNode.TopLevelNullability = infoAndType.Info;
            }
            else
            {
                updatedNode = node.Update(expression, pattern, decisionDag, node.WhenTrueLabel, node.WhenFalseLabel, node.Type);
            }
            return updatedNode;
        }

        public override LoweredNode? VisitConstantPattern(LoweredConstantPattern node)
        {
            TypeSymbol inputType = GetUpdatedSymbol(node, node.InputType);
            LoweredExpression value = (LoweredExpression)this.Visit(node.Value);
            return node.Update(value, node.ConstantValue, inputType);
        }

        public override LoweredNode? VisitDiscardPattern(LoweredDiscardPattern node)
        {
            TypeSymbol inputType = GetUpdatedSymbol(node, node.InputType);
            return node.Update(inputType);
        }

        public override LoweredNode? VisitDeclarationPattern(LoweredDeclarationPattern node)
        {
            Symbol? variable = GetUpdatedSymbol(node, node.Variable);
            TypeSymbol inputType = GetUpdatedSymbol(node, node.InputType);
            LoweredExpression? variableAccess = (LoweredExpression?)this.Visit(node.VariableAccess);
            LoweredTypeExpression? declaredType = (LoweredTypeExpression?)this.Visit(node.DeclaredType);
            return node.Update(variable, variableAccess, declaredType, node.IsVar, inputType);
        }

        public override LoweredNode? VisitRecursivePattern(LoweredRecursivePattern node)
        {
            MethodSymbol? deconstructMethod = GetUpdatedSymbol(node, node.DeconstructMethod);
            Symbol? variable = GetUpdatedSymbol(node, node.Variable);
            TypeSymbol inputType = GetUpdatedSymbol(node, node.InputType);
            LoweredTypeExpression? declaredType = (LoweredTypeExpression?)this.Visit(node.DeclaredType);
            ImmutableArray<LoweredSubpattern> deconstruction = this.VisitList(node.Deconstruction);
            ImmutableArray<LoweredSubpattern> properties = this.VisitList(node.Properties);
            LoweredExpression? variableAccess = (LoweredExpression?)this.Visit(node.VariableAccess);
            return node.Update(declaredType, deconstructMethod, deconstruction, properties, variable, variableAccess, node.IsExplicitNotNullTest, inputType);
        }

        public override LoweredNode? VisitITuplePattern(LoweredITuplePattern node)
        {
            MethodSymbol getLengthMethod = GetUpdatedSymbol(node, node.GetLengthMethod);
            MethodSymbol getItemMethod = GetUpdatedSymbol(node, node.GetItemMethod);
            TypeSymbol inputType = GetUpdatedSymbol(node, node.InputType);
            ImmutableArray<LoweredSubpattern> subpatterns = this.VisitList(node.Subpatterns);
            return node.Update(getLengthMethod, getItemMethod, subpatterns, inputType);
        }

        public override LoweredNode? VisitSubpattern(LoweredSubpattern node)
        {
            Symbol? symbol = GetUpdatedSymbol(node, node.Symbol);
            LoweredPattern pattern = (LoweredPattern)this.Visit(node.Pattern);
            return node.Update(symbol, pattern);
        }

        public override LoweredNode? VisitDiscardExpression(LoweredDiscardExpression node)
        {
            if (!_updatedNullabilities.TryGetValue(node, out (NullabilityInfo Info, TypeSymbol Type) infoAndType))
            {
                return node;
            }

            LoweredDiscardExpression updatedNode = node.Update(infoAndType.Type);
            updatedNode.TopLevelNullability = infoAndType.Info;
            return updatedNode;
        }

        public override LoweredNode? VisitThrowExpression(LoweredThrowExpression node)
        {
            LoweredExpression expression = (LoweredExpression)this.Visit(node.Expression);
            LoweredThrowExpression updatedNode;

            if (_updatedNullabilities.TryGetValue(node, out (NullabilityInfo Info, TypeSymbol Type) infoAndType))
            {
                updatedNode = node.Update(expression, infoAndType.Type);
                updatedNode.TopLevelNullability = infoAndType.Info;
            }
            else
            {
                updatedNode = node.Update(expression, node.Type);
            }
            return updatedNode;
        }

        public override LoweredNode? VisitOutVariablePendingInference(OutVariablePendingInference node)
        {
            Symbol variableSymbol = GetUpdatedSymbol(node, node.VariableSymbol);
            LoweredExpression? receiverOpt = (LoweredExpression?)this.Visit(node.ReceiverOpt);
            OutVariablePendingInference updatedNode;

            if (_updatedNullabilities.TryGetValue(node, out (NullabilityInfo Info, TypeSymbol Type) infoAndType))
            {
                updatedNode = node.Update(variableSymbol, receiverOpt);
                updatedNode.TopLevelNullability = infoAndType.Info;
            }
            else
            {
                updatedNode = node.Update(variableSymbol, receiverOpt);
            }
            return updatedNode;
        }

        public override LoweredNode? VisitDeconstructionVariablePendingInference(DeconstructionVariablePendingInference node)
        {
            Symbol variableSymbol = GetUpdatedSymbol(node, node.VariableSymbol);
            LoweredExpression? receiverOpt = (LoweredExpression?)this.Visit(node.ReceiverOpt);
            DeconstructionVariablePendingInference updatedNode;

            if (_updatedNullabilities.TryGetValue(node, out (NullabilityInfo Info, TypeSymbol Type) infoAndType))
            {
                updatedNode = node.Update(variableSymbol, receiverOpt);
                updatedNode.TopLevelNullability = infoAndType.Info;
            }
            else
            {
                updatedNode = node.Update(variableSymbol, receiverOpt);
            }
            return updatedNode;
        }

        public override LoweredNode? VisitOutDeconstructVarPendingInference(OutDeconstructVarPendingInference node)
        {
            if (!_updatedNullabilities.TryGetValue(node, out (NullabilityInfo Info, TypeSymbol Type) infoAndType))
            {
                return node;
            }

            OutDeconstructVarPendingInference updatedNode = node.Update();
            updatedNode.TopLevelNullability = infoAndType.Info;
            return updatedNode;
        }

        public override LoweredNode? VisitConstructorMethodBody(LoweredConstructorMethodBody node)
        {
            ImmutableArray<LocalSymbol> locals = GetUpdatedArray(node, node.Locals);
            LoweredExpressionStatement? initializer = (LoweredExpressionStatement?)this.Visit(node.Initializer);
            LoweredBlock? blockBody = (LoweredBlock?)this.Visit(node.BlockBody);
            LoweredBlock? expressionBody = (LoweredBlock?)this.Visit(node.ExpressionBody);
            return node.Update(locals, initializer, blockBody, expressionBody);
        }

        public override LoweredNode? VisitExpressionWithNullability(LoweredExpressionWithNullability node)
        {
            LoweredExpression expression = (LoweredExpression)this.Visit(node.Expression);
            LoweredExpressionWithNullability updatedNode;

            if (_updatedNullabilities.TryGetValue(node, out (NullabilityInfo Info, TypeSymbol Type) infoAndType))
            {
                updatedNode = node.Update(expression, node.NullableAnnotation, infoAndType.Type);
                updatedNode.TopLevelNullability = infoAndType.Info;
            }
            else
            {
                updatedNode = node.Update(expression, node.NullableAnnotation, node.Type);
            }
            return updatedNode;
        }
    }

    internal sealed class LoweredTreeDumperNodeProducer : LoweredTreeVisitor<object?, TreeDumperNode>
    {
        private LoweredTreeDumperNodeProducer()
        {
        }
        public static TreeDumperNode MakeTree(LoweredNode node) => (new LoweredTreeDumperNodeProducer()).Visit(node, null);
        public override TreeDumperNode VisitFieldEqualsValue(LoweredFieldEqualsValue node, object? arg) => new TreeDumperNode("fieldEqualsValue", null, new TreeDumperNode[]
        {
            new TreeDumperNode("field", node.Field, null),
            new TreeDumperNode("locals", node.Locals, null),
            new TreeDumperNode("value", null, new TreeDumperNode[] { Visit(node.Value, null) }),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitPropertyEqualsValue(LoweredPropertyEqualsValue node, object? arg) => new TreeDumperNode("propertyEqualsValue", null, new TreeDumperNode[]
        {
            new TreeDumperNode("property", node.Property, null),
            new TreeDumperNode("locals", node.Locals, null),
            new TreeDumperNode("value", null, new TreeDumperNode[] { Visit(node.Value, null) }),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitParameterEqualsValue(LoweredParameterEqualsValue node, object? arg) => new TreeDumperNode("parameterEqualsValue", null, new TreeDumperNode[]
        {
            new TreeDumperNode("parameter", node.Parameter, null),
            new TreeDumperNode("locals", node.Locals, null),
            new TreeDumperNode("value", null, new TreeDumperNode[] { Visit(node.Value, null) }),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitGlobalStatementInitializer(LoweredGlobalStatementInitializer node, object? arg) => new TreeDumperNode("globalStatementInitializer", null, new TreeDumperNode[]
        {
            new TreeDumperNode("statement", null, new TreeDumperNode[] { Visit(node.Statement, null) }),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitDeconstructValuePlaceholder(LoweredDeconstructValuePlaceholder node, object? arg) => new TreeDumperNode("deconstructValuePlaceholder", null, new TreeDumperNode[]
        {
            new TreeDumperNode("valEscape", node.ValEscape, null),
            new TreeDumperNode("type", node.Type, null),
            new TreeDumperNode("isSuppressed", node.IsSuppressed, null),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitTupleOperandPlaceholder(LoweredTupleOperandPlaceholder node, object? arg) => new TreeDumperNode("tupleOperandPlaceholder", null, new TreeDumperNode[]
        {
            new TreeDumperNode("type", node.Type, null),
            new TreeDumperNode("isSuppressed", node.IsSuppressed, null),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitAwaitableValuePlaceholder(LoweredAwaitableValuePlaceholder node, object? arg) => new TreeDumperNode("awaitableValuePlaceholder", null, new TreeDumperNode[]
        {
            new TreeDumperNode("valEscape", node.ValEscape, null),
            new TreeDumperNode("type", node.Type, null),
            new TreeDumperNode("isSuppressed", node.IsSuppressed, null),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitDisposableValuePlaceholder(LoweredDisposableValuePlaceholder node, object? arg) => new TreeDumperNode("disposableValuePlaceholder", null, new TreeDumperNode[]
        {
            new TreeDumperNode("type", node.Type, null),
            new TreeDumperNode("isSuppressed", node.IsSuppressed, null),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitObjectOrCollectionValuePlaceholder(LoweredObjectOrCollectionValuePlaceholder node, object? arg) => new TreeDumperNode("objectOrCollectionValuePlaceholder", null, new TreeDumperNode[]
        {
            new TreeDumperNode("type", node.Type, null),
            new TreeDumperNode("isSuppressed", node.IsSuppressed, null),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitDup(LoweredDup node, object? arg) => new TreeDumperNode("dup", null, new TreeDumperNode[]
        {
            new TreeDumperNode("refKind", node.RefKind, null),
            new TreeDumperNode("type", node.Type, null),
            new TreeDumperNode("isSuppressed", node.IsSuppressed, null),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitPassByCopy(LoweredPassByCopy node, object? arg) => new TreeDumperNode("passByCopy", null, new TreeDumperNode[]
        {
            new TreeDumperNode("expression", null, new TreeDumperNode[] { Visit(node.Expression, null) }),
            new TreeDumperNode("type", node.Type, null),
            new TreeDumperNode("isSuppressed", node.IsSuppressed, null),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitBadExpression(LoweredBadExpression node, object? arg) => new TreeDumperNode("badExpression", null, new TreeDumperNode[]
        {
            new TreeDumperNode("resultKind", node.ResultKind, null),
            new TreeDumperNode("symbols", node.Symbols, null),
            new TreeDumperNode("childLoweredNodes", null, from x in node.ChildLoweredNodes select Visit(x, null)),
            new TreeDumperNode("type", node.Type, null),
            new TreeDumperNode("isSuppressed", node.IsSuppressed, null),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitBadStatement(LoweredBadStatement node, object? arg) => new TreeDumperNode("badStatement", null, new TreeDumperNode[]
        {
            new TreeDumperNode("childLoweredNodes", null, from x in node.ChildLoweredNodes select Visit(x, null)),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitExtractedFinallyBlock(LoweredExtractedFinallyBlock node, object? arg) => new TreeDumperNode("extractedFinallyBlock", null, new TreeDumperNode[]
        {
            new TreeDumperNode("finallyBlock", null, new TreeDumperNode[] { Visit(node.FinallyBlock, null) }),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitTypeExpression(LoweredTypeExpression node, object? arg) => new TreeDumperNode("typeExpression", null, new TreeDumperNode[]
        {
            new TreeDumperNode("aliasOpt", node.AliasOpt, null),
            new TreeDumperNode("boundContainingTypeOpt", null, new TreeDumperNode[] { Visit(node.LoweredContainingTypeOpt, null) }),
            new TreeDumperNode("boundDimensionsOpt", null, node.LoweredDimensionsOpt.IsDefault ? Array.Empty<TreeDumperNode>() : from x in node.LoweredDimensionsOpt select Visit(x, null)),
            new TreeDumperNode("typeWithAnnotations", node.TypeWithAnnotations, null),
            new TreeDumperNode("type", node.Type, null),
            new TreeDumperNode("isSuppressed", node.IsSuppressed, null),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitTypeOrValueExpression(LoweredTypeOrValueExpression node, object? arg) => new TreeDumperNode("typeOrValueExpression", null, new TreeDumperNode[]
        {
            new TreeDumperNode("data", node.Data, null),
            new TreeDumperNode("type", node.Type, null),
            new TreeDumperNode("isSuppressed", node.IsSuppressed, null),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitNamespaceExpression(LoweredNamespaceExpression node, object? arg) => new TreeDumperNode("namespaceExpression", null, new TreeDumperNode[]
        {
            new TreeDumperNode("namespaceSymbol", node.NamespaceSymbol, null),
            new TreeDumperNode("aliasOpt", node.AliasOpt, null),
            new TreeDumperNode("type", node.Type, null),
            new TreeDumperNode("isSuppressed", node.IsSuppressed, null),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitUnaryOperator(LoweredUnaryOperator node, object? arg) => new TreeDumperNode("unaryOperator", null, new TreeDumperNode[]
        {
            new TreeDumperNode("operatorKind", node.OperatorKind, null),
            new TreeDumperNode("operand", null, new TreeDumperNode[] { Visit(node.Operand, null) }),
            new TreeDumperNode("constantValueOpt", node.ConstantValueOpt, null),
            new TreeDumperNode("methodOpt", node.MethodOpt, null),
            new TreeDumperNode("resultKind", node.ResultKind, null),
            new TreeDumperNode("originalUserDefinedOperatorsOpt", node.OriginalUserDefinedOperatorsOpt, null),
            new TreeDumperNode("type", node.Type, null),
            new TreeDumperNode("isSuppressed", node.IsSuppressed, null),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitIncrementOperator(LoweredIncrementOperator node, object? arg) => new TreeDumperNode("incrementOperator", null, new TreeDumperNode[]
        {
            new TreeDumperNode("operatorKind", node.OperatorKind, null),
            new TreeDumperNode("operand", null, new TreeDumperNode[] { Visit(node.Operand, null) }),
            new TreeDumperNode("methodOpt", node.MethodOpt, null),
            new TreeDumperNode("operandConversion", node.OperandConversion, null),
            new TreeDumperNode("resultConversion", node.ResultConversion, null),
            new TreeDumperNode("resultKind", node.ResultKind, null),
            new TreeDumperNode("originalUserDefinedOperatorsOpt", node.OriginalUserDefinedOperatorsOpt, null),
            new TreeDumperNode("type", node.Type, null),
            new TreeDumperNode("isSuppressed", node.IsSuppressed, null),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitAddressOfOperator(LoweredAddressOfOperator node, object? arg) => new TreeDumperNode("addressOfOperator", null, new TreeDumperNode[]
        {
            new TreeDumperNode("operand", null, new TreeDumperNode[] { Visit(node.Operand, null) }),
            new TreeDumperNode("isManaged", node.IsManaged, null),
            new TreeDumperNode("type", node.Type, null),
            new TreeDumperNode("isSuppressed", node.IsSuppressed, null),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitPointerIndirectionOperator(LoweredPointerIndirectionOperator node, object? arg) => new TreeDumperNode("pointerIndirectionOperator", null, new TreeDumperNode[]
        {
            new TreeDumperNode("operand", null, new TreeDumperNode[] { Visit(node.Operand, null) }),
            new TreeDumperNode("type", node.Type, null),
            new TreeDumperNode("isSuppressed", node.IsSuppressed, null),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitPointerElementAccess(LoweredPointerElementAccess node, object? arg) => new TreeDumperNode("pointerElementAccess", null, new TreeDumperNode[]
        {
            new TreeDumperNode("expression", null, new TreeDumperNode[] { Visit(node.Expression, null) }),
            new TreeDumperNode("index", null, new TreeDumperNode[] { Visit(node.Index, null) }),
            new TreeDumperNode("@checked", node.Checked, null),
            new TreeDumperNode("type", node.Type, null),
            new TreeDumperNode("isSuppressed", node.IsSuppressed, null),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitRefTypeOperator(LoweredRefTypeOperator node, object? arg) => new TreeDumperNode("refTypeOperator", null, new TreeDumperNode[]
        {
            new TreeDumperNode("operand", null, new TreeDumperNode[] { Visit(node.Operand, null) }),
            new TreeDumperNode("getTypeFromHandle", node.GetTypeFromHandle, null),
            new TreeDumperNode("type", node.Type, null),
            new TreeDumperNode("isSuppressed", node.IsSuppressed, null),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitMakeRefOperator(LoweredMakeRefOperator node, object? arg) => new TreeDumperNode("makeRefOperator", null, new TreeDumperNode[]
        {
            new TreeDumperNode("operand", null, new TreeDumperNode[] { Visit(node.Operand, null) }),
            new TreeDumperNode("type", node.Type, null),
            new TreeDumperNode("isSuppressed", node.IsSuppressed, null),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitRefValueOperator(LoweredRefValueOperator node, object? arg) => new TreeDumperNode("refValueOperator", null, new TreeDumperNode[]
        {
            new TreeDumperNode("nullableAnnotation", node.NullableAnnotation, null),
            new TreeDumperNode("operand", null, new TreeDumperNode[] { Visit(node.Operand, null) }),
            new TreeDumperNode("type", node.Type, null),
            new TreeDumperNode("isSuppressed", node.IsSuppressed, null),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitFromEndIndexExpression(LoweredFromEndIndexExpression node, object? arg) => new TreeDumperNode("fromEndIndexExpression", null, new TreeDumperNode[]
        {
            new TreeDumperNode("operand", null, new TreeDumperNode[] { Visit(node.Operand, null) }),
            new TreeDumperNode("methodOpt", node.MethodOpt, null),
            new TreeDumperNode("type", node.Type, null),
            new TreeDumperNode("isSuppressed", node.IsSuppressed, null),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitRangeExpression(LoweredRangeExpression node, object? arg) => new TreeDumperNode("rangeExpression", null, new TreeDumperNode[]
        {
            new TreeDumperNode("leftOperandOpt", null, new TreeDumperNode[] { Visit(node.LeftOperandOpt, null) }),
            new TreeDumperNode("rightOperandOpt", null, new TreeDumperNode[] { Visit(node.RightOperandOpt, null) }),
            new TreeDumperNode("methodOpt", node.MethodOpt, null),
            new TreeDumperNode("type", node.Type, null),
            new TreeDumperNode("isSuppressed", node.IsSuppressed, null),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitBinaryOperator(LoweredBinaryOperator node, object? arg) => new TreeDumperNode("binaryOperator", null, new TreeDumperNode[]
        {
            new TreeDumperNode("operatorKind", node.OperatorKind, null),
            new TreeDumperNode("constantValueOpt", node.ConstantValueOpt, null),
            new TreeDumperNode("methodOpt", node.MethodOpt, null),
            new TreeDumperNode("resultKind", node.ResultKind, null),
            new TreeDumperNode("originalUserDefinedOperatorsOpt", node.OriginalUserDefinedOperatorsOpt, null),
            new TreeDumperNode("left", null, new TreeDumperNode[] { Visit(node.Left, null) }),
            new TreeDumperNode("right", null, new TreeDumperNode[] { Visit(node.Right, null) }),
            new TreeDumperNode("type", node.Type, null),
            new TreeDumperNode("isSuppressed", node.IsSuppressed, null),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitTupleBinaryOperator(LoweredTupleBinaryOperator node, object? arg) => new TreeDumperNode("tupleBinaryOperator", null, new TreeDumperNode[]
        {
            new TreeDumperNode("left", null, new TreeDumperNode[] { Visit(node.Left, null) }),
            new TreeDumperNode("right", null, new TreeDumperNode[] { Visit(node.Right, null) }),
            new TreeDumperNode("operatorKind", node.OperatorKind, null),
            new TreeDumperNode("operators", node.Operators, null),
            new TreeDumperNode("type", node.Type, null),
            new TreeDumperNode("isSuppressed", node.IsSuppressed, null),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitUserDefinedConditionalLogicalOperator(LoweredUserDefinedConditionalLogicalOperator node, object? arg) => new TreeDumperNode("userDefinedConditionalLogicalOperator", null, new TreeDumperNode[]
        {
            new TreeDumperNode("operatorKind", node.OperatorKind, null),
            new TreeDumperNode("logicalOperator", node.LogicalOperator, null),
            new TreeDumperNode("trueOperator", node.TrueOperator, null),
            new TreeDumperNode("falseOperator", node.FalseOperator, null),
            new TreeDumperNode("resultKind", node.ResultKind, null),
            new TreeDumperNode("originalUserDefinedOperatorsOpt", node.OriginalUserDefinedOperatorsOpt, null),
            new TreeDumperNode("left", null, new TreeDumperNode[] { Visit(node.Left, null) }),
            new TreeDumperNode("right", null, new TreeDumperNode[] { Visit(node.Right, null) }),
            new TreeDumperNode("type", node.Type, null),
            new TreeDumperNode("isSuppressed", node.IsSuppressed, null),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitCompoundAssignmentOperator(LoweredCompoundAssignmentOperator node, object? arg) => new TreeDumperNode("compoundAssignmentOperator", null, new TreeDumperNode[]
        {
            new TreeDumperNode("@operator", node.Operator, null),
            new TreeDumperNode("left", null, new TreeDumperNode[] { Visit(node.Left, null) }),
            new TreeDumperNode("right", null, new TreeDumperNode[] { Visit(node.Right, null) }),
            new TreeDumperNode("leftConversion", node.LeftConversion, null),
            new TreeDumperNode("finalConversion", node.FinalConversion, null),
            new TreeDumperNode("resultKind", node.ResultKind, null),
            new TreeDumperNode("originalUserDefinedOperatorsOpt", node.OriginalUserDefinedOperatorsOpt, null),
            new TreeDumperNode("type", node.Type, null),
            new TreeDumperNode("isSuppressed", node.IsSuppressed, null),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitAssignmentOperator(LoweredAssignmentOperator node, object? arg) => new TreeDumperNode("assignmentOperator", null, new TreeDumperNode[]
        {
            new TreeDumperNode("left", null, new TreeDumperNode[] { Visit(node.Left, null) }),
            new TreeDumperNode("right", null, new TreeDumperNode[] { Visit(node.Right, null) }),
            new TreeDumperNode("isRef", node.IsRef, null),
            new TreeDumperNode("type", node.Type, null),
            new TreeDumperNode("isSuppressed", node.IsSuppressed, null),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitDeconstructionAssignmentOperator(LoweredDeconstructionAssignmentOperator node, object? arg) => new TreeDumperNode("deconstructionAssignmentOperator", null, new TreeDumperNode[]
        {
            new TreeDumperNode("left", null, new TreeDumperNode[] { Visit(node.Left, null) }),
            new TreeDumperNode("right", null, new TreeDumperNode[] { Visit(node.Right, null) }),
            new TreeDumperNode("isUsed", node.IsUsed, null),
            new TreeDumperNode("type", node.Type, null),
            new TreeDumperNode("isSuppressed", node.IsSuppressed, null),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitNullCoalescingOperator(LoweredNullCoalescingOperator node, object? arg) => new TreeDumperNode("nullCoalescingOperator", null, new TreeDumperNode[]
        {
            new TreeDumperNode("leftOperand", null, new TreeDumperNode[] { Visit(node.LeftOperand, null) }),
            new TreeDumperNode("rightOperand", null, new TreeDumperNode[] { Visit(node.RightOperand, null) }),
            new TreeDumperNode("leftConversion", node.LeftConversion, null),
            new TreeDumperNode("operatorResultKind", node.OperatorResultKind, null),
            new TreeDumperNode("type", node.Type, null),
            new TreeDumperNode("isSuppressed", node.IsSuppressed, null),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitNullCoalescingAssignmentOperator(LoweredNullCoalescingAssignmentOperator node, object? arg) => new TreeDumperNode("nullCoalescingAssignmentOperator", null, new TreeDumperNode[]
        {
            new TreeDumperNode("leftOperand", null, new TreeDumperNode[] { Visit(node.LeftOperand, null) }),
            new TreeDumperNode("rightOperand", null, new TreeDumperNode[] { Visit(node.RightOperand, null) }),
            new TreeDumperNode("type", node.Type, null),
            new TreeDumperNode("isSuppressed", node.IsSuppressed, null),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitConditionalOperator(LoweredConditionalOperator node, object? arg) => new TreeDumperNode("conditionalOperator", null, new TreeDumperNode[]
        {
            new TreeDumperNode("isRef", node.IsRef, null),
            new TreeDumperNode("condition", null, new TreeDumperNode[] { Visit(node.Condition, null) }),
            new TreeDumperNode("consequence", null, new TreeDumperNode[] { Visit(node.Consequence, null) }),
            new TreeDumperNode("alternative", null, new TreeDumperNode[] { Visit(node.Alternative, null) }),
            new TreeDumperNode("constantValueOpt", node.ConstantValueOpt, null),
            new TreeDumperNode("type", node.Type, null),
            new TreeDumperNode("isSuppressed", node.IsSuppressed, null),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitArrayAccess(LoweredArrayAccess node, object? arg) => new TreeDumperNode("arrayAccess", null, new TreeDumperNode[]
        {
            new TreeDumperNode("expression", null, new TreeDumperNode[] { Visit(node.Expression, null) }),
            new TreeDumperNode("indices", null, from x in node.Indices select Visit(x, null)),
            new TreeDumperNode("type", node.Type, null),
            new TreeDumperNode("isSuppressed", node.IsSuppressed, null),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitArrayLength(LoweredArrayLength node, object? arg) => new TreeDumperNode("arrayLength", null, new TreeDumperNode[]
        {
            new TreeDumperNode("expression", null, new TreeDumperNode[] { Visit(node.Expression, null) }),
            new TreeDumperNode("type", node.Type, null),
            new TreeDumperNode("isSuppressed", node.IsSuppressed, null),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitAwaitableInfo(LoweredAwaitableInfo node, object? arg) => new TreeDumperNode("awaitableInfo", null, new TreeDumperNode[]
        {
            new TreeDumperNode("awaitableInstancePlaceholder", null, new TreeDumperNode[] { Visit(node.AwaitableInstancePlaceholder, null) }),
            new TreeDumperNode("isDynamic", node.IsDynamic, null),
            new TreeDumperNode("getAwaiter", null, new TreeDumperNode[] { Visit(node.GetAwaiter, null) }),
            new TreeDumperNode("isCompleted", node.IsCompleted, null),
            new TreeDumperNode("getResult", node.GetResult, null),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitAwaitExpression(LoweredAwaitExpression node, object? arg) => new TreeDumperNode("awaitExpression", null, new TreeDumperNode[]
        {
            new TreeDumperNode("expression", null, new TreeDumperNode[] { Visit(node.Expression, null) }),
            new TreeDumperNode("awaitableInfo", null, new TreeDumperNode[] { Visit(node.AwaitableInfo, null) }),
            new TreeDumperNode("type", node.Type, null),
            new TreeDumperNode("isSuppressed", node.IsSuppressed, null),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitTypeOfOperator(LoweredTypeOfOperator node, object? arg) => new TreeDumperNode("typeOfOperator", null, new TreeDumperNode[]
        {
            new TreeDumperNode("sourceType", null, new TreeDumperNode[] { Visit(node.SourceType, null) }),
            new TreeDumperNode("getTypeFromHandle", node.GetTypeFromHandle, null),
            new TreeDumperNode("type", node.Type, null),
            new TreeDumperNode("isSuppressed", node.IsSuppressed, null),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitMethodDefIndex(LoweredMethodDefIndex node, object? arg) => new TreeDumperNode("methodDefIndex", null, new TreeDumperNode[]
        {
            new TreeDumperNode("method", node.Method, null),
            new TreeDumperNode("type", node.Type, null),
            new TreeDumperNode("isSuppressed", node.IsSuppressed, null),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitMaximumMethodDefIndex(LoweredMaximumMethodDefIndex node, object? arg) => new TreeDumperNode("maximumMethodDefIndex", null, new TreeDumperNode[]
        {
            new TreeDumperNode("type", node.Type, null),
            new TreeDumperNode("isSuppressed", node.IsSuppressed, null),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitInstrumentationPayloadRoot(LoweredInstrumentationPayloadRoot node, object? arg) => new TreeDumperNode("instrumentationPayloadRoot", null, new TreeDumperNode[]
        {
            new TreeDumperNode("analysisKind", node.AnalysisKind, null),
            new TreeDumperNode("type", node.Type, null),
            new TreeDumperNode("isSuppressed", node.IsSuppressed, null),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitModuleVersionId(LoweredModuleVersionId node, object? arg) => new TreeDumperNode("moduleVersionId", null, new TreeDumperNode[]
        {
            new TreeDumperNode("type", node.Type, null),
            new TreeDumperNode("isSuppressed", node.IsSuppressed, null),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitModuleVersionIdString(LoweredModuleVersionIdString node, object? arg) => new TreeDumperNode("moduleVersionIdString", null, new TreeDumperNode[]
        {
            new TreeDumperNode("type", node.Type, null),
            new TreeDumperNode("isSuppressed", node.IsSuppressed, null),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitSourceDocumentIndex(LoweredSourceDocumentIndex node, object? arg) => new TreeDumperNode("sourceDocumentIndex", null, new TreeDumperNode[]
        {
            new TreeDumperNode("document", node.Document, null),
            new TreeDumperNode("type", node.Type, null),
            new TreeDumperNode("isSuppressed", node.IsSuppressed, null),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitMethodInfo(LoweredMethodInfo node, object? arg) => new TreeDumperNode("methodInfo", null, new TreeDumperNode[]
        {
            new TreeDumperNode("method", node.Method, null),
            new TreeDumperNode("getMethodFromHandle", node.GetMethodFromHandle, null),
            new TreeDumperNode("type", node.Type, null),
            new TreeDumperNode("isSuppressed", node.IsSuppressed, null),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitFieldInfo(LoweredFieldInfo node, object? arg) => new TreeDumperNode("fieldInfo", null, new TreeDumperNode[]
        {
            new TreeDumperNode("field", node.Field, null),
            new TreeDumperNode("getFieldFromHandle", node.GetFieldFromHandle, null),
            new TreeDumperNode("type", node.Type, null),
            new TreeDumperNode("isSuppressed", node.IsSuppressed, null),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitDefaultLiteral(LoweredDefaultLiteral node, object? arg) => new TreeDumperNode("defaultLiteral", null, new TreeDumperNode[]
        {
            new TreeDumperNode("type", node.Type, null),
            new TreeDumperNode("isSuppressed", node.IsSuppressed, null),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitDefaultExpression(LoweredDefaultExpression node, object? arg) => new TreeDumperNode("defaultExpression", null, new TreeDumperNode[]
        {
            new TreeDumperNode("targetType", null, new TreeDumperNode[] { Visit(node.TargetType, null) }),
            new TreeDumperNode("constantValueOpt", node.ConstantValueOpt, null),
            new TreeDumperNode("type", node.Type, null),
            new TreeDumperNode("isSuppressed", node.IsSuppressed, null),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitIsOperator(LoweredIsOperator node, object? arg) => new TreeDumperNode("isOperator", null, new TreeDumperNode[]
        {
            new TreeDumperNode("operand", null, new TreeDumperNode[] { Visit(node.Operand, null) }),
            new TreeDumperNode("targetType", null, new TreeDumperNode[] { Visit(node.TargetType, null) }),
            new TreeDumperNode("conversion", node.Conversion, null),
            new TreeDumperNode("type", node.Type, null),
            new TreeDumperNode("isSuppressed", node.IsSuppressed, null),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitAsOperator(LoweredAsOperator node, object? arg) => new TreeDumperNode("asOperator", null, new TreeDumperNode[]
        {
            new TreeDumperNode("operand", null, new TreeDumperNode[] { Visit(node.Operand, null) }),
            new TreeDumperNode("targetType", null, new TreeDumperNode[] { Visit(node.TargetType, null) }),
            new TreeDumperNode("conversion", node.Conversion, null),
            new TreeDumperNode("type", node.Type, null),
            new TreeDumperNode("isSuppressed", node.IsSuppressed, null),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitSizeOfOperator(LoweredSizeOfOperator node, object? arg) => new TreeDumperNode("sizeOfOperator", null, new TreeDumperNode[]
        {
            new TreeDumperNode("sourceType", null, new TreeDumperNode[] { Visit(node.SourceType, null) }),
            new TreeDumperNode("constantValueOpt", node.ConstantValueOpt, null),
            new TreeDumperNode("type", node.Type, null),
            new TreeDumperNode("isSuppressed", node.IsSuppressed, null),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitConversion(LoweredConversion node, object? arg) => new TreeDumperNode("conversion", null, new TreeDumperNode[]
        {
            new TreeDumperNode("operand", null, new TreeDumperNode[] { Visit(node.Operand, null) }),
            new TreeDumperNode("conversion", node.Conversion, null),
            new TreeDumperNode("isBaseConversion", node.IsBaseConversion, null),
            new TreeDumperNode("@checked", node.Checked, null),
            new TreeDumperNode("explicitCastInCode", node.ExplicitCastInCode, null),
            new TreeDumperNode("constantValueOpt", node.ConstantValueOpt, null),
            new TreeDumperNode("conversionGroupOpt", node.ConversionGroupOpt, null),
            new TreeDumperNode("originalUserDefinedConversionsOpt", node.OriginalUserDefinedConversionsOpt, null),
            new TreeDumperNode("type", node.Type, null),
            new TreeDumperNode("isSuppressed", node.IsSuppressed, null),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitReadOnlySpanFromArray(LoweredReadOnlySpanFromArray node, object? arg) => new TreeDumperNode("readOnlySpanFromArray", null, new TreeDumperNode[]
        {
            new TreeDumperNode("operand", null, new TreeDumperNode[] { Visit(node.Operand, null) }),
            new TreeDumperNode("conversionMethod", node.ConversionMethod, null),
            new TreeDumperNode("type", node.Type, null),
            new TreeDumperNode("isSuppressed", node.IsSuppressed, null),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitArgList(LoweredArgList node, object? arg) => new TreeDumperNode("argList", null, new TreeDumperNode[]
        {
            new TreeDumperNode("type", node.Type, null),
            new TreeDumperNode("isSuppressed", node.IsSuppressed, null),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitArgListOperator(LoweredArgListOperator node, object? arg) => new TreeDumperNode("argListOperator", null, new TreeDumperNode[]
        {
            new TreeDumperNode("arguments", null, from x in node.Arguments select Visit(x, null)),
            new TreeDumperNode("argumentRefKindsOpt", node.ArgumentRefKindsOpt, null),
            new TreeDumperNode("type", node.Type, null),
            new TreeDumperNode("isSuppressed", node.IsSuppressed, null),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitFixedLocalCollectionInitializer(LoweredFixedLocalCollectionInitializer node, object? arg) => new TreeDumperNode("fixedLocalCollectionInitializer", null, new TreeDumperNode[]
        {
            new TreeDumperNode("elementPointerType", node.ElementPointerType, null),
            new TreeDumperNode("elementPointerTypeConversion", node.ElementPointerTypeConversion, null),
            new TreeDumperNode("expression", null, new TreeDumperNode[] { Visit(node.Expression, null) }),
            new TreeDumperNode("getPinnableOpt", node.GetPinnableOpt, null),
            new TreeDumperNode("type", node.Type, null),
            new TreeDumperNode("isSuppressed", node.IsSuppressed, null),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitSequencePoint(LoweredSequencePoint node, object? arg) => new TreeDumperNode("sequencePoint", null, new TreeDumperNode[]
        {
            new TreeDumperNode("statementOpt", null, new TreeDumperNode[] { Visit(node.StatementOpt, null) }),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitSequencePointWithSpan(LoweredSequencePointWithSpan node, object? arg) => new TreeDumperNode("sequencePointWithSpan", null, new TreeDumperNode[]
        {
            new TreeDumperNode("statementOpt", null, new TreeDumperNode[] { Visit(node.StatementOpt, null) }),
            new TreeDumperNode("span", node.Span, null),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitBlock(LoweredBlock node, object? arg) => new TreeDumperNode("block", null, new TreeDumperNode[]
        {
            new TreeDumperNode("locals", node.Locals, null),
            new TreeDumperNode("localFunctions", node.LocalFunctions, null),
            new TreeDumperNode("statements", null, from x in node.Statements select Visit(x, null)),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitScope(LoweredScope node, object? arg) => new TreeDumperNode("scope", null, new TreeDumperNode[]
        {
            new TreeDumperNode("locals", node.Locals, null),
            new TreeDumperNode("statements", null, from x in node.Statements select Visit(x, null)),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitStateMachineScope(LoweredStateMachineScope node, object? arg) => new TreeDumperNode("stateMachineScope", null, new TreeDumperNode[]
        {
            new TreeDumperNode("fields", node.Fields, null),
            new TreeDumperNode("statement", null, new TreeDumperNode[] { Visit(node.Statement, null) }),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitLocalDeclaration(LoweredLocalDeclaration node, object? arg) => new TreeDumperNode("localDeclaration", null, new TreeDumperNode[]
        {
            new TreeDumperNode("localSymbol", node.LocalSymbol, null),
            new TreeDumperNode("declaredTypeOpt", null, new TreeDumperNode[] { Visit(node.DeclaredTypeOpt, null) }),
            new TreeDumperNode("initializerOpt", null, new TreeDumperNode[] { Visit(node.InitializerOpt, null) }),
            new TreeDumperNode("argumentsOpt", null, node.ArgumentsOpt.IsDefault ? Array.Empty<TreeDumperNode>() : from x in node.ArgumentsOpt select Visit(x, null)),
            new TreeDumperNode("inferredType", node.InferredType, null),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitMultipleLocalDeclarations(LoweredMultipleLocalDeclarations node, object? arg) => new TreeDumperNode("multipleLocalDeclarations", null, new TreeDumperNode[]
        {
            new TreeDumperNode("localDeclarations", null, from x in node.LocalDeclarations select Visit(x, null)),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitUsingLocalDeclarations(LoweredUsingLocalDeclarations node, object? arg) => new TreeDumperNode("usingLocalDeclarations", null, new TreeDumperNode[]
        {
            new TreeDumperNode("disposeMethodOpt", node.DisposeMethodOpt, null),
            new TreeDumperNode("iDisposableConversion", node.IDisposableConversion, null),
            new TreeDumperNode("awaitOpt", null, new TreeDumperNode[] { Visit(node.AwaitOpt, null) }),
            new TreeDumperNode("localDeclarations", null, from x in node.LocalDeclarations select Visit(x, null)),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitLocalFunctionStatement(LoweredLocalFunctionStatement node, object? arg) => new TreeDumperNode("localFunctionStatement", null, new TreeDumperNode[]
        {
            new TreeDumperNode("symbol", node.Symbol, null),
            new TreeDumperNode("blockBody", null, new TreeDumperNode[] { Visit(node.BlockBody, null) }),
            new TreeDumperNode("expressionBody", null, new TreeDumperNode[] { Visit(node.ExpressionBody, null) }),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitNoOpStatement(LoweredNoOpStatement node, object? arg) => new TreeDumperNode("noOpStatement", null, new TreeDumperNode[]
        {
            new TreeDumperNode("flavor", node.Flavor, null),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitReturnStatement(LoweredReturnStatement node, object? arg) => new TreeDumperNode("returnStatement", null, new TreeDumperNode[]
        {
            new TreeDumperNode("refKind", node.RefKind, null),
            new TreeDumperNode("expressionOpt", null, new TreeDumperNode[] { Visit(node.ExpressionOpt, null) }),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitYieldReturnStatement(LoweredYieldReturnStatement node, object? arg) => new TreeDumperNode("yieldReturnStatement", null, new TreeDumperNode[]
        {
            new TreeDumperNode("expression", null, new TreeDumperNode[] { Visit(node.Expression, null) }),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitYieldBreakStatement(LoweredYieldBreakStatement node, object? arg) => new TreeDumperNode("yieldBreakStatement", null, Array.Empty<TreeDumperNode>()
        );
        public override TreeDumperNode VisitThrowStatement(LoweredThrowStatement node, object? arg) => new TreeDumperNode("throwStatement", null, new TreeDumperNode[]
        {
            new TreeDumperNode("expressionOpt", null, new TreeDumperNode[] { Visit(node.ExpressionOpt, null) }),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitExpressionStatement(LoweredExpressionStatement node, object? arg) => new TreeDumperNode("expressionStatement", null, new TreeDumperNode[]
        {
            new TreeDumperNode("expression", null, new TreeDumperNode[] { Visit(node.Expression, null) }),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitBreakStatement(LoweredBreakStatement node, object? arg) => new TreeDumperNode("breakStatement", null, new TreeDumperNode[]
        {
            new TreeDumperNode("label", node.Label, null),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitContinueStatement(LoweredContinueStatement node, object? arg) => new TreeDumperNode("continueStatement", null, new TreeDumperNode[]
        {
            new TreeDumperNode("label", node.Label, null),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitSwitchStatement(LoweredSwitchStatement node, object? arg) => new TreeDumperNode("switchStatement", null, new TreeDumperNode[]
        {
            new TreeDumperNode("expression", null, new TreeDumperNode[] { Visit(node.Expression, null) }),
            new TreeDumperNode("innerLocals", node.InnerLocals, null),
            new TreeDumperNode("innerLocalFunctions", node.InnerLocalFunctions, null),
            new TreeDumperNode("switchSections", null, from x in node.SwitchSections select Visit(x, null)),
            new TreeDumperNode("decisionDag", null, new TreeDumperNode[] { Visit(node.DecisionDag, null) }),
            new TreeDumperNode("defaultLabel", null, new TreeDumperNode[] { Visit(node.DefaultLabel, null) }),
            new TreeDumperNode("breakLabel", node.BreakLabel, null),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitSwitchDispatch(LoweredSwitchDispatch node, object? arg) => new TreeDumperNode("switchDispatch", null, new TreeDumperNode[]
        {
            new TreeDumperNode("expression", null, new TreeDumperNode[] { Visit(node.Expression, null) }),
            new TreeDumperNode("cases", node.Cases, null),
            new TreeDumperNode("defaultLabel", node.DefaultLabel, null),
            new TreeDumperNode("equalityMethod", node.EqualityMethod, null),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitIfStatement(LoweredIfStatement node, object? arg) => new TreeDumperNode("ifStatement", null, new TreeDumperNode[]
        {
            new TreeDumperNode("condition", null, new TreeDumperNode[] { Visit(node.Condition, null) }),
            new TreeDumperNode("consequence", null, new TreeDumperNode[] { Visit(node.Consequence, null) }),
            new TreeDumperNode("alternativeOpt", null, new TreeDumperNode[] { Visit(node.AlternativeOpt, null) }),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitDoStatement(LoweredDoStatement node, object? arg) => new TreeDumperNode("doStatement", null, new TreeDumperNode[]
        {
            new TreeDumperNode("locals", node.Locals, null),
            new TreeDumperNode("condition", null, new TreeDumperNode[] { Visit(node.Condition, null) }),
            new TreeDumperNode("body", null, new TreeDumperNode[] { Visit(node.Body, null) }),
            new TreeDumperNode("breakLabel", node.BreakLabel, null),
            new TreeDumperNode("continueLabel", node.ContinueLabel, null),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitWhileStatement(LoweredWhileStatement node, object? arg) => new TreeDumperNode("whileStatement", null, new TreeDumperNode[]
        {
            new TreeDumperNode("locals", node.Locals, null),
            new TreeDumperNode("condition", null, new TreeDumperNode[] { Visit(node.Condition, null) }),
            new TreeDumperNode("body", null, new TreeDumperNode[] { Visit(node.Body, null) }),
            new TreeDumperNode("breakLabel", node.BreakLabel, null),
            new TreeDumperNode("continueLabel", node.ContinueLabel, null),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitForStatement(LoweredForStatement node, object? arg) => new TreeDumperNode("forStatement", null, new TreeDumperNode[]
        {
            new TreeDumperNode("outerLocals", node.OuterLocals, null),
            new TreeDumperNode("initializer", null, new TreeDumperNode[] { Visit(node.Initializer, null) }),
            new TreeDumperNode("innerLocals", node.InnerLocals, null),
            new TreeDumperNode("condition", null, new TreeDumperNode[] { Visit(node.Condition, null) }),
            new TreeDumperNode("increment", null, new TreeDumperNode[] { Visit(node.Increment, null) }),
            new TreeDumperNode("body", null, new TreeDumperNode[] { Visit(node.Body, null) }),
            new TreeDumperNode("breakLabel", node.BreakLabel, null),
            new TreeDumperNode("continueLabel", node.ContinueLabel, null),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitForEachStatement(LoweredForEachStatement node, object? arg) => new TreeDumperNode("forEachStatement", null, new TreeDumperNode[]
        {
            new TreeDumperNode("enumeratorInfoOpt", node.EnumeratorInfoOpt, null),
            new TreeDumperNode("elementConversion", node.ElementConversion, null),
            new TreeDumperNode("iterationVariableType", null, new TreeDumperNode[] { Visit(node.IterationVariableType, null) }),
            new TreeDumperNode("iterationVariables", node.IterationVariables, null),
            new TreeDumperNode("iterationErrorExpressionOpt", null, new TreeDumperNode[] { Visit(node.IterationErrorExpressionOpt, null) }),
            new TreeDumperNode("expression", null, new TreeDumperNode[] { Visit(node.Expression, null) }),
            new TreeDumperNode("deconstructionOpt", null, new TreeDumperNode[] { Visit(node.DeconstructionOpt, null) }),
            new TreeDumperNode("awaitOpt", null, new TreeDumperNode[] { Visit(node.AwaitOpt, null) }),
            new TreeDumperNode("body", null, new TreeDumperNode[] { Visit(node.Body, null) }),
            new TreeDumperNode("@checked", node.Checked, null),
            new TreeDumperNode("breakLabel", node.BreakLabel, null),
            new TreeDumperNode("continueLabel", node.ContinueLabel, null),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitForEachDeconstructStep(LoweredForEachDeconstructStep node, object? arg) => new TreeDumperNode("forEachDeconstructStep", null, new TreeDumperNode[]
        {
            new TreeDumperNode("deconstructionAssignment", null, new TreeDumperNode[] { Visit(node.DeconstructionAssignment, null) }),
            new TreeDumperNode("targetPlaceholder", null, new TreeDumperNode[] { Visit(node.TargetPlaceholder, null) }),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitUsingStatement(LoweredUsingStatement node, object? arg) => new TreeDumperNode("usingStatement", null, new TreeDumperNode[]
        {
            new TreeDumperNode("locals", node.Locals, null),
            new TreeDumperNode("declarationsOpt", null, new TreeDumperNode[] { Visit(node.DeclarationsOpt, null) }),
            new TreeDumperNode("expressionOpt", null, new TreeDumperNode[] { Visit(node.ExpressionOpt, null) }),
            new TreeDumperNode("iDisposableConversion", node.IDisposableConversion, null),
            new TreeDumperNode("body", null, new TreeDumperNode[] { Visit(node.Body, null) }),
            new TreeDumperNode("awaitOpt", null, new TreeDumperNode[] { Visit(node.AwaitOpt, null) }),
            new TreeDumperNode("disposeMethodOpt", node.DisposeMethodOpt, null),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitFixedStatement(LoweredFixedStatement node, object? arg) => new TreeDumperNode("fixedStatement", null, new TreeDumperNode[]
        {
            new TreeDumperNode("locals", node.Locals, null),
            new TreeDumperNode("declarations", null, new TreeDumperNode[] { Visit(node.Declarations, null) }),
            new TreeDumperNode("body", null, new TreeDumperNode[] { Visit(node.Body, null) }),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitLockStatement(LoweredLockStatement node, object? arg) => new TreeDumperNode("lockStatement", null, new TreeDumperNode[]
        {
            new TreeDumperNode("argument", null, new TreeDumperNode[] { Visit(node.Argument, null) }),
            new TreeDumperNode("body", null, new TreeDumperNode[] { Visit(node.Body, null) }),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitTryStatement(LoweredTryStatement node, object? arg) => new TreeDumperNode("tryStatement", null, new TreeDumperNode[]
        {
            new TreeDumperNode("tryBlock", null, new TreeDumperNode[] { Visit(node.TryBlock, null) }),
            new TreeDumperNode("catchBlocks", null, from x in node.CatchBlocks select Visit(x, null)),
            new TreeDumperNode("finallyBlockOpt", null, new TreeDumperNode[] { Visit(node.FinallyBlockOpt, null) }),
            new TreeDumperNode("finallyLabelOpt", node.FinallyLabelOpt, null),
            new TreeDumperNode("preferFaultHandler", node.PreferFaultHandler, null),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitCatchBlock(LoweredCatchBlock node, object? arg) => new TreeDumperNode("catchBlock", null, new TreeDumperNode[]
        {
            new TreeDumperNode("locals", node.Locals, null),
            new TreeDumperNode("exceptionSourceOpt", null, new TreeDumperNode[] { Visit(node.ExceptionSourceOpt, null) }),
            new TreeDumperNode("exceptionTypeOpt", node.ExceptionTypeOpt, null),
            new TreeDumperNode("exceptionFilterOpt", null, new TreeDumperNode[] { Visit(node.ExceptionFilterOpt, null) }),
            new TreeDumperNode("body", null, new TreeDumperNode[] { Visit(node.Body, null) }),
            new TreeDumperNode("isSynthesizedAsyncCatchAll", node.IsSynthesizedAsyncCatchAll, null),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitLiteral(LoweredLiteral node, object? arg) => new TreeDumperNode("literal", null, new TreeDumperNode[]
        {
            new TreeDumperNode("constantValueOpt", node.ConstantValueOpt, null),
            new TreeDumperNode("type", node.Type, null),
            new TreeDumperNode("isSuppressed", node.IsSuppressed, null),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitThisReference(LoweredThisReference node, object? arg) => new TreeDumperNode("thisReference", null, new TreeDumperNode[]
        {
            new TreeDumperNode("type", node.Type, null),
            new TreeDumperNode("isSuppressed", node.IsSuppressed, null),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitPreviousSubmissionReference(LoweredPreviousSubmissionReference node, object? arg) => new TreeDumperNode("previousSubmissionReference", null, new TreeDumperNode[]
        {
            new TreeDumperNode("type", node.Type, null),
            new TreeDumperNode("isSuppressed", node.IsSuppressed, null),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitHostObjectMemberReference(LoweredHostObjectMemberReference node, object? arg) => new TreeDumperNode("hostObjectMemberReference", null, new TreeDumperNode[]
        {
            new TreeDumperNode("type", node.Type, null),
            new TreeDumperNode("isSuppressed", node.IsSuppressed, null),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitBaseReference(LoweredBaseReference node, object? arg) => new TreeDumperNode("baseReference", null, new TreeDumperNode[]
        {
            new TreeDumperNode("type", node.Type, null),
            new TreeDumperNode("isSuppressed", node.IsSuppressed, null),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitLocal(LoweredLocal node, object? arg) => new TreeDumperNode("local", null, new TreeDumperNode[]
        {
            new TreeDumperNode("localSymbol", node.LocalSymbol, null),
            new TreeDumperNode("declarationKind", node.DeclarationKind, null),
            new TreeDumperNode("constantValueOpt", node.ConstantValueOpt, null),
            new TreeDumperNode("isNullableUnknown", node.IsNullableUnknown, null),
            new TreeDumperNode("type", node.Type, null),
            new TreeDumperNode("isSuppressed", node.IsSuppressed, null),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitPseudoVariable(LoweredPseudoVariable node, object? arg) => new TreeDumperNode("pseudoVariable", null, new TreeDumperNode[]
        {
            new TreeDumperNode("localSymbol", node.LocalSymbol, null),
            new TreeDumperNode("emitExpressions", node.EmitExpressions, null),
            new TreeDumperNode("type", node.Type, null),
            new TreeDumperNode("isSuppressed", node.IsSuppressed, null),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitRangeVariable(LoweredRangeVariable node, object? arg) => new TreeDumperNode("rangeVariable", null, new TreeDumperNode[]
        {
            new TreeDumperNode("rangeVariableSymbol", node.RangeVariableSymbol, null),
            new TreeDumperNode("value", null, new TreeDumperNode[] { Visit(node.Value, null) }),
            new TreeDumperNode("type", node.Type, null),
            new TreeDumperNode("isSuppressed", node.IsSuppressed, null),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitParameter(LoweredParameter node, object? arg) => new TreeDumperNode("parameter", null, new TreeDumperNode[]
        {
            new TreeDumperNode("parameterSymbol", node.ParameterSymbol, null),
            new TreeDumperNode("type", node.Type, null),
            new TreeDumperNode("isSuppressed", node.IsSuppressed, null),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitLabelStatement(LoweredLabelStatement node, object? arg) => new TreeDumperNode("labelStatement", null, new TreeDumperNode[]
        {
            new TreeDumperNode("label", node.Label, null),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitGotoStatement(LoweredGotoStatement node, object? arg) => new TreeDumperNode("gotoStatement", null, new TreeDumperNode[]
        {
            new TreeDumperNode("label", node.Label, null),
            new TreeDumperNode("caseExpressionOpt", null, new TreeDumperNode[] { Visit(node.CaseExpressionOpt, null) }),
            new TreeDumperNode("labelExpressionOpt", null, new TreeDumperNode[] { Visit(node.LabelExpressionOpt, null) }),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitLabeledStatement(LoweredLabeledStatement node, object? arg) => new TreeDumperNode("labeledStatement", null, new TreeDumperNode[]
        {
            new TreeDumperNode("label", node.Label, null),
            new TreeDumperNode("body", null, new TreeDumperNode[] { Visit(node.Body, null) }),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitLabel(LoweredLabel node, object? arg) => new TreeDumperNode("label", null, new TreeDumperNode[]
        {
            new TreeDumperNode("label", node.Label, null),
            new TreeDumperNode("type", node.Type, null),
            new TreeDumperNode("isSuppressed", node.IsSuppressed, null),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitStatementList(LoweredStatementList node, object? arg) => new TreeDumperNode("statementList", null, new TreeDumperNode[]
        {
            new TreeDumperNode("statements", null, from x in node.Statements select Visit(x, null)),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitConditionalGoto(LoweredConditionalGoto node, object? arg) => new TreeDumperNode("conditionalGoto", null, new TreeDumperNode[]
        {
            new TreeDumperNode("condition", null, new TreeDumperNode[] { Visit(node.Condition, null) }),
            new TreeDumperNode("jumpIfTrue", node.JumpIfTrue, null),
            new TreeDumperNode("label", node.Label, null),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitSwitchExpressionArm(LoweredSwitchExpressionArm node, object? arg) => new TreeDumperNode("switchExpressionArm", null, new TreeDumperNode[]
        {
            new TreeDumperNode("locals", node.Locals, null),
            new TreeDumperNode("pattern", null, new TreeDumperNode[] { Visit(node.Pattern, null) }),
            new TreeDumperNode("whenClause", null, new TreeDumperNode[] { Visit(node.WhenClause, null) }),
            new TreeDumperNode("value", null, new TreeDumperNode[] { Visit(node.Value, null) }),
            new TreeDumperNode("label", node.Label, null),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitUnconvertedSwitchExpression(LoweredUnconvertedSwitchExpression node, object? arg) => new TreeDumperNode("unconvertedSwitchExpression", null, new TreeDumperNode[]
        {
            new TreeDumperNode("expression", null, new TreeDumperNode[] { Visit(node.Expression, null) }),
            new TreeDumperNode("switchArms", null, from x in node.SwitchArms select Visit(x, null)),
            new TreeDumperNode("decisionDag", null, new TreeDumperNode[] { Visit(node.DecisionDag, null) }),
            new TreeDumperNode("defaultLabel", node.DefaultLabel, null),
            new TreeDumperNode("reportedNotExhaustive", node.ReportedNotExhaustive, null),
            new TreeDumperNode("type", node.Type, null),
            new TreeDumperNode("isSuppressed", node.IsSuppressed, null),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitConvertedSwitchExpression(LoweredConvertedSwitchExpression node, object? arg) => new TreeDumperNode("convertedSwitchExpression", null, new TreeDumperNode[]
        {
            new TreeDumperNode("naturalTypeOpt", node.NaturalTypeOpt, null),
            new TreeDumperNode("wasTargetTyped", node.WasTargetTyped, null),
            new TreeDumperNode("expression", null, new TreeDumperNode[] { Visit(node.Expression, null) }),
            new TreeDumperNode("switchArms", null, from x in node.SwitchArms select Visit(x, null)),
            new TreeDumperNode("decisionDag", null, new TreeDumperNode[] { Visit(node.DecisionDag, null) }),
            new TreeDumperNode("defaultLabel", node.DefaultLabel, null),
            new TreeDumperNode("reportedNotExhaustive", node.ReportedNotExhaustive, null),
            new TreeDumperNode("type", node.Type, null),
            new TreeDumperNode("isSuppressed", node.IsSuppressed, null),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitDecisionDag(LoweredDecisionDag node, object? arg) => new TreeDumperNode("decisionDag", null, new TreeDumperNode[]
        {
            new TreeDumperNode("rootNode", node.RootNode, null),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitEvaluationDecisionDagNode(LoweredEvaluationDecisionDagNode node, object? arg) => new TreeDumperNode("evaluationDecisionDagNode", null, new TreeDumperNode[]
        {
            new TreeDumperNode("evaluation", null, new TreeDumperNode[] { Visit(node.Evaluation, null) }),
            new TreeDumperNode("next", null, new TreeDumperNode[] { Visit(node.Next, null) }),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitTestDecisionDagNode(LoweredTestDecisionDagNode node, object? arg) => new TreeDumperNode("testDecisionDagNode", null, new TreeDumperNode[]
        {
            new TreeDumperNode("test", null, new TreeDumperNode[] { Visit(node.Test, null) }),
            new TreeDumperNode("whenTrue", null, new TreeDumperNode[] { Visit(node.WhenTrue, null) }),
            new TreeDumperNode("whenFalse", null, new TreeDumperNode[] { Visit(node.WhenFalse, null) }),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitWhenDecisionDagNode(LoweredWhenDecisionDagNode node, object? arg) => new TreeDumperNode("whenDecisionDagNode", null, new TreeDumperNode[]
        {
            new TreeDumperNode("bindings", node.Bindings, null),
            new TreeDumperNode("whenExpression", null, new TreeDumperNode[] { Visit(node.WhenExpression, null) }),
            new TreeDumperNode("whenTrue", null, new TreeDumperNode[] { Visit(node.WhenTrue, null) }),
            new TreeDumperNode("whenFalse", null, new TreeDumperNode[] { Visit(node.WhenFalse, null) }),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitLeafDecisionDagNode(LoweredLeafDecisionDagNode node, object? arg) => new TreeDumperNode("leafDecisionDagNode", null, new TreeDumperNode[]
        {
            new TreeDumperNode("label", node.Label, null),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitDagTemp(LoweredDagTemp node, object? arg) => new TreeDumperNode("dagTemp", null, new TreeDumperNode[]
        {
            new TreeDumperNode("type", node.Type, null),
            new TreeDumperNode("source", null, new TreeDumperNode[] { Visit(node.Source, null) }),
            new TreeDumperNode("index", node.Index, null),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitDagTypeTest(LoweredDagTypeTest node, object? arg) => new TreeDumperNode("dagTypeTest", null, new TreeDumperNode[]
        {
            new TreeDumperNode("type", node.Type, null),
            new TreeDumperNode("input", null, new TreeDumperNode[] { Visit(node.Input, null) }),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitDagNonNullTest(LoweredDagNonNullTest node, object? arg) => new TreeDumperNode("dagNonNullTest", null, new TreeDumperNode[]
        {
            new TreeDumperNode("isExplicitTest", node.IsExplicitTest, null),
            new TreeDumperNode("input", null, new TreeDumperNode[] { Visit(node.Input, null) }),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitDagExplicitNullTest(LoweredDagExplicitNullTest node, object? arg) => new TreeDumperNode("dagExplicitNullTest", null, new TreeDumperNode[]
        {
            new TreeDumperNode("input", null, new TreeDumperNode[] { Visit(node.Input, null) }),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitDagValueTest(LoweredDagValueTest node, object? arg) => new TreeDumperNode("dagValueTest", null, new TreeDumperNode[]
        {
            new TreeDumperNode("value", node.Value, null),
            new TreeDumperNode("input", null, new TreeDumperNode[] { Visit(node.Input, null) }),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitDagDeconstructEvaluation(LoweredDagDeconstructEvaluation node, object? arg) => new TreeDumperNode("dagDeconstructEvaluation", null, new TreeDumperNode[]
        {
            new TreeDumperNode("deconstructMethod", node.DeconstructMethod, null),
            new TreeDumperNode("input", null, new TreeDumperNode[] { Visit(node.Input, null) }),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitDagTypeEvaluation(LoweredDagTypeEvaluation node, object? arg) => new TreeDumperNode("dagTypeEvaluation", null, new TreeDumperNode[]
        {
            new TreeDumperNode("type", node.Type, null),
            new TreeDumperNode("input", null, new TreeDumperNode[] { Visit(node.Input, null) }),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitDagFieldEvaluation(LoweredDagFieldEvaluation node, object? arg) => new TreeDumperNode("dagFieldEvaluation", null, new TreeDumperNode[]
        {
            new TreeDumperNode("field", node.Field, null),
            new TreeDumperNode("input", null, new TreeDumperNode[] { Visit(node.Input, null) }),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitDagPropertyEvaluation(LoweredDagPropertyEvaluation node, object? arg) => new TreeDumperNode("dagPropertyEvaluation", null, new TreeDumperNode[]
        {
            new TreeDumperNode("property", node.Property, null),
            new TreeDumperNode("input", null, new TreeDumperNode[] { Visit(node.Input, null) }),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitDagIndexEvaluation(LoweredDagIndexEvaluation node, object? arg) => new TreeDumperNode("dagIndexEvaluation", null, new TreeDumperNode[]
        {
            new TreeDumperNode("property", node.Property, null),
            new TreeDumperNode("index", node.Index, null),
            new TreeDumperNode("input", null, new TreeDumperNode[] { Visit(node.Input, null) }),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitSwitchSection(LoweredSwitchSection node, object? arg) => new TreeDumperNode("switchSection", null, new TreeDumperNode[]
        {
            new TreeDumperNode("locals", node.Locals, null),
            new TreeDumperNode("switchLabels", null, from x in node.SwitchLabels select Visit(x, null)),
            new TreeDumperNode("statements", null, from x in node.Statements select Visit(x, null)),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitSwitchLabel(LoweredSwitchLabel node, object? arg) => new TreeDumperNode("switchLabel", null, new TreeDumperNode[]
        {
            new TreeDumperNode("label", node.Label, null),
            new TreeDumperNode("pattern", null, new TreeDumperNode[] { Visit(node.Pattern, null) }),
            new TreeDumperNode("whenClause", null, new TreeDumperNode[] { Visit(node.WhenClause, null) }),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitSequencePointExpression(LoweredSequencePointExpression node, object? arg) => new TreeDumperNode("sequencePointExpression", null, new TreeDumperNode[]
        {
            new TreeDumperNode("expression", null, new TreeDumperNode[] { Visit(node.Expression, null) }),
            new TreeDumperNode("type", node.Type, null),
            new TreeDumperNode("isSuppressed", node.IsSuppressed, null),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitSequence(LoweredSequence node, object? arg) => new TreeDumperNode("sequence", null, new TreeDumperNode[]
        {
            new TreeDumperNode("locals", node.Locals, null),
            new TreeDumperNode("sideEffects", null, from x in node.SideEffects select Visit(x, null)),
            new TreeDumperNode("value", null, new TreeDumperNode[] { Visit(node.Value, null) }),
            new TreeDumperNode("type", node.Type, null),
            new TreeDumperNode("isSuppressed", node.IsSuppressed, null),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitSpillSequence(LoweredSpillSequence node, object? arg) => new TreeDumperNode("spillSequence", null, new TreeDumperNode[]
        {
            new TreeDumperNode("locals", node.Locals, null),
            new TreeDumperNode("sideEffects", null, from x in node.SideEffects select Visit(x, null)),
            new TreeDumperNode("value", null, new TreeDumperNode[] { Visit(node.Value, null) }),
            new TreeDumperNode("type", node.Type, null),
            new TreeDumperNode("isSuppressed", node.IsSuppressed, null),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitDynamicMemberAccess(LoweredDynamicMemberAccess node, object? arg) => new TreeDumperNode("dynamicMemberAccess", null, new TreeDumperNode[]
        {
            new TreeDumperNode("receiver", null, new TreeDumperNode[] { Visit(node.Receiver, null) }),
            new TreeDumperNode("typeArgumentsOpt", node.TypeArgumentsOpt, null),
            new TreeDumperNode("name", node.Name, null),
            new TreeDumperNode("invoked", node.Invoked, null),
            new TreeDumperNode("indexed", node.Indexed, null),
            new TreeDumperNode("type", node.Type, null),
            new TreeDumperNode("isSuppressed", node.IsSuppressed, null),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitDynamicInvocation(LoweredDynamicInvocation node, object? arg) => new TreeDumperNode("dynamicInvocation", null, new TreeDumperNode[]
        {
            new TreeDumperNode("argumentNamesOpt", node.ArgumentNamesOpt, null),
            new TreeDumperNode("argumentRefKindsOpt", node.ArgumentRefKindsOpt, null),
            new TreeDumperNode("applicableMethods", node.ApplicableMethods, null),
            new TreeDumperNode("expression", null, new TreeDumperNode[] { Visit(node.Expression, null) }),
            new TreeDumperNode("arguments", null, from x in node.Arguments select Visit(x, null)),
            new TreeDumperNode("type", node.Type, null),
            new TreeDumperNode("isSuppressed", node.IsSuppressed, null),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitConditionalAccess(LoweredConditionalAccess node, object? arg) => new TreeDumperNode("conditionalAccess", null, new TreeDumperNode[]
        {
            new TreeDumperNode("receiver", null, new TreeDumperNode[] { Visit(node.Receiver, null) }),
            new TreeDumperNode("accessExpression", null, new TreeDumperNode[] { Visit(node.AccessExpression, null) }),
            new TreeDumperNode("type", node.Type, null),
            new TreeDumperNode("isSuppressed", node.IsSuppressed, null),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitLoweredConditionalAccess(LoweredLoweredConditionalAccess node, object? arg) => new TreeDumperNode("loweredConditionalAccess", null, new TreeDumperNode[]
        {
            new TreeDumperNode("receiver", null, new TreeDumperNode[] { Visit(node.Receiver, null) }),
            new TreeDumperNode("hasValueMethodOpt", node.HasValueMethodOpt, null),
            new TreeDumperNode("whenNotNull", null, new TreeDumperNode[] { Visit(node.WhenNotNull, null) }),
            new TreeDumperNode("whenNullOpt", null, new TreeDumperNode[] { Visit(node.WhenNullOpt, null) }),
            new TreeDumperNode("id", node.Id, null),
            new TreeDumperNode("type", node.Type, null),
            new TreeDumperNode("isSuppressed", node.IsSuppressed, null),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitConditionalReceiver(LoweredConditionalReceiver node, object? arg) => new TreeDumperNode("conditionalReceiver", null, new TreeDumperNode[]
        {
            new TreeDumperNode("id", node.Id, null),
            new TreeDumperNode("type", node.Type, null),
            new TreeDumperNode("isSuppressed", node.IsSuppressed, null),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitComplexConditionalReceiver(LoweredComplexConditionalReceiver node, object? arg) => new TreeDumperNode("complexConditionalReceiver", null, new TreeDumperNode[]
        {
            new TreeDumperNode("valueTypeReceiver", null, new TreeDumperNode[] { Visit(node.ValueTypeReceiver, null) }),
            new TreeDumperNode("referenceTypeReceiver", null, new TreeDumperNode[] { Visit(node.ReferenceTypeReceiver, null) }),
            new TreeDumperNode("type", node.Type, null),
            new TreeDumperNode("isSuppressed", node.IsSuppressed, null),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitMethodGroup(LoweredMethodGroup node, object? arg) => new TreeDumperNode("methodGroup", null, new TreeDumperNode[]
        {
            new TreeDumperNode("typeArgumentsOpt", node.TypeArgumentsOpt, null),
            new TreeDumperNode("name", node.Name, null),
            new TreeDumperNode("methods", node.Methods, null),
            new TreeDumperNode("lookupSymbolOpt", node.LookupSymbolOpt, null),
            new TreeDumperNode("lookupError", node.LookupError, null),
            new TreeDumperNode("flags", node.Flags, null),
            new TreeDumperNode("receiverOpt", null, new TreeDumperNode[] { Visit(node.ReceiverOpt, null) }),
            new TreeDumperNode("resultKind", node.ResultKind, null),
            new TreeDumperNode("type", node.Type, null),
            new TreeDumperNode("isSuppressed", node.IsSuppressed, null),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitPropertyGroup(LoweredPropertyGroup node, object? arg) => new TreeDumperNode("propertyGroup", null, new TreeDumperNode[]
        {
            new TreeDumperNode("properties", node.Properties, null),
            new TreeDumperNode("receiverOpt", null, new TreeDumperNode[] { Visit(node.ReceiverOpt, null) }),
            new TreeDumperNode("resultKind", node.ResultKind, null),
            new TreeDumperNode("type", node.Type, null),
            new TreeDumperNode("isSuppressed", node.IsSuppressed, null),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitCall(LoweredCall node, object? arg) => new TreeDumperNode("call", null, new TreeDumperNode[]
        {
            new TreeDumperNode("receiverOpt", null, new TreeDumperNode[] { Visit(node.ReceiverOpt, null) }),
            new TreeDumperNode("method", node.Method, null),
            new TreeDumperNode("arguments", null, from x in node.Arguments select Visit(x, null)),
            new TreeDumperNode("argumentNamesOpt", node.ArgumentNamesOpt, null),
            new TreeDumperNode("argumentRefKindsOpt", node.ArgumentRefKindsOpt, null),
            new TreeDumperNode("isDelegateCall", node.IsDelegateCall, null),
            new TreeDumperNode("expanded", node.Expanded, null),
            new TreeDumperNode("invokedAsExtensionMethod", node.InvokedAsExtensionMethod, null),
            new TreeDumperNode("argsToParamsOpt", node.ArgsToParamsOpt, null),
            new TreeDumperNode("resultKind", node.ResultKind, null),
            new TreeDumperNode("originalMethodsOpt", node.OriginalMethodsOpt, null),
            new TreeDumperNode("binderOpt", node.BinderOpt, null),
            new TreeDumperNode("type", node.Type, null),
            new TreeDumperNode("isSuppressed", node.IsSuppressed, null),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitEventAssignmentOperator(LoweredEventAssignmentOperator node, object? arg) => new TreeDumperNode("eventAssignmentOperator", null, new TreeDumperNode[]
        {
            new TreeDumperNode("@event", node.Event, null),
            new TreeDumperNode("isAddition", node.IsAddition, null),
            new TreeDumperNode("isDynamic", node.IsDynamic, null),
            new TreeDumperNode("receiverOpt", null, new TreeDumperNode[] { Visit(node.ReceiverOpt, null) }),
            new TreeDumperNode("argument", null, new TreeDumperNode[] { Visit(node.Argument, null) }),
            new TreeDumperNode("type", node.Type, null),
            new TreeDumperNode("isSuppressed", node.IsSuppressed, null),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitAttribute(LoweredAttribute node, object? arg) => new TreeDumperNode("attribute", null, new TreeDumperNode[]
        {
            new TreeDumperNode("constructor", node.Constructor, null),
            new TreeDumperNode("constructorArguments", null, from x in node.ConstructorArguments select Visit(x, null)),
            new TreeDumperNode("constructorArgumentNamesOpt", node.ConstructorArgumentNamesOpt, null),
            new TreeDumperNode("constructorArgumentsToParamsOpt", node.ConstructorArgumentsToParamsOpt, null),
            new TreeDumperNode("constructorExpanded", node.ConstructorExpanded, null),
            new TreeDumperNode("namedArguments", null, from x in node.NamedArguments select Visit(x, null)),
            new TreeDumperNode("resultKind", node.ResultKind, null),
            new TreeDumperNode("type", node.Type, null),
            new TreeDumperNode("isSuppressed", node.IsSuppressed, null),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitObjectCreationExpression(LoweredObjectCreationExpression node, object? arg) => new TreeDumperNode("objectCreationExpression", null, new TreeDumperNode[]
        {
            new TreeDumperNode("constructor", node.Constructor, null),
            new TreeDumperNode("constructorsGroup", node.ConstructorsGroup, null),
            new TreeDumperNode("arguments", null, from x in node.Arguments select Visit(x, null)),
            new TreeDumperNode("argumentNamesOpt", node.ArgumentNamesOpt, null),
            new TreeDumperNode("argumentRefKindsOpt", node.ArgumentRefKindsOpt, null),
            new TreeDumperNode("expanded", node.Expanded, null),
            new TreeDumperNode("argsToParamsOpt", node.ArgsToParamsOpt, null),
            new TreeDumperNode("constantValueOpt", node.ConstantValueOpt, null),
            new TreeDumperNode("initializerExpressionOpt", null, new TreeDumperNode[] { Visit(node.InitializerExpressionOpt, null) }),
            new TreeDumperNode("binderOpt", node.BinderOpt, null),
            new TreeDumperNode("type", node.Type, null),
            new TreeDumperNode("isSuppressed", node.IsSuppressed, null),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitTupleLiteral(LoweredTupleLiteral node, object? arg) => new TreeDumperNode("tupleLiteral", null, new TreeDumperNode[]
        {
            new TreeDumperNode("arguments", null, from x in node.Arguments select Visit(x, null)),
            new TreeDumperNode("argumentNamesOpt", node.ArgumentNamesOpt, null),
            new TreeDumperNode("inferredNamesOpt", node.InferredNamesOpt, null),
            new TreeDumperNode("type", node.Type, null),
            new TreeDumperNode("isSuppressed", node.IsSuppressed, null),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitConvertedTupleLiteral(LoweredConvertedTupleLiteral node, object? arg) => new TreeDumperNode("convertedTupleLiteral", null, new TreeDumperNode[]
        {
            new TreeDumperNode("sourceTuple", null, new TreeDumperNode[] { Visit(node.SourceTuple, null) }),
            new TreeDumperNode("wasTargetTyped", node.WasTargetTyped, null),
            new TreeDumperNode("arguments", null, from x in node.Arguments select Visit(x, null)),
            new TreeDumperNode("argumentNamesOpt", node.ArgumentNamesOpt, null),
            new TreeDumperNode("inferredNamesOpt", node.InferredNamesOpt, null),
            new TreeDumperNode("type", node.Type, null),
            new TreeDumperNode("isSuppressed", node.IsSuppressed, null),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitDynamicObjectCreationExpression(LoweredDynamicObjectCreationExpression node, object? arg) => new TreeDumperNode("dynamicObjectCreationExpression", null, new TreeDumperNode[]
        {
            new TreeDumperNode("name", node.Name, null),
            new TreeDumperNode("arguments", null, from x in node.Arguments select Visit(x, null)),
            new TreeDumperNode("argumentNamesOpt", node.ArgumentNamesOpt, null),
            new TreeDumperNode("argumentRefKindsOpt", node.ArgumentRefKindsOpt, null),
            new TreeDumperNode("initializerExpressionOpt", null, new TreeDumperNode[] { Visit(node.InitializerExpressionOpt, null) }),
            new TreeDumperNode("applicableMethods", node.ApplicableMethods, null),
            new TreeDumperNode("type", node.Type, null),
            new TreeDumperNode("isSuppressed", node.IsSuppressed, null),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitNoPiaObjectCreationExpression(LoweredNoPiaObjectCreationExpression node, object? arg) => new TreeDumperNode("noPiaObjectCreationExpression", null, new TreeDumperNode[]
        {
            new TreeDumperNode("guidString", node.GuidString, null),
            new TreeDumperNode("initializerExpressionOpt", null, new TreeDumperNode[] { Visit(node.InitializerExpressionOpt, null) }),
            new TreeDumperNode("type", node.Type, null),
            new TreeDumperNode("isSuppressed", node.IsSuppressed, null),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitObjectInitializerExpression(LoweredObjectInitializerExpression node, object? arg) => new TreeDumperNode("objectInitializerExpression", null, new TreeDumperNode[]
        {
            new TreeDumperNode("placeholder", null, new TreeDumperNode[] { Visit(node.Placeholder, null) }),
            new TreeDumperNode("initializers", null, from x in node.Initializers select Visit(x, null)),
            new TreeDumperNode("type", node.Type, null),
            new TreeDumperNode("isSuppressed", node.IsSuppressed, null),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitObjectInitializerMember(LoweredObjectInitializerMember node, object? arg) => new TreeDumperNode("objectInitializerMember", null, new TreeDumperNode[]
        {
            new TreeDumperNode("memberSymbol", node.MemberSymbol, null),
            new TreeDumperNode("arguments", null, from x in node.Arguments select Visit(x, null)),
            new TreeDumperNode("argumentNamesOpt", node.ArgumentNamesOpt, null),
            new TreeDumperNode("argumentRefKindsOpt", node.ArgumentRefKindsOpt, null),
            new TreeDumperNode("expanded", node.Expanded, null),
            new TreeDumperNode("argsToParamsOpt", node.ArgsToParamsOpt, null),
            new TreeDumperNode("resultKind", node.ResultKind, null),
            new TreeDumperNode("receiverType", node.ReceiverType, null),
            new TreeDumperNode("binderOpt", node.BinderOpt, null),
            new TreeDumperNode("type", node.Type, null),
            new TreeDumperNode("isSuppressed", node.IsSuppressed, null),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitDynamicObjectInitializerMember(LoweredDynamicObjectInitializerMember node, object? arg) => new TreeDumperNode("dynamicObjectInitializerMember", null, new TreeDumperNode[]
        {
            new TreeDumperNode("memberName", node.MemberName, null),
            new TreeDumperNode("receiverType", node.ReceiverType, null),
            new TreeDumperNode("type", node.Type, null),
            new TreeDumperNode("isSuppressed", node.IsSuppressed, null),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitCollectionInitializerExpression(LoweredCollectionInitializerExpression node, object? arg) => new TreeDumperNode("collectionInitializerExpression", null, new TreeDumperNode[]
        {
            new TreeDumperNode("placeholder", null, new TreeDumperNode[] { Visit(node.Placeholder, null) }),
            new TreeDumperNode("initializers", null, from x in node.Initializers select Visit(x, null)),
            new TreeDumperNode("type", node.Type, null),
            new TreeDumperNode("isSuppressed", node.IsSuppressed, null),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitCollectionElementInitializer(LoweredCollectionElementInitializer node, object? arg) => new TreeDumperNode("collectionElementInitializer", null, new TreeDumperNode[]
        {
            new TreeDumperNode("addMethod", node.AddMethod, null),
            new TreeDumperNode("arguments", null, from x in node.Arguments select Visit(x, null)),
            new TreeDumperNode("implicitReceiverOpt", null, new TreeDumperNode[] { Visit(node.ImplicitReceiverOpt, null) }),
            new TreeDumperNode("expanded", node.Expanded, null),
            new TreeDumperNode("argsToParamsOpt", node.ArgsToParamsOpt, null),
            new TreeDumperNode("invokedAsExtensionMethod", node.InvokedAsExtensionMethod, null),
            new TreeDumperNode("resultKind", node.ResultKind, null),
            new TreeDumperNode("binderOpt", node.BinderOpt, null),
            new TreeDumperNode("type", node.Type, null),
            new TreeDumperNode("isSuppressed", node.IsSuppressed, null),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitDynamicCollectionElementInitializer(LoweredDynamicCollectionElementInitializer node, object? arg) => new TreeDumperNode("dynamicCollectionElementInitializer", null, new TreeDumperNode[]
        {
            new TreeDumperNode("applicableMethods", node.ApplicableMethods, null),
            new TreeDumperNode("expression", null, new TreeDumperNode[] { Visit(node.Expression, null) }),
            new TreeDumperNode("arguments", null, from x in node.Arguments select Visit(x, null)),
            new TreeDumperNode("type", node.Type, null),
            new TreeDumperNode("isSuppressed", node.IsSuppressed, null),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitImplicitReceiver(LoweredImplicitReceiver node, object? arg) => new TreeDumperNode("implicitReceiver", null, new TreeDumperNode[]
        {
            new TreeDumperNode("type", node.Type, null),
            new TreeDumperNode("isSuppressed", node.IsSuppressed, null),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitAnonymousObjectCreationExpression(LoweredAnonymousObjectCreationExpression node, object? arg) => new TreeDumperNode("anonymousObjectCreationExpression", null, new TreeDumperNode[]
        {
            new TreeDumperNode("constructor", node.Constructor, null),
            new TreeDumperNode("arguments", null, from x in node.Arguments select Visit(x, null)),
            new TreeDumperNode("declarations", null, from x in node.Declarations select Visit(x, null)),
            new TreeDumperNode("type", node.Type, null),
            new TreeDumperNode("isSuppressed", node.IsSuppressed, null),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitAnonymousPropertyDeclaration(LoweredAnonymousPropertyDeclaration node, object? arg) => new TreeDumperNode("anonymousPropertyDeclaration", null, new TreeDumperNode[]
        {
            new TreeDumperNode("property", node.Property, null),
            new TreeDumperNode("type", node.Type, null),
            new TreeDumperNode("isSuppressed", node.IsSuppressed, null),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitNewT(LoweredNewT node, object? arg) => new TreeDumperNode("newT", null, new TreeDumperNode[]
        {
            new TreeDumperNode("initializerExpressionOpt", null, new TreeDumperNode[] { Visit(node.InitializerExpressionOpt, null) }),
            new TreeDumperNode("type", node.Type, null),
            new TreeDumperNode("isSuppressed", node.IsSuppressed, null),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitDelegateCreationExpression(LoweredDelegateCreationExpression node, object? arg) => new TreeDumperNode("delegateCreationExpression", null, new TreeDumperNode[]
        {
            new TreeDumperNode("argument", null, new TreeDumperNode[] { Visit(node.Argument, null) }),
            new TreeDumperNode("methodOpt", node.MethodOpt, null),
            new TreeDumperNode("isExtensionMethod", node.IsExtensionMethod, null),
            new TreeDumperNode("type", node.Type, null),
            new TreeDumperNode("isSuppressed", node.IsSuppressed, null),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitArrayCreation(LoweredArrayCreation node, object? arg) => new TreeDumperNode("arrayCreation", null, new TreeDumperNode[]
        {
            new TreeDumperNode("bounds", null, from x in node.Lowereds select Visit(x, null)),
            new TreeDumperNode("initializerOpt", null, new TreeDumperNode[] { Visit(node.InitializerOpt, null) }),
            new TreeDumperNode("type", node.Type, null),
            new TreeDumperNode("isSuppressed", node.IsSuppressed, null),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitArrayInitialization(LoweredArrayInitialization node, object? arg) => new TreeDumperNode("arrayInitialization", null, new TreeDumperNode[]
        {
            new TreeDumperNode("initializers", null, from x in node.Initializers select Visit(x, null)),
            new TreeDumperNode("type", node.Type, null),
            new TreeDumperNode("isSuppressed", node.IsSuppressed, null),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitStackAllocArrayCreation(LoweredStackAllocArrayCreation node, object? arg) => new TreeDumperNode("stackAllocArrayCreation", null, new TreeDumperNode[]
        {
            new TreeDumperNode("elementType", node.ElementType, null),
            new TreeDumperNode("count", null, new TreeDumperNode[] { Visit(node.Count, null) }),
            new TreeDumperNode("initializerOpt", null, new TreeDumperNode[] { Visit(node.InitializerOpt, null) }),
            new TreeDumperNode("type", node.Type, null),
            new TreeDumperNode("isSuppressed", node.IsSuppressed, null),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitConvertedStackAllocExpression(LoweredConvertedStackAllocExpression node, object? arg) => new TreeDumperNode("convertedStackAllocExpression", null, new TreeDumperNode[]
        {
            new TreeDumperNode("elementType", node.ElementType, null),
            new TreeDumperNode("count", null, new TreeDumperNode[] { Visit(node.Count, null) }),
            new TreeDumperNode("initializerOpt", null, new TreeDumperNode[] { Visit(node.InitializerOpt, null) }),
            new TreeDumperNode("type", node.Type, null),
            new TreeDumperNode("isSuppressed", node.IsSuppressed, null),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitFieldAccess(LoweredFieldAccess node, object? arg) => new TreeDumperNode("fieldAccess", null, new TreeDumperNode[]
        {
            new TreeDumperNode("receiverOpt", null, new TreeDumperNode[] { Visit(node.ReceiverOpt, null) }),
            new TreeDumperNode("fieldSymbol", node.FieldSymbol, null),
            new TreeDumperNode("constantValueOpt", node.ConstantValueOpt, null),
            new TreeDumperNode("resultKind", node.ResultKind, null),
            new TreeDumperNode("isByValue", node.IsByValue, null),
            new TreeDumperNode("isDeclaration", node.IsDeclaration, null),
            new TreeDumperNode("type", node.Type, null),
            new TreeDumperNode("isSuppressed", node.IsSuppressed, null),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitHoistedFieldAccess(LoweredHoistedFieldAccess node, object? arg) => new TreeDumperNode("hoistedFieldAccess", null, new TreeDumperNode[]
        {
            new TreeDumperNode("fieldSymbol", node.FieldSymbol, null),
            new TreeDumperNode("type", node.Type, null),
            new TreeDumperNode("isSuppressed", node.IsSuppressed, null),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitPropertyAccess(LoweredPropertyAccess node, object? arg) => new TreeDumperNode("propertyAccess", null, new TreeDumperNode[]
        {
            new TreeDumperNode("receiverOpt", null, new TreeDumperNode[] { Visit(node.ReceiverOpt, null) }),
            new TreeDumperNode("propertySymbol", node.PropertySymbol, null),
            new TreeDumperNode("resultKind", node.ResultKind, null),
            new TreeDumperNode("type", node.Type, null),
            new TreeDumperNode("isSuppressed", node.IsSuppressed, null),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitEventAccess(LoweredEventAccess node, object? arg) => new TreeDumperNode("eventAccess", null, new TreeDumperNode[]
        {
            new TreeDumperNode("receiverOpt", null, new TreeDumperNode[] { Visit(node.ReceiverOpt, null) }),
            new TreeDumperNode("eventSymbol", node.EventSymbol, null),
            new TreeDumperNode("isUsableAsField", node.IsUsableAsField, null),
            new TreeDumperNode("resultKind", node.ResultKind, null),
            new TreeDumperNode("type", node.Type, null),
            new TreeDumperNode("isSuppressed", node.IsSuppressed, null),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitIndexerAccess(LoweredIndexerAccess node, object? arg) => new TreeDumperNode("indexerAccess", null, new TreeDumperNode[]
        {
            new TreeDumperNode("receiverOpt", null, new TreeDumperNode[] { Visit(node.ReceiverOpt, null) }),
            new TreeDumperNode("indexer", node.Indexer, null),
            new TreeDumperNode("arguments", null, from x in node.Arguments select Visit(x, null)),
            new TreeDumperNode("argumentNamesOpt", node.ArgumentNamesOpt, null),
            new TreeDumperNode("argumentRefKindsOpt", node.ArgumentRefKindsOpt, null),
            new TreeDumperNode("expanded", node.Expanded, null),
            new TreeDumperNode("argsToParamsOpt", node.ArgsToParamsOpt, null),
            new TreeDumperNode("binderOpt", node.BinderOpt, null),
            new TreeDumperNode("useSetterForDefaultArgumentGeneration", node.UseSetterForDefaultArgumentGeneration, null),
            new TreeDumperNode("originalIndexersOpt", node.OriginalIndexersOpt, null),
            new TreeDumperNode("type", node.Type, null),
            new TreeDumperNode("isSuppressed", node.IsSuppressed, null),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitIndexOrRangePatternIndexerAccess(LoweredIndexOrRangePatternIndexerAccess node, object? arg) => new TreeDumperNode("indexOrRangePatternIndexerAccess", null, new TreeDumperNode[]
        {
            new TreeDumperNode("receiver", null, new TreeDumperNode[] { Visit(node.Receiver, null) }),
            new TreeDumperNode("lengthOrCountProperty", node.LengthOrCountProperty, null),
            new TreeDumperNode("patternSymbol", node.PatternSymbol, null),
            new TreeDumperNode("argument", null, new TreeDumperNode[] { Visit(node.Argument, null) }),
            new TreeDumperNode("type", node.Type, null),
            new TreeDumperNode("isSuppressed", node.IsSuppressed, null),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitDynamicIndexerAccess(LoweredDynamicIndexerAccess node, object? arg) => new TreeDumperNode("dynamicIndexerAccess", null, new TreeDumperNode[]
        {
            new TreeDumperNode("receiverOpt", null, new TreeDumperNode[] { Visit(node.ReceiverOpt, null) }),
            new TreeDumperNode("arguments", null, from x in node.Arguments select Visit(x, null)),
            new TreeDumperNode("argumentNamesOpt", node.ArgumentNamesOpt, null),
            new TreeDumperNode("argumentRefKindsOpt", node.ArgumentRefKindsOpt, null),
            new TreeDumperNode("applicableIndexers", node.ApplicableIndexers, null),
            new TreeDumperNode("type", node.Type, null),
            new TreeDumperNode("isSuppressed", node.IsSuppressed, null),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitLambda(LoweredLambda node, object? arg) => new TreeDumperNode("lambda", null, new TreeDumperNode[]
        {
            new TreeDumperNode("unboundLambda", null, new TreeDumperNode[] { Visit(node.UnboundLambda, null) }),
            new TreeDumperNode("symbol", node.Symbol, null),
            new TreeDumperNode("body", null, new TreeDumperNode[] { Visit(node.Body, null) }),
            new TreeDumperNode("diagnostics", node.Diagnostics, null),
            new TreeDumperNode("binder", node.Binder, null),
            new TreeDumperNode("type", node.Type, null),
            new TreeDumperNode("isSuppressed", node.IsSuppressed, null),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitUnboundLambda(UnboundLambda node, object? arg) => new TreeDumperNode("unboundLambda", null, new TreeDumperNode[]
        {
            new TreeDumperNode("data", node.Data, null),
            new TreeDumperNode("type", node.Type, null),
            new TreeDumperNode("isSuppressed", node.IsSuppressed, null),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitQueryClause(LoweredQueryClause node, object? arg) => new TreeDumperNode("queryClause", null, new TreeDumperNode[]
        {
            new TreeDumperNode("value", null, new TreeDumperNode[] { Visit(node.Value, null) }),
            new TreeDumperNode("definedSymbol", node.DefinedSymbol, null),
            new TreeDumperNode("operation", null, new TreeDumperNode[] { Visit(node.Operation, null) }),
            new TreeDumperNode("cast", null, new TreeDumperNode[] { Visit(node.Cast, null) }),
            new TreeDumperNode("binder", node.Binder, null),
            new TreeDumperNode("unoptimizedForm", null, new TreeDumperNode[] { Visit(node.UnoptimizedForm, null) }),
            new TreeDumperNode("type", node.Type, null),
            new TreeDumperNode("isSuppressed", node.IsSuppressed, null),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitTypeOrInstanceInitializers(LoweredTypeOrInstanceInitializers node, object? arg) => new TreeDumperNode("typeOrInstanceInitializers", null, new TreeDumperNode[]
        {
            new TreeDumperNode("statements", null, from x in node.Statements select Visit(x, null)),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitNameOfOperator(LoweredNameOfOperator node, object? arg) => new TreeDumperNode("nameOfOperator", null, new TreeDumperNode[]
        {
            new TreeDumperNode("argument", null, new TreeDumperNode[] { Visit(node.Argument, null) }),
            new TreeDumperNode("constantValueOpt", node.ConstantValueOpt, null),
            new TreeDumperNode("type", node.Type, null),
            new TreeDumperNode("isSuppressed", node.IsSuppressed, null),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitInterpolatedString(LoweredInterpolatedString node, object? arg) => new TreeDumperNode("interpolatedString", null, new TreeDumperNode[]
        {
            new TreeDumperNode("parts", null, from x in node.Parts select Visit(x, null)),
            new TreeDumperNode("type", node.Type, null),
            new TreeDumperNode("isSuppressed", node.IsSuppressed, null),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitStringInsert(LoweredStringInsert node, object? arg) => new TreeDumperNode("stringInsert", null, new TreeDumperNode[]
        {
            new TreeDumperNode("value", null, new TreeDumperNode[] { Visit(node.Value, null) }),
            new TreeDumperNode("alignment", null, new TreeDumperNode[] { Visit(node.Alignment, null) }),
            new TreeDumperNode("format", null, new TreeDumperNode[] { Visit(node.Format, null) }),
            new TreeDumperNode("type", node.Type, null),
            new TreeDumperNode("isSuppressed", node.IsSuppressed, null),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitIsPatternExpression(LoweredIsPatternExpression node, object? arg) => new TreeDumperNode("isPatternExpression", null, new TreeDumperNode[]
        {
            new TreeDumperNode("expression", null, new TreeDumperNode[] { Visit(node.Expression, null) }),
            new TreeDumperNode("pattern", null, new TreeDumperNode[] { Visit(node.Pattern, null) }),
            new TreeDumperNode("decisionDag", null, new TreeDumperNode[] { Visit(node.DecisionDag, null) }),
            new TreeDumperNode("whenTrueLabel", node.WhenTrueLabel, null),
            new TreeDumperNode("whenFalseLabel", node.WhenFalseLabel, null),
            new TreeDumperNode("type", node.Type, null),
            new TreeDumperNode("isSuppressed", node.IsSuppressed, null),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitConstantPattern(LoweredConstantPattern node, object? arg) => new TreeDumperNode("constantPattern", null, new TreeDumperNode[]
        {
            new TreeDumperNode("value", null, new TreeDumperNode[] { Visit(node.Value, null) }),
            new TreeDumperNode("constantValue", node.ConstantValue, null),
            new TreeDumperNode("inputType", node.InputType, null),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitDiscardPattern(LoweredDiscardPattern node, object? arg) => new TreeDumperNode("discardPattern", null, new TreeDumperNode[]
        {
            new TreeDumperNode("inputType", node.InputType, null),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitDeclarationPattern(LoweredDeclarationPattern node, object? arg) => new TreeDumperNode("declarationPattern", null, new TreeDumperNode[]
        {
            new TreeDumperNode("variable", node.Variable, null),
            new TreeDumperNode("variableAccess", null, new TreeDumperNode[] { Visit(node.VariableAccess, null) }),
            new TreeDumperNode("declaredType", null, new TreeDumperNode[] { Visit(node.DeclaredType, null) }),
            new TreeDumperNode("isVar", node.IsVar, null),
            new TreeDumperNode("inputType", node.InputType, null),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitRecursivePattern(LoweredRecursivePattern node, object? arg) => new TreeDumperNode("recursivePattern", null, new TreeDumperNode[]
        {
            new TreeDumperNode("declaredType", null, new TreeDumperNode[] { Visit(node.DeclaredType, null) }),
            new TreeDumperNode("deconstructMethod", node.DeconstructMethod, null),
            new TreeDumperNode("deconstruction", null, node.Deconstruction.IsDefault ? Array.Empty<TreeDumperNode>() : from x in node.Deconstruction select Visit(x, null)),
            new TreeDumperNode("properties", null, node.Properties.IsDefault ? Array.Empty<TreeDumperNode>() : from x in node.Properties select Visit(x, null)),
            new TreeDumperNode("variable", node.Variable, null),
            new TreeDumperNode("variableAccess", null, new TreeDumperNode[] { Visit(node.VariableAccess, null) }),
            new TreeDumperNode("isExplicitNotNullTest", node.IsExplicitNotNullTest, null),
            new TreeDumperNode("inputType", node.InputType, null),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitITuplePattern(LoweredITuplePattern node, object? arg) => new TreeDumperNode("iTuplePattern", null, new TreeDumperNode[]
        {
            new TreeDumperNode("getLengthMethod", node.GetLengthMethod, null),
            new TreeDumperNode("getItemMethod", node.GetItemMethod, null),
            new TreeDumperNode("subpatterns", null, from x in node.Subpatterns select Visit(x, null)),
            new TreeDumperNode("inputType", node.InputType, null),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitSubpattern(LoweredSubpattern node, object? arg) => new TreeDumperNode("subpattern", null, new TreeDumperNode[]
        {
            new TreeDumperNode("symbol", node.Symbol, null),
            new TreeDumperNode("pattern", null, new TreeDumperNode[] { Visit(node.Pattern, null) }),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitDiscardExpression(LoweredDiscardExpression node, object? arg) => new TreeDumperNode("discardExpression", null, new TreeDumperNode[]
        {
            new TreeDumperNode("type", node.Type, null),
            new TreeDumperNode("isSuppressed", node.IsSuppressed, null),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitThrowExpression(LoweredThrowExpression node, object? arg) => new TreeDumperNode("throwExpression", null, new TreeDumperNode[]
        {
            new TreeDumperNode("expression", null, new TreeDumperNode[] { Visit(node.Expression, null) }),
            new TreeDumperNode("type", node.Type, null),
            new TreeDumperNode("isSuppressed", node.IsSuppressed, null),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitOutVariablePendingInference(OutVariablePendingInference node, object? arg) => new TreeDumperNode("outVariablePendingInference", null, new TreeDumperNode[]
        {
            new TreeDumperNode("variableSymbol", node.VariableSymbol, null),
            new TreeDumperNode("receiverOpt", null, new TreeDumperNode[] { Visit(node.ReceiverOpt, null) }),
            new TreeDumperNode("type", node.Type, null),
            new TreeDumperNode("isSuppressed", node.IsSuppressed, null),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitDeconstructionVariablePendingInference(DeconstructionVariablePendingInference node, object? arg) => new TreeDumperNode("deconstructionVariablePendingInference", null, new TreeDumperNode[]
        {
            new TreeDumperNode("variableSymbol", node.VariableSymbol, null),
            new TreeDumperNode("receiverOpt", null, new TreeDumperNode[] { Visit(node.ReceiverOpt, null) }),
            new TreeDumperNode("type", node.Type, null),
            new TreeDumperNode("isSuppressed", node.IsSuppressed, null),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitOutDeconstructVarPendingInference(OutDeconstructVarPendingInference node, object? arg) => new TreeDumperNode("outDeconstructVarPendingInference", null, new TreeDumperNode[]
        {
            new TreeDumperNode("type", node.Type, null),
            new TreeDumperNode("isSuppressed", node.IsSuppressed, null),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitNonConstructorMethodBody(LoweredNonConstructorMethodBody node, object? arg) => new TreeDumperNode("nonConstructorMethodBody", null, new TreeDumperNode[]
        {
            new TreeDumperNode("blockBody", null, new TreeDumperNode[] { Visit(node.BlockBody, null) }),
            new TreeDumperNode("expressionBody", null, new TreeDumperNode[] { Visit(node.ExpressionBody, null) }),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitConstructorMethodBody(LoweredConstructorMethodBody node, object? arg) => new TreeDumperNode("constructorMethodBody", null, new TreeDumperNode[]
        {
            new TreeDumperNode("locals", node.Locals, null),
            new TreeDumperNode("initializer", null, new TreeDumperNode[] { Visit(node.Initializer, null) }),
            new TreeDumperNode("blockBody", null, new TreeDumperNode[] { Visit(node.BlockBody, null) }),
            new TreeDumperNode("expressionBody", null, new TreeDumperNode[] { Visit(node.ExpressionBody, null) }),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
        public override TreeDumperNode VisitExpressionWithNullability(LoweredExpressionWithNullability node, object? arg) => new TreeDumperNode("expressionWithNullability", null, new TreeDumperNode[]
        {
            new TreeDumperNode("expression", null, new TreeDumperNode[] { Visit(node.Expression, null) }),
            new TreeDumperNode("nullableAnnotation", node.NullableAnnotation, null),
            new TreeDumperNode("type", node.Type, null),
            new TreeDumperNode("isSuppressed", node.IsSuppressed, null),
            new TreeDumperNode("hasErrors", node.HasErrors, null)
        }
        );
    }
}
